

		  /*
		  {
		    CuttableVoronoiData cvd_tmp;
		    vdReturnDataVec[ii_fp].extractGroupAsCvd(cvd_tmp,0);
		    cvd_tmp.writeTecplot(0);
		  }
		  cvd_copy.writeTecplot(1);
		  
		  for (int ino_copy = 0; ino_copy < cvd_copy.nno; ++ino_copy) {
		    // find the closest node in vdReturnDataVec[ii_fp]...
		    int ino_closest = -1;
		    double d2_closest;
		    for (int ino = 0; ino <  vdReturnDataVec[ii_fp].nno; ++ino) {
		      const double d2 = DIST2(cvd_copy.x_no[ino_copy],vdReturnDataVec[ii_fp].x_no[ino]);
		      if ((ino_closest == -1)||(d2 < d2_closest)) {
			ino_closest = ino;
			d2_closest = d2;
		      }
		    }
		    cout << "got ino_closest: " << ino_closest << " with d2_closest: " << d2_closest << endl;
		    FILE * fp = fopen("node.dat","w");
		    fprintf(fp,"%18.15e %18.15e %18.15e\n",
			    cvd_copy.x_no[ino_copy][0],
			    cvd_copy.x_no[ino_copy][1],
			    cvd_copy.x_no[ino_copy][2]);
		    fprintf(fp,"%18.15e %18.15e %18.15e\n",
			    vdReturnDataVec[ii_fp].x_no[ino_closest][0],
			    vdReturnDataVec[ii_fp].x_no[ino_closest][1],
			    vdReturnDataVec[ii_fp].x_no[ino_closest][2]);
		    fclose(fp);

		    bool b_stop = false;

		    // cvd_copy's edges...
		    cout << "cvd_copy faoed for this node: " << endl;
		    assert(icv_or == cgoor[ior][0]);
		    cout << " > icv_or: " << icv_or << " icv_fp: " << icv_fp << endl;
		    for (int ied = 0; ied < cvd_copy.ned; ++ied) {
		      FOR_I2 {
			if (cvd_copy.nooed[ied][i] == ino_copy) {
			  FOR_J2 {
			    const int ifa = cvd_copy.faoed[ied][j];
			    if (ifa >= 0) {
			      const int ist = vdReturnDataVec[ii_or].spbobf[ifa][0];
			      const int ipart_bits = vdReturnDataVec[ii_or].spbobf[ifa][1];
			      cout << " > ist: " << ist << " ipart_bits: " << ipart_bits << endl;
			    }
			    else if (ifa <= -ORPHAN_FACE_OFFSET) {
			      // this face was cut during the current orphan-chunk cutting... 
			      cout << " > icv_nbr (orphan cut with icv_fp): " << nbrVec[-ifa-ORPHAN_FACE_OFFSET].second << endl;
			      b_stop = true;
			    }
			    else {
			      // this ifa is -8 index'd into cvofa: recall it was adjusted above to
			      // allow recutting with the cut routine...
			      cout << " > icv_nbr (original cut with icv_or): " << vdReturnDataVec[ii_or].cvofa[-ifa-8] << endl;
			    }
			  }
			}
		      }
		    }
		    
		    // foster parent's associated edges...
		    cout << "foster-parent's faoed for this node: " << endl;
		    cout << " > icv_fp: " << vdReturnDataVec[ii_fp].icv << endl;
		    for (int ied = 0; ied < vdReturnDataVec[ii_fp].edogr_i[1]; ++ied) {
		      FOR_I2 {
			if (vdReturnDataVec[ii_fp].nooed[ied][i] == ino_closest) {
			  FOR_J2 {
			    const int ifa = vdReturnDataVec[ii_fp].faoed[ied][j];
			    if (ifa >= 0) {
			      const int ist = vdReturnDataVec[ii_fp].spbobf[ifa][0];
			      const int ipart_bits = vdReturnDataVec[ii_fp].spbobf[ifa][1];
			      cout << " > ist: " << ist << " ipart_bits: " << ipart_bits << endl;
			    }
			    else {
			      // ifa is -1 index'd into cvofa...
			      cout << " > icv_nbr: " << vdReturnDataVec[ii_fp].cvofa[-ifa-1] << endl;
			    }
			  }
			}
		      }
		    }
		    
		    cout << "TAKE A LOOK" << endl;
		    if (b_stop) getchar();
		    
		  }
		  */


	/*
	  for (int cog = cvogr_i[igr_or]; cog != cvogr_i[igr_or+1]; ++cog) {
          int ixvd = cvogr_v[cog];
	  
	  // make sure this guy is in 
	  {
	  set<int>::iterator it = final_cvoor_set[ior].find(ixvd);
	  assert(it != final_cvoor_set[ior].end());
	  final_cvoor_set[ior].erase(it);
	  }

          if (ixvd >= 0) {
	  const double d2 = DIST2(x_no_avg,x_vd[ixvd]);
	  if ((ii_min == -1)||(d2 < d2_min)) {
	  ii_min = nbrVec.size();
	  d2_min = d2;
	  }
	  nbrVec.push_back(pair<double,int>(d2,ixvd));
          }
          else {
	  const double d2 = DIST2(x_no_avg,x_vd_ghost[-ixvd-1]);
	  if ((ii_min == -1)||(d2 < d2_min)) {
	  ii_min = nbrVec.size();
	  d2_min = d2;
	  }
	  nbrVec.push_back(pair<double,int>(d2,ixvd));
          }
	  }
	*/

	/*
	if (icv_debug == icv_or) {

	  vdReturnDataVec[ii_or].writeTecplot("main_all.dat",x_vd[icv_or]);
	  
	  FILE * fp = fopen("nbrs.dat","w");
	  for (set<int>::iterator it = final_cvoor_set[ior].begin(); it != final_cvoor_set[ior].end(); ++it) {
	    const int ixvd = *it;
	    if (ixvd >= 0) {
	      cout << "icv_debug ixvd: " << ixvd << " x: " << COUT_VEC(x_vd[ixvd]) << endl;
	      fprintf(fp,"%18.15e %18.15e %18.15e\n",x_vd[ixvd][0],x_vd[ixvd][1],x_vd[ixvd][2]);
	    }
	    else {
	      assert(0);
	    }
	  }
	  fclose(fp);

	  cout << "icv_or: " << icv_or << " igr_or: " << igr_or << " out of " << vdReturnDataVec[ii_or].ngr << " take a look!" << endl;
	  getchar();
	  
	}
	*/
		



  /*
  
  class Int4 {
  public:
    int data[4];
    Int4() {
      data[0] = -1;
      data[1] = -1;
      data[2] = -1;
      data[3] = -1;
    }
    void clear() {
      data[0] = -1;
      data[1] = -1;
      data[2] = -1;
      data[3] = -1;
    }
    inline bool operator < (const Int4& other) const {
      return((this->data[0] < other.data[0])||
	     ((this->data[0] == other.data[0])&&
	      ((this->data[1] < other.data[1])||
	       ((this->data[1] == other.data[1])&&
		((this->data[2] < other.data[2])||
		 ((this->data[2] == other.data[2])&&
		  (this->data[3] < other.data[3])))))));
    }
    inline bool operator == (const Int4& other) const {
      return((this->data[0] == other.data[0])&&
	     (this->data[1] == other.data[1])&&
	     (this->data[2] == other.data[2])&&
	     (this->data[3] == other.data[3]));
    }
    void add(const int value) {
      assert(value != -1);
      if (data[0] == -1) {
	data[0] = value;
	return;
      }
      else if (value == data[0]) {
	return;
      }
      else if (value < data[0]) {
	assert((data[3] == -1)||(value >= 0));
	data[3] = data[2];
	data[2] = data[1];
	data[1] = data[0];
	data[0] = value;
      }
      else if (data[1] == -1) {
	data[1] = value;
	return;
      }
      else if (value == data[1]) {
	return;
      }
      else if (value < data[1]) {
	assert((data[3] == -1)||(data[0] >= 0));
	data[3] = data[2];
	data[2] = data[1];
	data[1] = value;
      }
      else if (data[2] == -1) {
	data[2] = value;
	return;
      }
      else if (value == data[2]) {
	return;
      }
      else if (value < data[2]) {
	assert((data[3] == -1)||(data[0] >= 0));
	data[3] = data[2];
	data[2] = value;
      }
      else if (data[3] == -1) {
	data[3] = value;
	return;
      }
      else if (value == data[3]) {
	return;
      }
      else {
	if (data[0] < 0) {
	  cout << "being asked to add value: " << value << " to data: " << data[0] << " " << data[1] << " " << data[2] << " " << data[3] << endl;
	  throw(0);
	}
	//assert(data[0] >= 0);
      }
    }
    };
    
  */



      int nno_max = 0;
      for (int ior = 0; ior < nor; ++ior) {
        const int icv = cgoor[ior][0];
        const int ii = ivrdocv[icv]; assert((ii >= 0)&&(ii < vdReturnDataVec.size()));
        nno_max = max(nno_max,vdReturnDataVec[ii].nno);
      }
      set<pair<double,int> >* closestSet = new set<pair<double,int> >[nno_max];
      while (!b_done) {
        b_done = true;
        set<pair<int,int> >::iterator it = orphanLinkSet.begin(); 
        for (int ior = 0; ior < nor; ++ior) {
          const int icv = cgoor[ior][0];
          const int igr = cgoor[ior][1]; 
          const double d2_tol = 1.0E-12*delta_vd[icv]*delta_vd[icv]; // dist2 tolerance for coincident nodes
          const int ii = ivrdocv[icv]; assert((ii >= 0)&&(ii < vdReturnDataVec.size()));
          while (it->first == ior) {
            const int ior_nbr = it->second;
            const int icv_nbr = cgoor[ior_nbr][0];
            const int igr_nbr = cgoor[ior_nbr][1];
            for (int ied = vdReturnDataVec[ii].edogr_i[igr]; ied != vdReturnDataVec[ii].edogr_i[igr+1]; ++ied) {
              FOR_I2 {
                const int ifa = vdReturnDataVec[ii].faoed[ied][i];
                if (ifa < 0) {
                  if (icv_nbr == vdReturnDataVec[ii].cvofa[-ifa-1]) {
                    // found face corresonding to orphan nbr...
                    for (set<int>::iterator it2 = nboor_set[ior_nbr].begin(); it2 != nboor_set[ior_nbr].end(); ++it2) {
                      FOR_J2 {
                        const int ino = vdReturnDataVec[ii].nooed[ied][j];
                        double x_no[3]; FOR_K3 x_no[k] = vdReturnDataVec[ii].x_no[ino][k]+x_vd[icv][k];
                        const double dist2 = DIST2(x_no,x_vd[icv_nbr]);
                        if (closestSet[ino].empty()) {
                          closestSet[ino].insert(pair<double,int>(dist2,icv_nbr));
                        }
                        else if (dist2 < (d2_tol+closestSet[ino].begin()->first)) {
                          // new closest guy, so clear all others
                          if (dist2 < (-d2_tol+closestSet[ino].begin()->first))
                            closestSet[ino].clear();
                          closestSet[ino].insert(pair<double,int>(dist2,icv_nbr));
                        }
                      }
                    }
                  }
                }
              }
            }
            // go to next orphan nbr...
            ++it; 
          }
          // closestSet should have all the guys that can potentially cut me, add to nboor_set
          for (int ino = 0; ino < vdReturnDataVec[ii].nno; ++ino) {
            for (set<pair<double,int> >::iterator it2 = closestSet[ino].begin(); it2 != closestSet[ino].end(); ++it2) {
              if (nboor_set[ior].find(it2->second) == nboor_set[ior].end()) {
                // found new nbr so we will iterate again...
                b_done = false;
                nboor_set[ior].insert(it2->second);
              }
            }
            closestSet[ino].clear();
          }
        }
      }
      delete[] closestSet;
      


      MPI_Pause("XXXXXXXXXXXXXX ===================== OKOK ====================== YYYY");

      
      assert(0);







#ifdef JUNKJUNK









































































      set<pair<pair<int,int>,int> > cv_spb_set; // put cv last so the sort is on spb
      set<pair<int,int> > orphan_spb_set;

      for (int ii = 0; ii < vdReturnDataVec.size(); ++ii) {
        const int icv = vdReturnDataVec[ii].icv;
        if (icv >= 0) {

          // for the first group, associate the cvs with the ist, ipart/bits on the set of tris...
          
          int igr = 0;
          for (int ied = vdReturnDataVec[ii].edogr_i[igr]; ied != vdReturnDataVec[ii].edogr_i[igr+1]; ++ied) {
            FOR_I2 {
              const int ifa = vdReturnDataVec[ii].faoed[ied][i];
              if (ifa >= 0) {
                assert(ifa < vdReturnDataVec[ii].nbf);
                // this face references a particular ist and part_bits...
                const int ist = vdReturnDataVec[ii].spbobf[ifa][0];
                const int ipart_bits = vdReturnDataVec[ii].spbobf[ifa][1];
                const int ipart = (ipart_bits>>6);
                const int bits = (ipart_bits&MASK_6BITS);
                assert(bits == 0);
                // push icv as a rbi into this ist...
                cv_spb_set.insert(pair<pair<int,int>,int>(pair<int,int>(ist,ipart_bits),icv));
              }
            }
          }

          // for the remaining groups of orphans, just insert into the simple orphan_spb_set, because 
          // these will simply take -1 to indicate the touching of an orphan...

          for (igr = 1; igr < vdReturnDataVec[ii].ngr; ++igr) {
            for (int ied = vdReturnDataVec[ii].edogr_i[igr]; ied != vdReturnDataVec[ii].edogr_i[igr+1]; ++ied) {
              FOR_I2 {
                const int ifa = vdReturnDataVec[ii].faoed[ied][i];
                if (ifa >= 0) {
                  assert(ifa < vdReturnDataVec[ii].nbf);
                  // this face references a particular ist and part_bits...
                  const int ist = vdReturnDataVec[ii].spbobf[ifa][0];
                  const int ipart_bits = vdReturnDataVec[ii].spbobf[ifa][1];
                  assert(ipart_bits == 0); // TODO: be more consistent with handling part & bits in one int (i.e. use pack/unpack routines)
                  const int ipart = (ipart_bits>>6);
                  const int bits = (ipart_bits&MASK_6BITS);
                  assert(bits == 0);
                  // push icv as a rbi into this ist...
                  orphan_spb_set.insert(pair<int,int>(ist,ipart_bits));
                }
              }
            }
          }
        }
      }

      // at this point, we partition to global surface across ALL processors. Eventually 
      // this will require multiple parts, and ist indexing will need to consider some kind
      // of flattening of the total number of surface tris, but for now, assume just 1 part...

      assert(partVec.size() == 1);
      assert(partVec[0]->surface);
      const int nst_flattened_global = partVec[0]->surface->nst;
      int * stora = NULL;
      MiscUtils::buildUniformXora(stora,nst_flattened_global);
      const int nst_flattened = stora[mpi_rank+1] - stora[mpi_rank];
      
      // now all the cv data out to the correct tri on the correct rank...
      
      int * send_count = new int[mpi_size];
      FOR_RANK send_count[rank] = 0;

      for (set<pair<pair<int,int>,int> >::iterator it = cv_spb_set.begin(); it != cv_spb_set.end(); ++it) {
        const int ist = it->first.first;        
        const int ipart_bits = it->first.second;
        assert(ipart_bits == 0); // no periodicity and part == 0
        const int rank = MiscUtils::getRankInXora(ist,stora);
        send_count[rank] += 3;
      }

      int * send_disp = new int[mpi_size];
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
      
      int * send_buf_int = new int[send_count_sum];

      for (set<pair<pair<int,int>,int> >::iterator it = cv_spb_set.begin(); it != cv_spb_set.end(); ++it) {
        const int ist = it->first.first;        
        const int ipart_bits = it->first.second;
        assert(ipart_bits == 0); // no periodicity and part == 0
        const int rank = MiscUtils::getRankInXora(ist,stora);
        send_buf_int[send_disp[rank]  ] = ist;
        send_buf_int[send_disp[rank]+1] = BitUtils::packRankBits(mpi_rank,0);
        send_buf_int[send_disp[rank]+2] = it->second; // icv
        send_disp[rank] += 3;
      }
      cv_spb_set.clear();
      
      // rewind...
        
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      
      // set up recv-side stuff...
      
      int * recv_count = new int[mpi_size];
      MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
      
      int * recv_disp = new int[mpi_size];
      recv_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
      int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];

      int * recv_buf_int = new int[recv_count_sum];
      
      MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
                    recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
      delete[] send_buf_int; send_buf_int = NULL;

      // unpack the cvs into the striped flattened st structure...
      
      int * cvost_i = new int[nst_flattened+1];
      for (int ist = 0; ist < nst_flattened; ++ist)
        cvost_i[ist+1] = 0;

      for (int irecv = 0 ; irecv < recv_count_sum; irecv += 3) {
        const int ist_flattened = recv_buf_int[irecv];
        assert((ist_flattened >= stora[mpi_rank])&&(ist_flattened < stora[mpi_rank+1]));
        const int ist = ist_flattened - stora[mpi_rank]; 
        ++cvost_i[ist+1];
      }
      
      cvost_i[0] = 0;
      for (int ist = 0; ist < nst_flattened; ++ist)
        cvost_i[ist+1] += cvost_i[ist];

      const int cvost_s = cvost_i[nst_flattened];
      assert(cvost_s == recv_count_sum/3);
      int (*cvost_v)[2] = new int[cvost_s][2];
      
      for (int irecv = 0 ; irecv < recv_count_sum; irecv += 3) {
        const int ist_flattened = recv_buf_int[irecv];
        assert((ist_flattened >= stora[mpi_rank])&&(ist_flattened < stora[mpi_rank+1]));
        const int ist = ist_flattened - stora[mpi_rank]; 
        const int rank_bits = recv_buf_int[irecv+1];
        const int icv = recv_buf_int[irecv+2];
        cvost_v[cvost_i[ist]][0] = rank_bits;
        cvost_v[cvost_i[ist]][1] = icv;
        ++cvost_i[ist];
      }
      delete[] recv_buf_int; recv_buf_int = NULL;
      
      // rewind csr...
      
      for (int ist = nst_flattened-1; ist > 0; --ist)
        cvost_i[ist] = cvost_i[ist-1];
      cvost_i[0] = 0;
      
      // now send over which st's touch orphans...
      
      FOR_RANK send_count[rank] = 0;
      
      for (set<pair<int,int> >::iterator it = orphan_spb_set.begin(); it != orphan_spb_set.end(); ++it) {
        const int ist = it->first;        
        const int ipart_bits = it->second;
        assert(ipart_bits == 0); // no periodicity and part == 0
        const int rank = MiscUtils::getRankInXora(ist,stora);
        ++send_count[rank];
      }
      
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
      
      assert(send_buf_int == NULL);
      send_buf_int = new int[send_count_sum];

      for (set<pair<int,int> >::iterator it = orphan_spb_set.begin(); it != orphan_spb_set.end(); ++it) {
        const int ist = it->first;        
        const int ipart_bits = it->second;
        assert(ipart_bits == 0); // no periodicity and part == 0
        const int rank = MiscUtils::getRankInXora(ist,stora);
        send_buf_int[send_disp[rank]] = ist;
        ++send_disp[rank];
      }
      orphan_spb_set.clear(); // might be wise to keep this for later?
      
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      
      // set up recv-side stuff...
      
      MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
      
      recv_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
      recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
      
      assert(recv_buf_int == NULL);
      recv_buf_int = new int[recv_count_sum];
      
      MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
                    recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
      delete[] send_buf_int; send_buf_int = NULL;

      int * st_flag = new int[nst_flattened];
      for (int ist = 0; ist < nst_flattened; ++ist)
        st_flag[ist] = -1;
      
      for (int irecv = 0 ; irecv < recv_count_sum; ++irecv) {
        const int ist_flattened = recv_buf_int[irecv];
        assert((ist_flattened >= stora[mpi_rank])&&(ist_flattened < stora[mpi_rank+1]));
        const int ist = ist_flattened - stora[mpi_rank];
        st_flag[ist] = 0;
      }
      delete[] recv_buf_int; recv_buf_int = NULL;

      int nst_orphan = 0;
      for (int ist = 0; ist < nst_flattened; ++ist) {
        if (st_flag[ist] == 0) {
          st_flag[ist] = nst_orphan++;
        }
        else { 
          assert(st_flag[ist] == -1);
        }
      }
      
      // report the max and average number of cvs per tri. This is an interesting measure
      // of the resolution between the tris and the volume mesh...
      
      {
        int8 my_i8buf[2] = { cvost_s, nst_orphan };
        int8 i8buf[2];
        MPI_Reduce(my_i8buf,i8buf,2,MPI_INT8,MPI_SUM,0,mpi_comm);
        if (mpi_rank == 0) 
          cout << " > flattened nst: " << nst_flattened_global << " avg cvs/tri: " << double(i8buf[0])/double(nst_flattened_global) << " tris with orphans: " << i8buf[1] << endl;
      }
      
      // -----------------------------------------------------------------------------
      // At this point, the st's touching orphans are identified in st_flag, and have
      // a local count of nst_orphan. 
      // -----------------------------------------------------------------------------
      
      // step 1: all orphans get nbr accessors...
      
      int (*oroor)[3] = new int[nst_orphan][3];
      for (int ist_orphan = 0; ist_orphan < nst_orphan; ++ist_orphan)
        FOR_I3 oroor[ist_orphan][i] = -1;

      // step 2: now use the connectivity of the parts to walk from the orphan tris to edge-based
      // nbrs...
      
      // use double* pair to indicate which edge we are talking about. This means
      // we don't have to worry about which part any tri is from, this will keep them unique...
      
      map<const pair<double*,double*>,int> edgeMap;
      for (int ist = 0; ist < nst_flattened; ++ist) {
        if (st_flag[ist] >= 0) {
          const int ist_orphan = st_flag[ist];
          // and look for our nbrs...
          const int ist_flattened = ist + stora[mpi_rank];
          FOR_I3 {
            double * x0 = partVec[0]->surface->xsp[partVec[0]->surface->spost[ist_flattened][i]];
            double * x1 = partVec[0]->surface->xsp[partVec[0]->surface->spost[ist_flattened][(i+1)%3]];
            // check if this edge is already in edgeMap...
            map<const pair<double*,double*>,int>::iterator it = edgeMap.find(pair<double*,double*>(x1,x0));
            if (it == edgeMap.end()) {
              // there is no edge in the current map, so add ours, recording the orphan index...
              edgeMap[pair<double*,double*>(x0,x1)] = ((ist_orphan<<2)|i); // teost-like to get orphan and edge in one int
            }
            else {
              const int ist_orphan_nbr = (it->second>>2);
              assert((ist_orphan_nbr >= 0)&&(ist_orphan_nbr < nst_orphan));
              const int i_nbr = (it->second&3);
              assert((i_nbr >= 0)&&(i_nbr < 3));
              edgeMap.erase(it);
              // these two LOCAL orphans are connected...
              assert(oroor[ist_orphan][i] == -1);
              oroor[ist_orphan][i] = ist_orphan_nbr;
              assert(oroor[ist_orphan_nbr][i_nbr] == -1);
              oroor[ist_orphan_nbr][i_nbr] = ist_orphan;
            }
          }
        }
      }

      // set 2.5: all local orphans are connected. So build the groups...
      
      int * orphan_group = new int[nst_orphan];
      for (int ist_orphan = 0; ist_orphan < nst_orphan; ++ist_orphan)
        orphan_group[ist_orphan] = ist_orphan;
      
      // use connectivity to reduce the groups...  
      for (int ist_orphan = 0; ist_orphan < nst_orphan; ++ist_orphan) {
        FOR_I3 {
          int ist_orphan_nbr = oroor[ist_orphan][i];
          // only consider one of the connection directions...
          if (ist_orphan_nbr > ist_orphan) {
            assert(ist_orphan_nbr < nst_orphan);
            int igr = orphan_group[ist_orphan];
            while (igr != orphan_group[igr])
              igr = orphan_group[igr];
            int igr_nbr = orphan_group[ist_orphan_nbr];
            while (igr_nbr != orphan_group[igr_nbr])
              igr_nbr = orphan_group[igr_nbr];
            orphan_group[igr] = orphan_group[igr_nbr] = min(igr,igr_nbr);
          }
        }
      }

      int ngr_orphan = 0;
      for (int ist_orphan = 0; ist_orphan < nst_orphan; ++ist_orphan) {
        if (orphan_group[ist_orphan] == ist_orphan) {
          ++ngr_orphan;
          orphan_group[ist_orphan] = -ngr_orphan; // use -1 indexing...
        }
        else {
          int igr = orphan_group[ist_orphan];
          while (igr >= 0) 
            igr = orphan_group[igr];
          orphan_group[ist_orphan] = igr;
        }
      }
      
      for (int ist_orphan = 0; ist_orphan < nst_orphan; ++ist_orphan) {
        orphan_group[ist_orphan] = -orphan_group[ist_orphan]-1;
        assert((orphan_group[ist_orphan] >= 0)&&(orphan_group[ist_orphan] < ngr_orphan));
      }

      // use one set per group. This avoids having to do any local iteration...
      
      set<pair<int,int> > * orphan_group_set = new set<pair<int,int> >[ngr_orphan];
      
      // start groups by inserting local cvost info...

      for (int ist = 0; ist < nst_flattened; ++ist) {
        if (st_flag[ist] >= 0) {
          const int ist_orphan = st_flag[ist];
          const int igr_orphan = orphan_group[ist_orphan];
          assert((igr_orphan >= 0)&&(igr_orphan < ngr_orphan));
          // TODO: delay this until the orphans are grouped...
          // push any local existing data into the set...
          for (int cos = cvost_i[ist]; cos != cvost_i[ist+1]; ++cos) {
            orphan_group_set[igr_orphan].insert(pair<int,int>(cvost_v[cos][0],cvost_v[cos][1]));
          }
        }
      }
      
      // step 3: now we have an orphan patch with some connections between orphans...
      // the surrounding edges are in edgeMap...
      // walk the local non-orphan tris and push any cvost cvs into the orphans, and also
      // eliminate any edges that match...
      
      for (int ist = 0; ist < nst_flattened; ++ist) {
        if (st_flag[ist] == -1) {
          // and look for our nbrs...
          const int ist_flattened = ist + stora[mpi_rank];
          FOR_I3 {
            double * x0 = partVec[0]->surface->xsp[partVec[0]->surface->spost[ist_flattened][i]];
            double * x1 = partVec[0]->surface->xsp[partVec[0]->surface->spost[ist_flattened][(i+1)%3]];
            map<const pair<double*,double*>,int>::iterator it = edgeMap.find(pair<double*,double*>(x1,x0));
            if (it != edgeMap.end()) {
              const int ist_orphan_nbr = (it->second>>2);
              assert((ist_orphan_nbr >= 0)&&(ist_orphan_nbr < nst_orphan));
              const int i_nbr = (it->second&3);
              assert((i_nbr >= 0)&&(i_nbr < 3));
              edgeMap.erase(it);
              // this is a local edge between an orphan and a non-orphan. We only need to 
              // send our cvost info once to the orphan, and this connection for the orphan
              // never needs to be used again...
              assert(oroor[ist_orphan_nbr][i_nbr] == -1);
              oroor[ist_orphan_nbr][i_nbr] = -2; // turn off this connection
              // push any cvost stuff we have into this orphan...
              // get the group associated with ist_orphan_nbr...
              const int igr_orphan_nbr = orphan_group[ist_orphan_nbr];
              for (int cos = cvost_i[ist]; cos != cvost_i[ist+1]; ++cos) {
                orphan_group_set[igr_orphan_nbr].insert(pair<int,int>(cvost_v[cos][0],cvost_v[cos][1]));
              }
            }
          }
        }
      }
      
      // now we just need to deal with off-rank st's...
      // unfortunately we have to go through everyone else, and see if anyone touches our edges in edgeMap...
      
      map<const int,int> ghostMap;
      int nst_orphan_g = nst_orphan;

      for (int ist_flattened = 0; ist_flattened < nst_flattened_global; ++ist_flattened) {
        
        // make sure we and NOT in the current partition...
        
        if ((ist_flattened < stora[mpi_rank])||(ist_flattened >= stora[mpi_rank+1])) {
          
          // NOTE: if this is expensive in a large case (lots of tris), we could try and eliminate some of
          // the edgeMap.find routines with a bounding box check. Because we used pointers
          // to the surface node coordinates to denote edges, we can actually compute the 
          // bbox of the edgeMap fairly easily. But for now, lookup every edge in the map...
          
          FOR_I3 {
            double * x0 = partVec[0]->surface->xsp[partVec[0]->surface->spost[ist_flattened][i]];
            double * x1 = partVec[0]->surface->xsp[partVec[0]->surface->spost[ist_flattened][(i+1)%3]];
            map<const pair<double*,double*>,int>::iterator it = edgeMap.find(pair<double*,double*>(x1,x0));
            if (it != edgeMap.end()) {
              const int ist_orphan_nbr = (it->second>>2);
              assert((ist_orphan_nbr >= 0)&&(ist_orphan_nbr < nst_orphan));
              const int i_nbr = (it->second&3);
              assert((i_nbr >= 0)&&(i_nbr < 3));
              edgeMap.erase(it);
              // this is a local edge between an orphan and a non-orphan. We only need to 
              // send our cvost info once to the orphan, and this connection for the orphan
              // never needs to be used again...
              assert(oroor[ist_orphan_nbr][i_nbr] == -1);
              map<const int,int>::iterator it = ghostMap.find(ist_flattened);
              if (it == ghostMap.end()) {
                ghostMap[ist_flattened] = oroor[ist_orphan_nbr][i_nbr] = nst_orphan_g++;
              }
              else {
                oroor[ist_orphan_nbr][i_nbr] = it->second;
              }
            }
          }

        }

      }
      
      // at this point, the edgeMap should be empty...

      assert(edgeMap.empty());
      
      // loop through the ghostMap and build a message. Use alltoall for now, but cound be Prcomm eventually...
      
      FOR_RANK send_count[rank] = 0;
      int ist_orphan_g_check = nst_orphan;
      for (map<const int,int>::iterator it = ghostMap.begin(); it != ghostMap.end(); ++it) {
        const int ist_flattened = it->first;
        // because of the way that the flattened tris are partitioned and 
        // the ghostMap is sorted on flattened tris, this should be ordered already
        assert(ist_orphan_g_check == it->second);
        ++ist_orphan_g_check;
        const int rank = MiscUtils::getRankInXora(ist_flattened,stora);
        assert(rank != mpi_rank);
        ++send_count[rank];
      }
      
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
      assert(send_count_sum == nst_orphan_g-nst_orphan); // should just be ghost size
      
      assert(send_buf_int == NULL);
      send_buf_int = new int[send_count_sum];

      for (map<const int,int>::iterator it = ghostMap.begin(); it != ghostMap.end(); ++it) {
        const int ist_flattened = it->first;
        const int rank = MiscUtils::getRankInXora(ist_flattened,stora);
        assert(rank != mpi_rank);
        send_buf_int[send_disp[rank]] = ist_flattened;
        ++send_disp[rank];
      }
      
      // rewind send_disp...
      
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      
      // set up recv-side stuff...
      
      MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
      
      recv_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
      recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
      
      assert(recv_buf_int == NULL);
      recv_buf_int = new int[recv_count_sum];
      
      MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
                    recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
      
      // we need to store 

      int * recv_count2 = new int[mpi_size];
      FOR_RANK {
        recv_count2[rank] = 0;
        for (int irecv = recv_disp[rank]; irecv < recv_disp[rank]+recv_count[rank]; ++irecv) {
          const int ist_flattened = recv_buf_int[irecv];
          // should be in our patch of owned ist's...
          assert((ist_flattened >= stora[mpi_rank])&&(ist_flattened < stora[mpi_rank+1]));
          const int ist = ist_flattened - stora[mpi_rank];
          // may be orphan or just cv. If he's orphan only, then indicate to the 
          // calling process, otherwise we are going to send back all our icv nbrs once...
          if (st_flag[ist] == -1) {
            recv_count2[rank] += 2*(cvost_i[ist+1]-cvost_i[ist]);
          }
        }
      }
      
      int * recv_disp2 = new int[mpi_size];
      recv_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        recv_disp2[rank] = recv_count2[rank-1] + recv_disp2[rank-1];
      int recv_count_sum2 = recv_disp2[mpi_size-1] + recv_count2[mpi_size-1];
      
      int * recv_buf_int2 = new int[recv_count_sum2];
      
      int irecv2 = 0;
      for (int irecv = 0; irecv < recv_count_sum; ++irecv) {
        const int ist_flattened = recv_buf_int[irecv];
        // should be in our patch of owned ist's...
        assert((ist_flattened >= stora[mpi_rank])&&(ist_flattened < stora[mpi_rank+1]));
        const int ist = ist_flattened - stora[mpi_rank];
        // may be orphan or just cv. If he's orphan only, then indicate to the 
        // calling process, otherwise we are going to send back all our icv nbrs once...
        if (st_flag[ist] >= 0) {
          // an orphan!...
          const int ist_orphan = st_flag[ist];
          const int igr_orphan = orphan_group[ist_orphan];
          assert((igr_orphan >= 0)&&(igr_orphan < ngr_orphan));
          recv_buf_int[irecv] = -igr_orphan-1;
        }
        else {
          assert(st_flag[ist] == -1);
          recv_buf_int[irecv] = cvost_i[ist+1]-cvost_i[ist];
          for (int cos = cvost_i[ist]; cos != cvost_i[ist+1]; ++cos) {
            recv_buf_int2[irecv2 ] = cvost_v[cos][0];
            recv_buf_int2[irecv2+1] = cvost_v[cos][1];
            irecv2 += 2;
          }
        }
      }
      
      // send this info back...
      
      MPI_Alltoallv(recv_buf_int,recv_count,recv_disp,MPI_INT,
                    send_buf_int,send_count,send_disp,MPI_INT,
                    mpi_comm);
      
      // now we are back on the send side. We have either a POSTIVE count of
      // the number of rbi pairs we can expect from the next message, or 
      // a NEGATIVE number indicating an orphan connection...
      
      int * cvost_g_i = new int[send_count_sum+1];
      int * send_count2 = recv_count; // hijack recv_count for clarity
      
      map<const pair<int,int>,int> rankGroupMap;
      int group_unpack_size = 0;
      
      cvost_g_i[0] = 0;
      FOR_RANK {
        send_count2[rank] = 0;
        for (int isend = send_disp[rank]; isend < send_disp[rank]+send_count[rank]; ++isend) {
          if (send_buf_int[isend] < 0) {
            // this is an orphan. the send_buf_int has the nbr's group index as -1 indexing...
            const int igr_nbr = -send_buf_int[isend]-1;
            // we can't check if this is too large because we don't know how many groups the nbr has...
            map<const pair<int,int>,int>::iterator it = rankGroupMap.find(pair<int,int>(rank,igr_nbr));
            if (it == rankGroupMap.end()) {
              rankGroupMap[pair<int,int>(rank,igr_nbr)] = send_buf_int[isend] = group_unpack_size++;
            }
            else {
              send_buf_int[isend] = it->second;
            }
            cvost_g_i[isend+1] = cvost_g_i[isend]; // i.e. +0
          }
          else {
            // this guy is going to send back information, but just this once
            cvost_g_i[isend+1] = cvost_g_i[isend] + send_buf_int[isend];
            send_count2[rank] += 2*send_buf_int[isend];
            send_buf_int[isend] = -2;
          }
        }
      }
      
      // we now know how much data to expect (once) from the recv side...

      int * send_disp2 = recv_disp;
      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
        send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
      int send_count_sum2 = send_disp2[mpi_size-1] + send_count2[mpi_size-1];
      int * send_buf_int2 = new int[send_count_sum2];
      
      MPI_Alltoallv(recv_buf_int2,recv_count2,recv_disp2,MPI_INT,
                    send_buf_int2,send_count2,send_disp2,MPI_INT,
                    mpi_comm);
      delete[] recv_buf_int2; recv_buf_int2 = NULL;

      // now loop through the orphans, and incorporate the "once" data...
      
      set<pair<int,int> > gr_nbr_set;
      for (int ist_orphan = 0; ist_orphan < nst_orphan; ++ist_orphan) {
        // loop on the orphan edges...
        FOR_I3 {
          const int ist_orphan_nbr = oroor[ist_orphan][i];
          if (ist_orphan_nbr >= nst_orphan) {
            const int igr_orphan = orphan_group[ist_orphan];
            assert((igr_orphan >= 0)&&(igr_orphan < ngr_orphan));
            const int isend = ist_orphan_nbr-nst_orphan;
            if (send_buf_int[isend] == -2) {
              // this connection is not to an active orphan, so integrate any cvost_g_i data...
              for (int cos = cvost_g_i[isend]; cos != cvost_g_i[isend+1]; ++cos) {
                orphan_group_set[igr_orphan].insert(pair<int,int>(send_buf_int2[cos*2],send_buf_int2[cos*2+1]));
              }
            }
            else {
              assert(cvost_g_i[isend] == cvost_g_i[isend+1]);
              // a positive index in send_buf_int refers to the final index in the group_unpack_size...
              assert((send_buf_int[isend] >= 0)&&(send_buf_int[isend] < group_unpack_size));
              // record the connections between local groups and nbr groups...
              gr_nbr_set.insert(pair<int,int>(igr_orphan,send_buf_int[isend]));
            }
          }
        }
      }

      delete[] send_buf_int; send_buf_int = NULL;
      delete[] send_buf_int2; send_buf_int2 = NULL;
      delete[] cvost_g_i;

      // ========================================================================
      // now build group exchanges and iterate until we have all the 
      // cvs possible...
      // ========================================================================
      
      assert(rankGroupMap.size() == group_unpack_size);
      int * group_unpack_rank = new int[group_unpack_size];
      int * group_unpack_buf = new int[group_unpack_size+1];
      // we need rank-order here and that should be ensured because the map was built inside a rank loop...
      // this way, we do not have to worry about the gr_nbr_set index connections: they are correct. If this
      // becomes important (because of bits for example) then we need to use the map order and
      // adjust the second index in gr_nbr_set accordingly...
      for (map<const pair<int,int>,int>::iterator it = rankGroupMap.begin(); it != rankGroupMap.end(); ++it) {
        const int igg = it->second;
        group_unpack_rank[igg] = it->first.first;
        group_unpack_buf[igg] = it->first.second; // the group on the nbr
      }
      rankGroupMap.clear();
      
      // now build a paired communicator. The pairing should be symmetric 
      // in terms of rank, but perhaps not count. Some day this will require periodicity...
      
      vector<CvPrcomm> grPrcommVec;
      int rank_current = -1;
      int bits_current = -1;
      CvPrcomm * prcomm = NULL;
      for (int igg = 0; igg < group_unpack_size; ++igg) {
        int rank = group_unpack_rank[igg];
        int bits = 0;
        if (rank > rank_current) {
          // we just switched ranks. If there was a prcomm, then
          // complete the size...
          if (prcomm)
            prcomm->unpack_size = igg-prcomm->unpack_offset;
          rank_current = rank;
          bits_current = -1;
          grPrcommVec.push_back(CvPrcomm());
          prcomm = &grPrcommVec.back();
          prcomm->rank = rank;
          prcomm->unpack_offset = igg;
        }
        else {
          assert(rank_current == rank);
          assert(prcomm);
        }
        // just tests monotoncity of the bits...
        if (bits > bits_current) {
          bits_current = bits;
        }
        else {
          assert(bits_current == bits);
        }
      }
      // we just finished. If there was a prcomm, then
      // complete the size...
      if (prcomm) prcomm->unpack_size = group_unpack_size-prcomm->unpack_offset;
      
      // finally, we need to send/recv the indices and bits to the pack side
      // and build the packVecs. Note that these should be symmetric by construction
      // because internal faces always have 2 cvs, but counts may not be the
      // same because more than one face can be on a single cv...

      MPI_Request * sendRequestArray = new MPI_Request[grPrcommVec.size()];
      MPI_Request * recvRequestArray = new MPI_Request[grPrcommVec.size()];
      for (int ii = 0, ii_end=grPrcommVec.size(); ii < ii_end; ++ii) {
        
        // post irecv...
        MPI_Irecv(&(grPrcommVec[ii].pack_size),1,MPI_INT,grPrcommVec[ii].rank,12345,mpi_comm,recvRequestArray+ii);
        
        // and the send...
        MPI_Issend(&(grPrcommVec[ii].unpack_size),1,MPI_INT,grPrcommVec[ii].rank,12345,mpi_comm,sendRequestArray+ii);

      }
      
      MPI_Waitall(grPrcommVec.size(),sendRequestArray,MPI_STATUSES_IGNORE);
      MPI_Waitall(grPrcommVec.size(),recvRequestArray,MPI_STATUSES_IGNORE);
      
      // now send from the unpack side to the pack side...
      
      int pack_size = 0;
      for (int ii = 0, ii_end=grPrcommVec.size(); ii < ii_end; ++ii)
        pack_size += grPrcommVec[ii].pack_size;
   
      int * group_pack_buf = new int[pack_size];
      
      pack_size = 0;
      for (int ii = 0, ii_end=grPrcommVec.size(); ii < ii_end; ++ii) {
        
        // post irecv...
        MPI_Irecv(group_pack_buf+pack_size,grPrcommVec[ii].pack_size,MPI_INT,
                  grPrcommVec[ii].rank,12346,mpi_comm,recvRequestArray+ii);
        pack_size += grPrcommVec[ii].pack_size;
        
        // and the send...
        MPI_Issend(group_unpack_buf+grPrcommVec[ii].unpack_offset,grPrcommVec[ii].unpack_size,MPI_INT,
                   grPrcommVec[ii].rank,12346,mpi_comm,sendRequestArray+ii);
        
      }

      MPI_Waitall(grPrcommVec.size(),sendRequestArray,MPI_STATUSES_IGNORE);
      MPI_Waitall(grPrcommVec.size(),recvRequestArray,MPI_STATUSES_IGNORE);
      
      // now build the packVec and periodicity...

      pack_size = 0;
      for (int ii = 0, ii_end=grPrcommVec.size(); ii < ii_end; ++ii) {
        assert(grPrcommVec[ii].packVec.empty());
        grPrcommVec[ii].packVec.resize(grPrcommVec[ii].pack_size);
        //CvPrcomm::Transform * transform = NULL;
        int bits_current = -1;
        for (int i = 0; i < grPrcommVec[ii].pack_size; ++i) {
          int index = group_pack_buf[pack_size+i];
          int bits = 0;
          if (bits > bits_current) {
            // bits are about to change, so complete any translate and rotate...
            //if (transform) transform->end = i;
            // look for new rotations/translations...
            //const bool has_R = PeriodicData::getPeriodicR(R,bits);
            //const bool has_t = PeriodicData::getPeriodicT(t,bits);
            //grPrcommVec[ii].transformVec.push_back(CvPrcomm::Transform(has_R,R,has_t,t,i));
            //transform = &(grPrcommVec[ii].transformVec.back());
            bits_current = bits;
          }
          else {
            assert(bits_current == bits);
          }
          assert((index >= 0)&&(index < ngr_orphan));
          grPrcommVec[ii].packVec[i] = index;
        }
        //if (transform) transform->end = grPrcommVec[ii].pack_size;
        pack_size += grPrcommVec[ii].pack_size;
      }
      
      // =====================================================================
      // now iterate until there are no more changes...
      // =====================================================================

      set<pair<int,int> > * orphan_group_set_final = new set<pair<int,int> >[ngr_orphan];
      
      int iter = 0;
      int done = 0;
      while (done == 0) {

        ++iter;

        // 1. send the counts of new cvost data...
        
        pack_size = 0;
        for (int ii = 0; ii < grPrcommVec.size(); ++ii) {
          
          // post irecv -- directly into group_unpack_buf...
          
          MPI_Irecv(group_unpack_buf+grPrcommVec[ii].unpack_offset,grPrcommVec[ii].unpack_size,
                    MPI_INT,grPrcommVec[ii].rank,12347,mpi_comm,recvRequestArray+ii);
          
          // pack and send the counts from orphan_group_set[igr]...
          
          for (int i = 0; i < grPrcommVec[ii].packVec.size(); ++i) {
            const int igr = grPrcommVec[ii].packVec[i];
            assert((igr >= 0)&&(igr < ngr_orphan));
            group_pack_buf[pack_size+i] = orphan_group_set[igr].size();
          }
          
          MPI_Issend(group_pack_buf+pack_size,grPrcommVec[ii].packVec.size(),
                     MPI_INT,grPrcommVec[ii].rank,12347,mpi_comm,sendRequestArray+ii);
          
          pack_size += grPrcommVec[ii].packVec.size();
          
        }
        
        // 2. let the uniform messages complete...
        
        MPI_Waitall(grPrcommVec.size(),sendRequestArray,MPI_STATUSES_IGNORE);
        MPI_Waitall(grPrcommVec.size(),recvRequestArray,MPI_STATUSES_IGNORE);
        
        // 3. 
        
        done = 1;

      }
      
      



        
      delete[] group_pack_buf;
      delete[] sendRequestArray;
      delete[] recvRequestArray;
      

      
      
      
      
      
      MPI_Pause("XXXXXXXXXXXXXXXX so far so very gooooooooooooood -- check it ouuuuuuuuuuuuut!");


#endif

      
    }


    
    MPI_Pause("================= MADE IT ======================= L3436");

    

    
    
  






// this was a great check before orphan grouping...

      
      // at this point, all sets should be in their starting mode, and we ned only consider
      // the connections between orphan nst's. As a check, write out a file than contains
      // ist, orphan_set.size() 
      // for all orphans...
      
      {
        string filename = "orphan_check.dat";
        FILE * fp;
        if ( mpi_rank == 0 ) {
          fp = fopen(filename.c_str(),"w");
          assert(fp != NULL);
        }
        else {
          int dummy;
          MPI_Status status;
          MPI_Recv(&dummy,1,MPI_INT,mpi_rank-1,1234,mpi_comm,&status);
          fp = fopen(filename.c_str(),"a");
          assert(fp != NULL);
        }
        
        for (int ist_flattened = stora[mpi_rank]; ist_flattened != stora[mpi_rank+1]; ++ist_flattened) {
          const int ist = ist_flattened-stora[mpi_rank];
          if (st_flag[ist] >= 0) {
            // this is an orphan st...
            const int ist_orphan = st_flag[ist];
            fprintf(fp,"%d %d\n",ist_flattened,orphan_set[ist_orphan].size());
          }
        }
        
        fclose(fp);

        if ( mpi_rank < mpi_size-1 ) {
          int dummy = 1;
          MPI_Send(&dummy,1,MPI_INT,mpi_rank+1,1234,mpi_comm);
        }

        MPI_Barrier(mpi_comm);
        
      }
      
      
// end 
// end 
// end 






    


    const double fa_area_tol = 1.0E-12;
    const double bf_area_tol = 1.0E-12;

    map<const int,FaceGeometryData> internalFaceGeometryMap; // map of face geometry with nbr key
    map<const int,BfGeometryData> boundaryFaceGeometryMap; // map of face geometry with ist key
  
    vd.vol = 0.0;
    FOR_I3 vd.x_cv[i] = 0.0;

    vector<VdTri> faVdTriVec;
    vector<VdTri> bfVdTriVec;
    set<int> zoneSet;



    // loop through (main) all edges for now
    for (int ied = 0; ied < cvd.ned; ++ied) {
      // each edge has 2 faces...
      FOR_I2 {
        const int ifa = cvd.faoed[ied][i];
        // recall i = 0,1, so edge goes form node 0->1 or 1->0, depending on the face
	double * x0 = cvd.x_no[cvd.nooed[ied][i]];
	double * x1 = cvd.x_no[cvd.nooed[ied][1-i]];
	// a negative ifa indicates an internal nbr (positive is a boundary)...
	if (ifa < 0) {
	  assert(ifa <= -8);
	  // at this point, the -8 indexed fa stores the index in nbrVec. This allows us
	  // to use the d2 in nbrVec to eliminate small face areas below... 
	  const int inbr = -ifa-8; assert((inbr >= 0)&&(inbr < nbrVec.size()));
	  map<const int,FaceGeometryData>::iterator iter = internalFaceGeometryMap.find(inbr);
	  if (iter == internalFaceGeometryMap.end()) {
            // used to use the following format for map insertion,
	    //internalFaceGeometryMap[inbr] = FaceGeometryData(x0); 
            // but now use the map.insert form to recover a copy of the iterator...
            pair<map<const int,FaceGeometryData>::iterator,bool> ret = internalFaceGeometryMap.insert(pair<const int,FaceGeometryData>(inbr,FaceGeometryData(x0)));
            assert(ret.second);
            iter = ret.first;
	  }
	  else if ((x0 != iter->second.x0)&&(x1 != iter->second.x0)) {
	    assert(iter->second.x0 != NULL);
	    const double this_n[3] = TRI_NORMAL_2(iter->second.x0,x0,x1);
	    const double this_vol = DOT_PRODUCT(iter->second.x0,this_n);
	    vd.vol += this_vol;
            iter->second.area += this_vol;
            FOR_J3 {
	      const double tmp = this_vol*(iter->second.x0[j]+x0[j]+x1[j]);
	      iter->second.xc[j] += tmp;
	      vd.x_cv[j] += tmp;
	      iter->second.normal[j] += this_n[j];
	    }
            faVdTriVec.push_back(VdTri(iter->second.x0,x0,x1));
	  }
	  else {
	    // face loop should be 1-directional...
	    // NOTE: this gets hit occasionally - is this a problem?
	    //assert(iter->second.x0 == x1);
	  }
          // also record the maximum node distance for each internal face. This info
          // is required to ensure the cv-based delta's are enough to properly and 
          // consistently build the Voronoi diagram...
          iter->second.r2_max = max(iter->second.r2_max,max(DOT_PRODUCT(x0,x0),DOT_PRODUCT(x1,x1)));
	}
	else {
	  // a positive ifa is a boundary face. It's value is actually an entry into ist_and_ipart_bits
          map<const int,BfGeometryData>::iterator iter = boundaryFaceGeometryMap.find(ifa);
	  if (iter == boundaryFaceGeometryMap.end()) {
            // the first time we deal with any ist, look up its zone index from the 
            // part surfaces...
            const int ist = ist_and_ipart_bits[ifa];
            const int ipart = (ist_and_ipart_bits[ifa+1]>>6); // recall first entry is ist_global, second is ipart/bits
            assert(ipart < partVec.size());
            boundaryFaceGeometryMap[ifa] = BfGeometryData(x0,ipart,ist); // use index1 for ipart, index2 for ist in that part: TODO: use bits here eventually when periodic
            // also add this zone to the zoneSet for "coloring"/condensing the cut surface tris to bf's below...
            const int isn = partVec[ipart]->surface->znost[ist];
            const int izone = partVec[ipart]->znosz[isn];
            assert((izone >= 0)&&(izone < zoneVec.size()));
            zoneSet.insert(izone);
	  }
	  else if ((x0 != iter->second.x0)&&(x1 != iter->second.x0)) {
	    assert(iter->second.x0 != NULL);
	    const double this_n[3] = TRI_NORMAL_2(iter->second.x0,x0,x1);
	    const double this_vol = DOT_PRODUCT(iter->second.x0,this_n);
	    vd.vol += this_vol;
	    const double this_area = MAG(this_n); // because these cut unique surface tris can only be cut by voronoi faces, they are convex
	    iter->second.area += this_area;
	    FOR_J3 {
	      iter->second.xc[j]     += this_area*(iter->second.x0[j]+x0[j]+x1[j]);
	      vd.x_cv[j]            += this_vol*(iter->second.x0[j]+x0[j]+x1[j]);
	      iter->second.normal[j] += this_n[j];
	    }
            bfVdTriVec.push_back(VdTri(iter->second.x0,x0,x1));
          }
	  /*
            else {
	    // face loop should be 1-directional...
	    if (!(iter->second.x0 == x1)) {
            cout << "ERROR at x_vd: " << COUT_VEC(x_vd) << endl;
            cvd.writeTecplot(12345);
            cvd.writeBinary("debug_cvd.bin");
            }
	    assert(iter->second.x0 == x1);
            }
	  */
	}
      }
    }
    
    FOR_I3 vd.x_cv[i] /= 4.0*vd.vol;
    vd.vol /= 6.0;
    
    const int nfa_max = internalFaceGeometryMap.size(); // may be too large because some get eliminated...
    vd.cv_nbr = new int[nfa_max];
    vd.r2_fa = new double[nfa_max];
    vd.n_fa = new double[nfa_max][3];
    vd.x_fa = new double[nfa_max][3];
   
    vd.nfa = 0;
    for (map<const int,FaceGeometryData>::iterator iter = internalFaceGeometryMap.begin(); iter !=  internalFaceGeometryMap.end(); ++iter) {
      const int inbr = iter->first;
      iter->second.complete();
      const double area = MAG(iter->second.normal);
      // the face area has to be atleast this fraction of the voronoi nbr distance squared
      // associated with the face. Note that this is the same on both sides, making it very unlikely that
      // a given face will only be eliminated on one side...
      if (area > nbrVec[inbr].first*fa_area_tol) {
	// replace inbr from the cvd face with the irecv_int reference from the nbrVec. 
	// This gets replaced again outside this routine where we have access to the buffer it indexes...
	vd.cv_nbr[vd.nfa] = nbrVec[inbr].second.first;
        vd.r2_fa[vd.nfa]          = iter->second.r2_max;
	FOR_I3 vd.n_fa[vd.nfa][i] = iter->second.normal[i];
	FOR_I3 vd.x_fa[vd.nfa][i] = iter->second.xc[i];
	++vd.nfa;
      }
    }

    map<const int,int> zoneMap;
    int nbf_max = 0;
    for (set<int>::iterator siter = zoneSet.begin(); siter != zoneSet.end(); ++siter)
      zoneMap[*siter] = nbf_max++;

    // HACK: do not group bf's...
    //nbf_max = boundaryFaceGeometryMap.size();

    vd.znobf = new int[nbf_max];
    vd.n_bf = new double[nbf_max][3];
    vd.x_bf = new double[nbf_max][3];
    vd.area_bf = new double[nbf_max];
    vd.delta_bf = new double[nbf_max];
    vd.greg_diag_bf = new double[nbf_max][3];
    vd.greg_offd_bf = new double[nbf_max][3];
    
    for (int ibf = 0; ibf < nbf_max; ++ibf) {
      vd.znobf[ibf] = -1;
      FOR_I3 vd.n_bf[ibf][i] = 0.0;
      FOR_I3 vd.x_bf[ibf][i] = 0.0;
      vd.area_bf[ibf] = 0.0;
      vd.delta_bf[ibf] = 0.0;
      FOR_I3 vd.greg_diag_bf[ibf][i] = 0.0;
      FOR_I3 vd.greg_offd_bf[ibf][i] = 0.0;
    }
    
    // we also need spobfMap for each potential bf...
    
    map<const int,double> * spobfMap = new map<const int,double>[nbf_max];
    
    //int nbf_hack = 0;

    // complete everything first: we use an n2 algo below for greg, so we need all bf chunks completed...

    for (map<const int,BfGeometryData>::iterator iter = boundaryFaceGeometryMap.begin(); iter !=  boundaryFaceGeometryMap.end(); ++iter)
      iter->second.complete();
    
    // now loop through and set data...

    for (map<const int,BfGeometryData>::iterator iter = boundaryFaceGeometryMap.begin(); iter !=  boundaryFaceGeometryMap.end(); ++iter) {
      // recall that the iter->second now contains the normal[3] and xc[3]
      const double area = MAG(iter->second.normal);
      if (area > bf_area_tol*pow(vd.vol,2.0/3.0)) {
        // -------------------------------------------------------------
        // compute delta_avg for this cut surface tri using the volume 
        // integration of abs signed distance...
        // -------------------------------------------------------------
        double delta_avg = 0.0;
        const double unit_n_bf[3] = { iter->second.normal[0]/area, 
                                      iter->second.normal[1]/area, 
                                      iter->second.normal[2]/area };
        const double zero[3] = { 0.0, 0.0, 0.0 }; // center of the vd is at zero (i.e. x_vd reference frame)
        for (int ii = 0, limit = faVdTriVec.size(); ii < limit; ++ii) {
          // compute the signed distance at the corners...
          const double phi0 = -(iter->second.x0[0]*unit_n_bf[0]+iter->second.x0[1]*unit_n_bf[1]+iter->second.x0[2]*unit_n_bf[2]);
          const double phi1 = ((faVdTriVec[ii].x[0][0]-iter->second.x0[0])*unit_n_bf[0]+
                               (faVdTriVec[ii].x[0][1]-iter->second.x0[1])*unit_n_bf[1]+
                               (faVdTriVec[ii].x[0][2]-iter->second.x0[2])*unit_n_bf[2]);
          const double phi2 = ((faVdTriVec[ii].x[1][0]-iter->second.x0[0])*unit_n_bf[0]+
                               (faVdTriVec[ii].x[1][1]-iter->second.x0[1])*unit_n_bf[1]+
                               (faVdTriVec[ii].x[1][2]-iter->second.x0[2])*unit_n_bf[2]);
          const double phi3 = ((faVdTriVec[ii].x[2][0]-iter->second.x0[0])*unit_n_bf[0]+
                               (faVdTriVec[ii].x[2][1]-iter->second.x0[1])*unit_n_bf[1]+
                               (faVdTriVec[ii].x[2][2]-iter->second.x0[2])*unit_n_bf[2]);
          // note first point is zero...
          delta_avg += tetIntegrateAbsSignedDist(phi0,phi1,phi2,phi3,zero,faVdTriVec[ii].x[0],faVdTriVec[ii].x[1],faVdTriVec[ii].x[2]);
        }
        for (int ii = 0, limit = bfVdTriVec.size(); ii < limit; ++ii) {
          // compute the signed distance at the corners...
          const double phi0 = -(iter->second.x0[0]*unit_n_bf[0]+iter->second.x0[1]*unit_n_bf[1]+iter->second.x0[2]*unit_n_bf[2]);
          const double phi1 = ((bfVdTriVec[ii].x[0][0]-iter->second.x0[0])*unit_n_bf[0]+
                               (bfVdTriVec[ii].x[0][1]-iter->second.x0[1])*unit_n_bf[1]+
                               (bfVdTriVec[ii].x[0][2]-iter->second.x0[2])*unit_n_bf[2]);
          const double phi2 = ((bfVdTriVec[ii].x[1][0]-iter->second.x0[0])*unit_n_bf[0]+
                               (bfVdTriVec[ii].x[1][1]-iter->second.x0[1])*unit_n_bf[1]+
                               (bfVdTriVec[ii].x[1][2]-iter->second.x0[2])*unit_n_bf[2]);
          const double phi3 = ((bfVdTriVec[ii].x[2][0]-iter->second.x0[0])*unit_n_bf[0]+
                               (bfVdTriVec[ii].x[2][1]-iter->second.x0[1])*unit_n_bf[1]+
                               (bfVdTriVec[ii].x[2][2]-iter->second.x0[2])*unit_n_bf[2]);
          // note first point is zero...
          delta_avg += tetIntegrateAbsSignedDist(phi0,phi1,phi2,phi3,zero,bfVdTriVec[ii].x[0],bfVdTriVec[ii].x[1],bfVdTriVec[ii].x[2]);
        }
        delta_avg /= (vd.vol*24.0);
        // -------------------------------------------------------------
        // figure out what bf we belong to based on the izone...
        // -------------------------------------------------------------
        const int isn = partVec[iter->second.index1]->surface->znost[iter->second.index2];
        const int izone = partVec[iter->second.index1]->znosz[isn];
        map<const int,int>::iterator ziter = zoneMap.find(izone);
        assert(ziter != zoneMap.end());
        const int ibf = ziter->second;
        assert((ibf >= 0)&&(ibf < nbf_max));
        // -------------------------------------------------------------
        // add the gradient regularization stuff...
        // -------------------------------------------------------------
        double sum1 = 0.0;
        for (int ifa = 0; ifa < vd.nfa; ++ifa) {
          //const double s_cv[3] = DIFF(x_cv[cvofa[ifa][0]],x_cv[cvofa[ifa][1]]);
          //const double mag_s = MAG(s_cv);
          //sum1 += fabs(DOT_PRODUCT(unit_n_bf,s_cv))/mag_s*MAG(n_fa[ifa]);
          sum1 += fabs(DOT_PRODUCT(unit_n_bf,vd.n_fa[ifa]));
        }
        double sum2 = 0.0;
        for (map<const int,BfGeometryData>::iterator iter2 = boundaryFaceGeometryMap.begin(); iter2 !=  boundaryFaceGeometryMap.end(); ++iter2) {
          sum2 += fabs(DOT_PRODUCT(unit_n_bf,iter2->second.normal));
        }
        // "factor" is the ratio of faces with information to all faces in this 
        // direction. the most it can be is 1, e.g. on an internal face with no
        // boundary faces. For a cell that has only boundary faces in a particular 
        // direction, it will be zero. here we use a quadratic weighting for 
        // factor less than 0.5 that is zero at factor = 0.5, and 1.0 at factor = 0
        const double factor = sum1/(sum1+sum2);
        if (factor < 0.5) {
          const double wgt = (factor-0.5)*(factor-0.5)*4.0;
          // diag...
          vd.greg_diag_bf[ibf][0] += wgt*unit_n_bf[0]*iter->second.normal[0];
          vd.greg_diag_bf[ibf][1] += wgt*unit_n_bf[1]*iter->second.normal[1];
          vd.greg_diag_bf[ibf][2] += wgt*unit_n_bf[2]*iter->second.normal[2];
          // offd...
          vd.greg_offd_bf[ibf][0] += wgt*unit_n_bf[1]*iter->second.normal[2];
          vd.greg_offd_bf[ibf][1] += wgt*unit_n_bf[0]*iter->second.normal[2];
          vd.greg_offd_bf[ibf][2] += wgt*unit_n_bf[0]*iter->second.normal[1];
        }
        // -------------------------------------------------------------
        // figure out the weights associated with the 3 nodes of this uncut surface tri...
        // -------------------------------------------------------------
        const int ipart = iter->second.index1;
        const int ist = iter->second.index2;
        const int isp0 = partVec[ipart]->surface->spost[ist][0];
        const int isp1 = partVec[ipart]->surface->spost[ist][1];
        const int isp2 = partVec[ipart]->surface->spost[ist][2];
        // build the barycentric weights from cross product magnitudes...
        double dx0[3]; FOR_I3 dx0[i] = partVec[ipart]->surface->xsp[isp0][i]-x_vd[i] - iter->second.xc[i];
        double dx1[3]; FOR_I3 dx1[i] = partVec[ipart]->surface->xsp[isp1][i]-x_vd[i] - iter->second.xc[i];
        double dx2[3]; FOR_I3 dx2[i] = partVec[ipart]->surface->xsp[isp2][i]-x_vd[i] - iter->second.xc[i];
        const double w0 = CROSS_DOT(dx1,dx2,iter->second.normal);
        const double w1 = CROSS_DOT(dx2,dx0,iter->second.normal);
        const double w2 = CROSS_DOT(dx0,dx1,iter->second.normal);
        const double wsum = w0 + w1 + w2;
        // add weight*area to each isp...
        // isp0...
        map<const int,double>::iterator witer = spobfMap[ibf].find(isp0);
        if (witer == spobfMap[ibf].end()) 
          spobfMap[ibf][isp0] = area*w0/wsum;
        else 
          witer->second += area*w0/wsum;
        // isp0...
        witer = spobfMap[ibf].find(isp1);
        if (witer == spobfMap[ibf].end()) 
          spobfMap[ibf][isp1] = area*w1/wsum;
        else 
          witer->second += area*w1/wsum;
        // isp2...
        witer = spobfMap[ibf].find(isp2);
        if (witer == spobfMap[ibf].end()) 
          spobfMap[ibf][isp2] = area*w2/wsum;
        else 
          witer->second += area*w2/wsum;
        // -------------------------------------------------------------
        // add our contributions to the bf...
        // -------------------------------------------------------------
        if (vd.znobf[ibf] == -1)
          vd.znobf[ibf] = izone;
        assert(vd.znobf[ibf] == izone);
        FOR_I3 vd.n_bf[ibf][i] += iter->second.normal[i];
        FOR_I3 vd.x_bf[ibf][i] += area*iter->second.xc[i];
        vd.area_bf[ibf] += area;
        vd.delta_bf[ibf] += area/delta_avg; // store sum(area/delta) for now
      }
    }
    //assert(nbf_hack <= nbf_max);

    int spobf_s = 0;
    for (int ibf = 0; ibf < nbf_max; ++ibf)
      spobf_s += spobfMap[ibf].size();
    
    vd.spobf_i = new int[nbf_max+1];
    vd.spobf_v = new int[spobf_s];
    vd.spobf_wgt = new double[spobf_s];
    
    int sob = 0;
    vd.spobf_i[0] = 0;
    vd.nbf = 0;
    for (int ibf = 0; ibf < nbf_max; ++ibf) {
      if (vd.znobf[ibf] >= 0) {
        vd.znobf[vd.nbf] = vd.znobf[ibf];
        FOR_I3 vd.n_bf[vd.nbf][i] = vd.n_bf[ibf][i];
        vd.area_bf[vd.nbf] = vd.area_bf[ibf];
        assert(vd.area_bf[vd.nbf] > 0.0);
        FOR_I3 vd.x_bf[vd.nbf][i] = vd.x_bf[ibf][i]/vd.area_bf[ibf];
        vd.delta_bf[vd.nbf] = vd.area_bf[ibf]/vd.delta_bf[ibf];
        FOR_I3 vd.greg_diag_bf[vd.nbf][i] = vd.greg_diag_bf[ibf][i];
        FOR_I3 vd.greg_offd_bf[vd.nbf][i] = vd.greg_offd_bf[ibf][i];
        // add the spobf stuff...
        for (map<const int,double>::iterator witer = spobfMap[ibf].begin(); witer != spobfMap[ibf].end(); ++witer) {
          vd.spobf_v[sob] = witer->first;
          vd.spobf_wgt[sob] = witer->second/vd.area_bf[ibf];
          ++sob;
        }
        vd.spobf_i[vd.nbf+1] = sob;
        ++vd.nbf;
      }
    }
    assert(sob == spobf_s);
    delete[] spobfMap;
    
    // check if spobf csr can reconstruct the x_bf's...
    {
      for (int ibf = 0; ibf < vd.nbf; ++ibf) {
        const int izone = vd.znobf[ibf];
        const int ipart = paozn[izone];
        double x_bf_check[3] = { 0.0, 0.0, 0.0 };
        for (int sob = vd.spobf_i[ibf]; sob != vd.spobf_i[ibf+1]; ++sob) {
          const int isp = vd.spobf_v[sob];
          const double wgt = vd.spobf_wgt[sob];
          FOR_I3 x_bf_check[i] += wgt*partVec[ipart]->surface->xsp[isp][i];
        }
        FOR_I3 x_bf_check[i] -= x_vd[i] + vd.x_bf[ibf][i];
        if (DOT_PRODUCT(x_bf_check,x_bf_check) > 1.0E-12*pow(vd.vol,2.0/3.0)) {
          cout << "Warning: got large x_bf_check: " << COUT_VEC(x_bf_check) << " DOT_PRODUCT(x_bf_check,x_bf_check)/pow(vd.vol,2.0/3.0): " << DOT_PRODUCT(x_bf_check,x_bf_check)/pow(vd.vol,2.0/3.0) << endl;
        }
      }
    }



        
        
        







        
        int igr_closest = -1;
        double d2_closest;
        for (int ied = 0; ied < cvd.ned; ++ied) {
          // each edge has 2 faces...
          FOR_I2 {
            const int ifa = cvd.faoed[ied][i];
            if (ifa >= 0) {
              const int ist = ist_and_ipart_bits[ifa];
              const int ipart = (ist_and_ipart_bits[ifa+1]>>6); // recall first entry is ist_global, second is ipart/bits
              const int bits = (ist_and_ipart_bits[ifa+1]&MASK_6BITS);
              assert(bits == 0);
              SurfaceShm * surface = partVec[ipart]->surface;
              assert(surface);
              const double d2 = MiscUtils::getPointToTriDist2(x_vd,
                                                              surface->xsp[surface->spost[ist][0]],
                                                              surface->xsp[surface->spost[ist][1]],
                                                              surface->xsp[surface->spost[ist][2]]);
              if ((igr_closest == -1)||(d2 < d2_closest)) {
                igr_closest = -no_flag[cvd.nooed[ied][0]]-1; // -1-indexed group in no_flag


                d2_closest = d2;
              }
            }
          }
        }

        assert(igr_closest >= 0);

        // re-index the groups...
        
        

        // HEREHERE
        // HEREHERE
        // HEREHERE
        // HEREHERE













// vd/ocd debugging output...

            //cout << " > x0: " << COUT_VEC(x0) << " x1: " << COUT_VEC(x1) << endl; 
            if (!(bfMultimap.find(pair<int,double*>(iter0->second,x0)) == bfMultimap.end())) {
	      cout << "Error: about to fail near xp: " << COUT_VEC(points->xp[ip]) << endl;
	      char filename[128];
	      sprintf(filename,"vd.%04d.bin",mpi_rank);
              vdArray[ip].writeBinary(filename);
              int next_ = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
              int oi = 0;
              while (next_ != -1) {
                sprintf(filename,"ocd.%04d.%02d.bin",mpi_rank,oi++);
                ocdVec[next_].writeBinary(filename);
                next_ = ocdVec[next_].next;
              }
              writeFullCvTecplot(ip,points->xp[ip]);
	    }




        
        const double xp = (xt[it_next][0]-xt[it_prev][0]);
        const double yp = (xt[it_next][1]-xt[it_prev][1]);
        const double xpp = (xt[it_next][0]-2.0*xt[it][0]+xt[it_prev][0]);
        const double ypp = (xt[it_next][1]-2.0*xt[it][1]+xt[it_prev][1]);
        const double denom = pow(xp*xp+yp*yp,3.0/2.0);
        if (denom != 0.0) {
          const double kappa = fabs((xp*ypp-yp*xpp)/denom);
          dx_local[it] = max(dn,min(dt,sqrt(0.001*dn/kappa)));
        }
        else {
          dx_local[it] = dt;
        }



        

          const int it_prev = it-1;
          const double t_prev = t_local[it_prev];
          const int it_next = (it+1)%nt;

          
        
        
        bool done = true;
        for (int it = 0; it < nt; ++it) {
          const int it_next = (it+1)%nt;
          const double dx0[3] = DIFF(xt0[it_next],xt0[it]);
          const double dx1[3] = DIFF(xt1[it_next],xt1[it]);
          const double ratio = DOT_PRODUCT(dx1,dx0)/DOT_PRODUCT(dx0,dx0);
          if (ratio > 1.2) {
            done = false;
            flag[it] = 1;
            flag[it_next] = 1;
          }
        }

        if (done) {
          cout << "blah!" << endl;
          getchar();
        }
        
        // some flags were set -- reduce the level in these flags and redistribute the points...
        // also enforce that the level difference between adjacent points is 0,1,-1...
        
        for (int it = 0; it < nt; ++it) {
          if ((flag[it] == 1)&&(nn_local[it] > 0)) {
            --nn_local[it];
          }
        }
        
        done = false;
        while (!done) {
          done = true;
          for (int it = 0; it < nt; ++it) {
            const int it_next = (it+1)%nt;
            if (nn_local[it] > nn_local[it_next]+1) {
              nn_local[it] = nn_local[it_next]+1;
              done = false;
            }
            else if (nn_local[it_next] > nn_local[it]+1) {
              nn_local[it_next] = nn_local[it]+1;
              done = false;
            }
          }
        }

        // finally redistribute the t_local acounting for the stretching ratio...
        
        // iterative for now...
        int iter = 0;
        done = false;
        while (!done) {
          double dt_max = 0.0;
          ++iter;
          for (int it = 1; it < nt; ++it) {
            const int it_prev = it-1;
            const double t_prev = t_local[it_prev];
            const int it_next = (it+1)%nt;
            double t_next = t_local[it_next];
            if (it_next == 0) {
              assert(t_next == 0.0);
              t_next += 1.0;
            }
            // figure out the coeff...
            const int dn_prev = nn_local[it_prev]-nn_local[it];
            double coeff_prev;
            switch (dn_prev) {
            case -1:
              coeff_prev = sqrt(sf);
              break;
            case 0:
              coeff_prev = 1.0;
              break;
            case 1:
              coeff_prev = 1.0/sqrt(sf);
              break;
            default:
              assert(0);
            }
            const int dn_next = nn_local[it_next]-nn_local[it];
            double coeff_next;
            switch (dn_next) {
            case -1:
              coeff_next = sqrt(sf);
              break;
            case 0:
              coeff_next = 1.0;
              break;
            case 1:
              coeff_next = 1.0/sqrt(sf);
              break;
            default:
              assert(0);
            }
            const double t_new = (coeff_prev*t_prev + coeff_next*t_next)/(coeff_prev+coeff_next);
            const double dt = t_new - t_local[it];
            dt_max = max(dt_max,dt);
            t_local[it] = t_new;
          }
          if (dt_max < 1.0E-8)
            done = true;
        }
        
        cout << "converged in iter: " << iter << endl;
        getchar();
      
      }






void VoronoiBuilder::doit() {

  setPoints();

  if (Param * param = getParam("CVD_DEBUG")) {
    CuttableVoronoiData cvd;
    cvd.readBinary(param->getString());
    cvd.writeTecplot(0);
    cvd.check();

    CvdReturnData crd;
    crd.setFromCvd(cvd);

    cout << "CVD_DEBUG: LOOKS GOOD" << endl;
    getchar();
    assert(0);
  }

  if (Param * param = getParam("VD_DEBUG")) {
    COUT1("got VD_DEBUG " << param->getString());
    VoronoiData vd;
    vd.readBinary(param->getString());
    vd.debug();
    cout << "VD_DEBUG: LOOKS GOOD" << endl;
    getchar();
    assert(0);
  }

  /*
    if (Param * param = getParam("WRITE_SURF_TECPLOT")) {
    string name = "surf.dat";
    int iarg = 0;
    while (iarg < param->size()) {
    const string token = param->getString(iarg++);
    if (token == "NAME") {
    name = param->getString(iarg++);
    }
    else {
    if (mpi_rank == 0) cout << "Warning: skipping unrecognized WRITE_SURF_TECPLOT token: " << token << endl;
    }
    }
    surface->writeTecplot(name);
    }
  */

  /*
    if (Param * param = getParam("WRITE_CHECK")) {
    surface->writeBinary("check.sbin");
    points->writeBinary("check0.pbin"); // before any Lloyd iteration
    int iarg = 0;
    while (iarg < param->size()) {
    const string token = param->getString(iarg++);
    if (token == "TECPLOT") {
    surface->writeTecplot("check_surf.dat");
    points->writeTecplot("check0_pts.dat"); // before any Lloyd iteration
    }
    else {
    assert(0);
    }
    }
    }
  */

  if (cti_serial_io&&(mpi_rank == 0))
    cout << "Warning: shuffling data to rank0 for serial io!" << endl;

  assert(vdArray == NULL);
  smoothing_step = 0;

  // tell the central log a solver is running...
  if (mpi_rank==0) logger->insertSolverAction(SIMULATION_RUN);

  KillfileReader kfr;
  //if (checkParam("INTERACTIVE"))
  //  kfr.setHold(true);

  // allow for param processing BEFORE going into the iteration loop. This could allow
  // inspection of points before voronoi build, for example...

  // look for killfile...
  int done = 0;
  while (Param * param = kfr.getParam("killstitch")) {
    if (mpi_rank == 0) cout << " > processing param \"" << param->str() << "\"" << endl;
    done = processParam(param);
    if (done != 0)
      break;
  }

  double wtime = MPI_Wtime();
  while ((done == 0)&&(smoothing_step <= nsmooth)) {
    //timer.start("init");

    if ((smoothing_step == 0)&&(mpi_rank == 0)) {
      cout <<
	"\n----------------------------------------------------------\n" <<
	" first Voronoi build..." <<
	"\n----------------------------------------------------------" << endl;
    }

    buildVoronoi();

    // take a look at specific full voronoi cvs...

    /*
      writeFullCvTecplotAt(0.0369301,-0.0505,0.00350535);
      writeFullCvTecplotAt(0.0336103,-0.0505,0.00345178);
      writeFullCvTecplotAt(0.0352702,-0.053375,0.003301);
      MPI_Pause("OK");
    */

    // imaging...

    FOR_PARAM_MATCHING("WRITE_IMAGE") {
      processWriteImage(&*param);
    }
    /*
      MPI_Barrier(mpi_comm); // TODO remove this when everything is robust
      timer.split("imaging");
    */

    // if we have reached the requested number of smoothing iterations,
    // then exit...

    while (Param * param = kfr.getParam("killstitch")) {
      if (mpi_rank == 0) cout << " > processing param \"" << param->str() << "\"" << endl;
      done = processParam(param);
      if (done != 0)
	break;
    }

    ++smoothing_step;
    if ((done == 0)&&(smoothing_step <= nsmooth)) {

      if (mpi_rank == 0) {
        cout <<
          "\n----------------------------------------------------------\n" <<
          " Smoothing step " << smoothing_step << " out of " << nsmooth << " (may go over)..." <<
          "\n----------------------------------------------------------" << endl;
      }

      // if smoothing: to limit maximum Voronoi motion during smoothing, save the
      // starting position and delta...

      if (xp0_and_delta0 == NULL) {
        xp0_and_delta0 = new double[points->np][4];
        for (int ip = 0; ip < points->np; ++ip) {
          FOR_I3 xp0_and_delta0[ip][i] = points->xp[ip][i];
          xp0_and_delta0[ip][3] = points->delta[ip];
        }
      }

      // -------------------------------------
      // Lloyd iteration...
      // -------------------------------------

      lloydIterate();

      // ------------------------------------
      // do a huge clean of everything
      // ------------------------------------

      points->clearAdt();

      // the orphan-nbr-data vec: memory is static...

      ondVec.clear();

      // for the orphan-chunk-data vec, it allocates memory and the destructor does NOT
      // do cleanup, so clean manually...

      for (int ii = 0; ii < ocdVec.size(); ++ii)
        ocdVec[ii].clear();
      ocdVec.clear();

      // now clear vdArray members...
      // also adjust delta here?...

      for (int ip = 0; ip < points->np; ++ip) {
        /*
          if (!vdArray[ip].hasBoundaryFaces()) {
          // no boundary faces. reset the delta to slightly larger than the cell r2...
          points->delta[ip] = 2.001*vdArray[ip].calcRMax();
          }
        */
        vdArray[ip].clear();
      }

      /*
        {
        MPI_Barrier(mpi_comm);
        if (mpi_rank == 0) {
        char command[256];
        sprintf(command,"tec360 -b png.mcr lloyd_debug4p.lay ; mv export.png lloyd_fine_p.%04d.png",smoothing_step);
        system(command);
        }
        MPI_Barrier(mpi_comm);
        }
      */

      //MPI_Pause("all clear");

      // store the binary points to allow restart lloyd iteration if there are problems...

      //if (checkParam("WRITE_CHECK_PTS"))
    }
    //timer.split("lloyd iteration");

    //timer.accumulate();
    if (mpi_rank == 0) {
      double wtime_prev = wtime;
      wtime = MPI_Wtime();
      cout << " > time since last check: " << wtime-wtime_prev<< endl;
    }

    if ((done != 0)||(smoothing_step > nsmooth))
      break;

  }

  //timer.report();

  if (checkParam("INTERACTIVE"))
    kfr.setHold(true);

  // allow for param processing BEFORE writing out restart file. This could allow for
  // inspection of mesh before writing...

  // look for killfile...
  done = 0;
  while (Param * param = kfr.getParam("killstitch")) {
    if (mpi_rank == 0) cout << " > processing param \"" << param->str() << "\"" << endl;
    done = processParam(param);
    if (done != 0)
      break;
  }

  DELETE(xp0_and_delta0);

  // this stuff now part of the class...
  /*
    delete[] send_count;
    delete[] send_disp;
    delete[] recv_count;
    delete[] recv_disp;
  */

  // this gets set by "stop!" in the killfile...
  if (done == -2)
    return;

  // for nsmooth > 0, write the smoothed points as "check.pbin"...

  if (checkParam("WRITE_PTS_TECPLOT")) {
    points->writeTecplot("check_pts.dat");
  }

  //if (checkParam("WRITE_SURF_TECPLOT")) {
  //  surface->writeTecplot("check_surf.dat");
  //}

  if (checkParam("WRITE_CHECK")) {
    points->writeBinary("check.pbin");
  }

  if (checkParam("WRITE_PBIN")) {
    Param * param = getParam("WRITE_PBIN");
    string filename = "points.pbin";
    int iarg = 0;
    while (iarg < param->size() && iarg < 1) {
      string token = param->getString(iarg++);
      // assume this is a filename...
      filename = token;
    }
    points->writeBinary(filename);
  }

  /*
    if (checkParam("WRITE_SBIN")) {
    Param * param = getParam("WRITE_SBIN");
    string filename = "surface.sbin";
    int iarg = 0;
    while (iarg < param->size() && iarg < 1) {
    string token = param->getString(iarg++);
    // assume this is a filename...
    filename = token;
    }
    surface->writeBinary(filename);
    }
  */

  if (vdArray) {

    // process restart writing...

    bool b_restart = false;
    if (checkParam("WRITE_RESTART_V3")) {
      writeRestart("restart_v3.les",3,false);
      b_restart = true;
    }

    if (checkParam("WRITE_RESTART_V4")) {
      writeRestart("restart.les",4,false);
      b_restart = true;
    }

    {
      // allow user to specify WRITE_RESTART or WRITE_RESTART_V5
      Param * param = getParam("WRITE_RESTART_V5");
      if (param) CWARN("WRITE_RESTART_V5 will be depricated in the next version. Use WRITE_RESTART");

      if (param == NULL) param = getParam("WRITE_RESTART");
      if (param) {
        string filename = "restart.mles";
        bool got_filename = false;
        bool write_surface = false; // TODO: how should we write this surface?
        bool skip_write = false;
        int iarg = 0;
        while (iarg < param->size()) {
          string token = param->getString(iarg++);
          if (token == "NO_SURFACE") {
            write_surface = false;
          }
          else if (token == "FALSE") {
            // do not write a restart - mostly for regression testing
            skip_write = true;
          }
          else {
            // assume this is a filename...
            if (got_filename) {
              CWARN("Filename already set. Unrecognized parameter: " << token);
            }
            else {
              filename = token;
              got_filename = true;
            }
          }
        }
        if (!skip_write) writeRestart(filename,5,write_surface);
        b_restart = true;
      }

    }

    // allow the param NO_RESTART or SKIP_RESTART or NO_MLES

    if (checkParam("NO_RESTART")||checkParam("SKIP_RESTART")||checkParam("NO_MLES"))
      return;

    // if by this point there has NOT been a restart written, write the default...

    if (!b_restart) writeRestart("restart.mles",5,false); // skip surface writing for now

  }

}



void VoronoiBuilder::processComputeNewOpsBad(Param * param,const bool b_help) {

  if (b_help) {
    WUI(INFO,"COMPUTE_NEW_OPS computes accurate operators base on finite volume integration");
    return;
  }
  
  // need to build voronoi first...
  // TODO: just NSMOOTH 0 to 
  if (!PartData::b_vp) {
    WUI(WARN,"expecting NSMOOTH <int> prior to COMPUTE_NEW_OPS");
    return;
  }

  //const double x_debug[3] = { 0.15, 0, -0.519615 }; // for regular packing
  const double x_debug[3] = { 0.15, 0, -0.525 }; // for cart packing
  const double phi0_exact = 0.456;
  const double phi_grad_exact[3] = { 1.123, 2.765, -1.987 };
  //const double phi_grad_exact[3] = { 1.123, 1.123, 1.123 };

  double (*sums0)[36] = new double[points->np][36];
  vector<uint8> nboip_v;
  int * nboip_i = new int[points->np+1];
  nboip_i[0] = 0;
  int nnbr_max = 0;
  double dx[3] = { 0.0, 0.0, 0.0 }; // HACK
  for (int ip = 0; ip < points->np; ++ip) {
    calcQuadratureLengthScale(sums0[ip],ip);
    calcQuadratureTermsAndNbrs(sums0[ip],nboip_v,ip,dx,sums0[ip][0]); // delete dx, separate r_vv eventually
    nboip_i[ip+1] = nboip_v.size();
    nnbr_max = max(nnbr_max,nboip_i[ip+1]-nboip_i[ip]);
  }
  
  cout << " > got nnbr_max: " << nnbr_max << endl;

  // the centroids are going to be helpful for checking the operators. Produce them using the
  // sums...
  
  double (*x_cv)[3] = new double[points->np][3];
  double *phi = new double[points->np];
  for (int ip = 0; ip < points->np; ++ip) {
    x_cv[ip][0] = points->xp[ip][0] + sums0[ip][SWX]/sums0[ip][SW]*sums0[ip][0];
    x_cv[ip][1] = points->xp[ip][1] + sums0[ip][SWY]/sums0[ip][SW]*sums0[ip][0];
    x_cv[ip][2] = points->xp[ip][2] + sums0[ip][SWZ]/sums0[ip][SW]*sums0[ip][0];
    phi[ip] = phi0_exact + DOT_PRODUCT(x_cv[ip],phi_grad_exact);
  }
  
  GeomUtils::writePtsTecplot("x_cv.dat",x_cv,points->np);
  cout << "take a look at x_cv.dat" << endl;
  
  // update ghost quadrature terms here...
  
  assert(mpi_size == 1);

  // then build the operators...

  double sums_check[36];
  vector<uint8> nbrs_check;
  
  double A[100];
  double L[100];
  double (*rhs)[10] = new double[nnbr_max+1][10]; // need space for ip
  double (*sums_nbr)[36] = new double[nnbr_max][36];
  int iponb[nnbr_max];
  double r[10];
  double r_check[10];
  
  for (int ip = 0; ip < points->np; ++ip) {
    
    bool debug = false;
    if (DIST(points->xp[ip],x_debug) < 1.0E-5) {
      const double dx_cv[3] = DIFF(x_cv[ip],points->xp[ip]);
      cout << "got debug: ip: " << ip << " dx_cv: " << COUT_VEC(dx_cv) << endl;
      debug = true;
    }
    
    // now populate the sums for this vd and its nbrs relative to the 
    // position of ip. Use ip's normalization as the normalization
    // for all nbrs...
    const int noi_f = nboip_i[ip];
    const int nnbr = nboip_i[ip+1] - nboip_i[ip];
    assert(nnbr <= nnbr_max);
    for (int noi = 0; noi < nnbr; ++noi) {
      int rank,bits,index;
      BitUtils::unpackRankBitsIndex(rank,bits,index,nboip_v[noi+noi_f]);
      assert(rank == 0);
      assert(bits == 0);
      assert((index >= 0)&&(index < points->np));
      assert(index != ip);
      double dx[3] = DIFF(points->xp[index],points->xp[ip]);
      transformQuadratureTerms(sums_nbr[noi],sums0[index],dx,sums0[ip][0]);
      
      // try computing the quadrature terms from first principles
      calcQuadratureTermsAndNbrs(sums_check,nbrs_check,index,dx,sums0[ip][0]); // delete dx, separate r_vv eventually
      
      for (int i = 1; i < 36; ++i) {
        //cout << "i: " << i << " DIFF: " << sums_check[i]-sums_nbr[noi][i] << endl;
        assert(fabs(sums_check[i]-sums_nbr[noi][i]) < 1.0E-15);
      }
      
      // and store ip of nbr. This is the same info as in nboip_v, but a little
      // easier to access...
      iponb[noi] = index;
      
    }
    
    // now build the LS matrix that minimizes the square of the difference with
    // the piecewise constant solution over the cell and its nbrs. The polynomial is:
    //                                          
    // P(x,y,z) = c0 + c1*x + c2*y + c3*z + c4*x*x + c5*x*y + c6*x*z + c7*y*y + c8*y*z + c9*z*z
    //
    
    // build [A]*{c0,c1,c2...c9}=[rhs]*{phi_cv,phi_nbr1,phi_nbr2...}
    // note: A is symmetric, so could store less... 
    
    A(0,0) = rhs[0][0] = sums0[ip][SW];
    A(0,1) = sums0[ip][SWX];
    A(0,2) = sums0[ip][SWY];
    A(0,3) = sums0[ip][SWZ];
    A(0,4) = sums0[ip][SWXX];
    A(0,5) = sums0[ip][SWXY];
    A(0,6) = sums0[ip][SWXZ];
    A(0,7) = sums0[ip][SWYY];
    A(0,8) = sums0[ip][SWYZ];
    A(0,9) = sums0[ip][SWZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][0] = sums_nbr[noi][SW];
      A(0,0) += sums_nbr[noi][SW];
      A(0,1) += sums_nbr[noi][SWX];
      A(0,2) += sums_nbr[noi][SWY];
      A(0,3) += sums_nbr[noi][SWZ];
      A(0,4) += sums_nbr[noi][SWXX];
      A(0,5) += sums_nbr[noi][SWXY];
      A(0,6) += sums_nbr[noi][SWXZ];
      A(0,7) += sums_nbr[noi][SWYY];
      A(0,8) += sums_nbr[noi][SWYZ];
      A(0,9) += sums_nbr[noi][SWZZ];
    }

    A(1,0) = rhs[0][1] = sums0[ip][SWX];
    A(1,1) = sums0[ip][SWXX];
    A(1,2) = sums0[ip][SWXY];
    A(1,3) = sums0[ip][SWXZ];
    A(1,4) = sums0[ip][SWXXX];
    A(1,5) = sums0[ip][SWXXY];
    A(1,6) = sums0[ip][SWXXZ];
    A(1,7) = sums0[ip][SWXYY];
    A(1,8) = sums0[ip][SWXYZ];
    A(1,9) = sums0[ip][SWXZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][1] = sums_nbr[noi][SWX];
      A(1,0) += sums_nbr[noi][SWX];
      A(1,1) += sums_nbr[noi][SWXX];
      A(1,2) += sums_nbr[noi][SWXY];
      A(1,3) += sums_nbr[noi][SWXZ];
      A(1,4) += sums_nbr[noi][SWXXX];
      A(1,5) += sums_nbr[noi][SWXXY];
      A(1,6) += sums_nbr[noi][SWXXZ];
      A(1,7) += sums_nbr[noi][SWXYY];
      A(1,8) += sums_nbr[noi][SWXYZ];
      A(1,9) += sums_nbr[noi][SWXZZ];
    }
    
    A(2,0) = rhs[0][2] = sums0[ip][SWY];
    A(2,1) = sums0[ip][SWXY];
    A(2,2) = sums0[ip][SWYY];
    A(2,3) = sums0[ip][SWYZ];
    A(2,4) = sums0[ip][SWXXY];
    A(2,5) = sums0[ip][SWXYY];
    A(2,6) = sums0[ip][SWXYZ];
    A(2,7) = sums0[ip][SWYYY];
    A(2,8) = sums0[ip][SWYYZ];
    A(2,9) = sums0[ip][SWYZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][2] = sums_nbr[noi][SWY];
      A(2,0) += sums_nbr[noi][SWY];
      A(2,1) += sums_nbr[noi][SWXY];
      A(2,2) += sums_nbr[noi][SWYY];
      A(2,3) += sums_nbr[noi][SWYZ];
      A(2,4) += sums_nbr[noi][SWXXY];
      A(2,5) += sums_nbr[noi][SWXYY];
      A(2,6) += sums_nbr[noi][SWXYZ];
      A(2,7) += sums_nbr[noi][SWYYY];
      A(2,8) += sums_nbr[noi][SWYYZ];
      A(2,9) += sums_nbr[noi][SWYZZ];
    }
    
    A(3,0) = rhs[0][3] = sums0[ip][SWZ];
    A(3,1) = sums0[ip][SWXZ];
    A(3,2) = sums0[ip][SWYZ];
    A(3,3) = sums0[ip][SWZZ];
    A(3,4) = sums0[ip][SWXXZ];
    A(3,5) = sums0[ip][SWXYZ];
    A(3,6) = sums0[ip][SWXZZ];
    A(3,7) = sums0[ip][SWYYZ];
    A(3,8) = sums0[ip][SWYZZ];
    A(3,9) = sums0[ip][SWZZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][3] = sums_nbr[noi][SWZ];
      A(3,0) += sums_nbr[noi][SWZ];
      A(3,1) += sums_nbr[noi][SWXZ];
      A(3,2) += sums_nbr[noi][SWYZ];
      A(3,3) += sums_nbr[noi][SWZZ];
      A(3,4) += sums_nbr[noi][SWXXZ];
      A(3,5) += sums_nbr[noi][SWXYZ];
      A(3,6) += sums_nbr[noi][SWXZZ];
      A(3,7) += sums_nbr[noi][SWYYZ];
      A(3,8) += sums_nbr[noi][SWYZZ];
      A(3,9) += sums_nbr[noi][SWZZZ];
    }

    A(4,0) = rhs[0][4] = sums0[ip][SWXX];
    A(4,1) = sums0[ip][SWXXX];
    A(4,2) = sums0[ip][SWXXY];
    A(4,3) = sums0[ip][SWXXZ];
    A(4,4) = sums0[ip][SWXXXX];
    A(4,5) = sums0[ip][SWXXXY];
    A(4,6) = sums0[ip][SWXXXZ];
    A(4,7) = sums0[ip][SWXXYY];
    A(4,8) = sums0[ip][SWXXYZ];
    A(4,9) = sums0[ip][SWXXZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][4] = sums_nbr[noi][SWXX];
      A(4,0) += sums_nbr[noi][SWXX];
      A(4,1) += sums_nbr[noi][SWXXX];
      A(4,2) += sums_nbr[noi][SWXXY];
      A(4,3) += sums_nbr[noi][SWXXZ];
      A(4,4) += sums_nbr[noi][SWXXXX];
      A(4,5) += sums_nbr[noi][SWXXXY];
      A(4,6) += sums_nbr[noi][SWXXXZ];
      A(4,7) += sums_nbr[noi][SWXXYY];
      A(4,8) += sums_nbr[noi][SWXXYZ];
      A(4,9) += sums_nbr[noi][SWXXZZ];
    }

    A(5,0) = rhs[0][5] = sums0[ip][SWXY];
    A(5,1) = sums0[ip][SWXXY];
    A(5,2) = sums0[ip][SWXYY];
    A(5,3) = sums0[ip][SWXYZ];
    A(5,4) = sums0[ip][SWXXXY];
    A(5,5) = sums0[ip][SWXXYY];
    A(5,6) = sums0[ip][SWXXYZ];
    A(5,7) = sums0[ip][SWXYYY];
    A(5,8) = sums0[ip][SWXYYZ];
    A(5,9) = sums0[ip][SWXYZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][5] = sums_nbr[noi][SWXY];
      A(5,0) += sums_nbr[noi][SWXY];
      A(5,1) += sums_nbr[noi][SWXXY];
      A(5,2) += sums_nbr[noi][SWXYY];
      A(5,3) += sums_nbr[noi][SWXYZ];
      A(5,4) += sums_nbr[noi][SWXXXY];
      A(5,5) += sums_nbr[noi][SWXXYY];
      A(5,6) += sums_nbr[noi][SWXXYZ];
      A(5,7) += sums_nbr[noi][SWXYYY];
      A(5,8) += sums_nbr[noi][SWXYYZ];
      A(5,9) += sums_nbr[noi][SWXYZZ];
    }

    A(6,0) = rhs[0][6] = sums0[ip][SWXZ];
    A(6,1) = sums0[ip][SWXXZ];
    A(6,2) = sums0[ip][SWXYZ];
    A(6,3) = sums0[ip][SWXZZ];
    A(6,4) = sums0[ip][SWXXXZ];
    A(6,5) = sums0[ip][SWXXYZ];
    A(6,6) = sums0[ip][SWXXZZ];
    A(6,7) = sums0[ip][SWXYYZ];
    A(6,8) = sums0[ip][SWXYZZ];
    A(6,9) = sums0[ip][SWXZZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][6] = sums_nbr[noi][SWXZ];
      A(6,0) += sums_nbr[noi][SWXZ];
      A(6,1) += sums_nbr[noi][SWXXZ];
      A(6,2) += sums_nbr[noi][SWXYZ];
      A(6,3) += sums_nbr[noi][SWXZZ];
      A(6,4) += sums_nbr[noi][SWXXXZ];
      A(6,5) += sums_nbr[noi][SWXXYZ];
      A(6,6) += sums_nbr[noi][SWXXZZ];
      A(6,7) += sums_nbr[noi][SWXYYZ];
      A(6,8) += sums_nbr[noi][SWXYZZ];
      A(6,9) += sums_nbr[noi][SWXZZZ];
    }

    A(7,0) = rhs[0][7] = sums0[ip][SWYY];
    A(7,1) = sums0[ip][SWXYY];
    A(7,2) = sums0[ip][SWYYY];
    A(7,3) = sums0[ip][SWYYZ];
    A(7,4) = sums0[ip][SWXXYY];
    A(7,5) = sums0[ip][SWXYYY];
    A(7,6) = sums0[ip][SWXYYZ];
    A(7,7) = sums0[ip][SWYYYY];
    A(7,8) = sums0[ip][SWYYYZ];
    A(7,9) = sums0[ip][SWYYZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][7] = sums_nbr[noi][SWYY];
      A(7,0) += sums_nbr[noi][SWYY];
      A(7,1) += sums_nbr[noi][SWXYY];
      A(7,2) += sums_nbr[noi][SWYYY];
      A(7,3) += sums_nbr[noi][SWYYZ];
      A(7,4) += sums_nbr[noi][SWXXYY];
      A(7,5) += sums_nbr[noi][SWXYYY];
      A(7,6) += sums_nbr[noi][SWXYYZ];
      A(7,7) += sums_nbr[noi][SWYYYY];
      A(7,8) += sums_nbr[noi][SWYYYZ];
      A(7,9) += sums_nbr[noi][SWYYZZ];
    }
    
    A(8,0) = rhs[0][8] = sums0[ip][SWYZ];
    A(8,1) = sums0[ip][SWXYZ];
    A(8,2) = sums0[ip][SWYYZ];
    A(8,3) = sums0[ip][SWYZZ];
    A(8,4) = sums0[ip][SWXXYZ];
    A(8,5) = sums0[ip][SWXYYZ];
    A(8,6) = sums0[ip][SWXYZZ];
    A(8,7) = sums0[ip][SWYYYZ];
    A(8,8) = sums0[ip][SWYYZZ];
    A(8,9) = sums0[ip][SWYZZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][8] = sums_nbr[noi][SWYZ];
      A(8,0) += sums_nbr[noi][SWYZ];
      A(8,1) += sums_nbr[noi][SWXYZ];
      A(8,2) += sums_nbr[noi][SWYYZ];
      A(8,3) += sums_nbr[noi][SWYZZ];
      A(8,4) += sums_nbr[noi][SWXXYZ];
      A(8,5) += sums_nbr[noi][SWXYYZ];
      A(8,6) += sums_nbr[noi][SWXYZZ];
      A(8,7) += sums_nbr[noi][SWYYYZ];
      A(8,8) += sums_nbr[noi][SWYYZZ];
      A(8,9) += sums_nbr[noi][SWYZZZ];
    }
    
    A(9,0) = rhs[0][9] = sums0[ip][SWZZ];
    A(9,1) = sums0[ip][SWXZZ];
    A(9,2) = sums0[ip][SWYZZ];
    A(9,3) = sums0[ip][SWZZZ];
    A(9,4) = sums0[ip][SWXXZZ];
    A(9,5) = sums0[ip][SWXYZZ];
    A(9,6) = sums0[ip][SWXZZZ];
    A(9,7) = sums0[ip][SWYYZZ];
    A(9,8) = sums0[ip][SWYZZZ];
    A(9,9) = sums0[ip][SWZZZZ];
    for (int noi = 0; noi < nnbr; ++noi) {
      rhs[noi+1][9] = sums_nbr[noi][SWZZ];
      A(9,0) += sums_nbr[noi][SWZZ];
      A(9,1) += sums_nbr[noi][SWXZZ];
      A(9,2) += sums_nbr[noi][SWYZZ];
      A(9,3) += sums_nbr[noi][SWZZZ];
      A(9,4) += sums_nbr[noi][SWXXZZ];
      A(9,5) += sums_nbr[noi][SWXYZZ];
      A(9,6) += sums_nbr[noi][SWXZZZ];
      A(9,7) += sums_nbr[noi][SWYYZZ];
      A(9,8) += sums_nbr[noi][SWYZZZ];
      A(9,9) += sums_nbr[noi][SWZZZZ];
    }
    
    // symmetry check...
    
    for (int i = 0; i < 10; ++i) {
      for (int j = i+1; j < 10; ++j) {
        assert(A(i,j) == A(j,i));
      }
    }

    // cholesky factor A...

    cholesky_fac_n10(L,A);
    
    // the full rhs for this polynomial is then...
    
    for (int i = 0; i < 10; ++i) {
      r[i] = rhs[0][i]*phi[ip];
      for (int noi = 0; noi < nnbr; ++noi) {
        const int ip_nbr = iponb[noi];
        assert(ip_nbr != ip);
        r[i] += rhs[noi+1][i]*phi[ip_nbr];
      }
    }
    
    for (int i = 0; i < 10; ++i) 
      r_check[i] = r[i];

    cholesky_solve_n10(r,L);

    cout << "cholesky_solve_n10: " << endl;
    for (int i = 0; i < 10; ++i) {
      cout << "r[" << i << "] = " << r[i] << endl;
    }
    cout << " r[1]/r_vv: " << r[1]/sums0[ip][0] << " vs grad: " << r[1]/sums0[ip][0]/phi_grad_exact[0] << endl;
    cout << " r[2]/r_vv: " << r[2]/sums0[ip][0] << " vs grad: " << r[2]/sums0[ip][0]/phi_grad_exact[1] << endl;
    cout << " r[3]/r_vv: " << r[3]/sums0[ip][0] << " vs grad: " << r[3]/sums0[ip][0]/phi_grad_exact[2] << endl;
    
    cout << "phi at points->xp: " << phi0_exact + DOT_PRODUCT(points->xp[ip],phi_grad_exact) << " phi(x_cv): " << phi[ip] << " nnbr: " << nnbr << endl;

    // check...
    
    cout << "check: " << endl;
    for (int i = 0; i < 10; ++i) {
      double this_r = 0.0;
      for (int j = 0; j < 10; ++j) {
        this_r += A(i,j)*r[j];
      }
      cout << " i: " << i << " this_r: " << this_r << " r_check[i]: " << r_check[i] << " diff: " << this_r-r_check[i] << endl;
      assert(fabs(this_r-r_check[i]) < 1.0E-15);
    }
    
    if (debug) 
      getchar();
    
    
  }

  MPI_Pause("SOOOOOOO FAR SOOOOOOOOO GOOOOOOOOOOD");
  
}





// old fluent binary stuff



CCCCCCC

        // format:
        // (10 (id start end type [ND]) (x y [z]))
        // [.] indicate optional parameters, depending on dimension
        const int id    = fr.getNextTokenAsHex(2);
        const int start = fr.getNextTokenAsHex(2);
        const int end   = fr.getNextTokenAsHex(2);
        const int type  = fr.getNextTokenAsHex(2);
        UNUSED(type);

        if (id == 0) {
          assert(start == 1);
          // declaration section, ND is omitted
          // set the node count for checking
          COUT2("    > global node declaration: " << end << " nodes");

          // intialize new surface points data
          nno = end;
        }
      }
      else if (strcmp(token,"13")==0) {
        // format:
        // (13 (id start end bc-type fa-type) ())
        const int id     = fr.getNextTokenAsHex(2);
        const int start  = fr.getNextTokenAsHex(2);
        const int end    = fr.getNextTokenAsHex(2);
        const int bcType   = fr.getNextTokenAsHex(2);

        // only process non-header information
        if (id != 0) {
          const int faType   = fr.getNextTokenAsHex(2);
          
          COUT2("    > face block: " << id);
          COUT2("      - found " << end - start + 1 << " faces of type " << faType);

          bool isInternal = false;

          if (faType >= 2 && faType <= 4) {
            ++fa_type_count[faType];
            int tris = (end - start + 1) * (faType - 2);
            int index;
            for (int i = start; i <= end; ++i) {
              for (int j = 0; j < (faType + 2); ++j) {
                index = fr.getNextTokenAsHex(2);
              }
              // if second cell listed is not 0 then this is an internal face
              if (index != 0) isInternal = true;
            }

            if (isInternal) {
              COUT2("      ! internal face zone detected; skipping");
              tri_internal += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else if (bcType == 31) {
              COUT2("      ! parent hanging-node section; skipping");
              tri_parent += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else {
              COUT2("      - equivalent to " << tris << " tris");
              tri_count += tris;
            }
          }
          else if (faType == 0 || faType == 5) {
            ++fa_type_count[faType];
            fr.advanceToLevel(2);
            int no_per_fa;
            int tris = 0;
            int cell_index;

            for (int ifa = start; ifa <= end; ++ifa) {
              no_per_fa = fr.getNextTokenAsHex(2);
              tris += no_per_fa - 2;

              for (int j = 0; j < (no_per_fa + 2); ++j) {
                cell_index = fr.getNextTokenAsHex(2);
              }
              // check second cell; if non-zero then this is an internal face
              if (cell_index != 0) isInternal = true;
            }

            if (isInternal) {
              COUT2("      ! internal face zone detected; skipping");
              tri_internal += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else if (bcType == 31) {
              COUT2("      ! parent hanging-node section; skipping");
              tri_parent += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else {
              COUT2("      - equivalent to " << tris << " tris");
              tri_count += tris;
            }
          }
        }
      }
      else if (strcmp(token,"2013")==0 || strcmp(token,"3013")==0) {
        // format:
        // (13 (id start end bc-type fa-type) ())
        const int id     = fr.getNextTokenAsHex(2);
        const int start  = fr.getNextTokenAsHex(2);
        const int end    = fr.getNextTokenAsHex(2);
        const int bcType = fr.getNextTokenAsHex(2);
        const int faType = fr.getNextTokenAsHex(2);

        fr.advanceToLevel(2);

        // only process non-header information
        if (id != 0) {
          COUT2("    > face block: " << id);
          COUT2("      - found  " << end - start + 1 << " faces of type " << faType);

          bool isInternal = false;

          if (faType >= 2 && faType <= 4) {
            int tris = (end - start + 1) * (faType - 2);

            int x[faType+2];
            for (int ifa = start; ifa <= end; ++ifa) {
              fr.readBinaryFaces(x,faType);
              // check if second cell is non-zero
              if (x[faType+1] != 0) isInternal = true;
            }

            if (isInternal) {
              COUT2("      ! internal face zone detected; skipping");
              tri_internal += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else if (bcType == 31) {
              COUT2("      ! parent hanging-node section; skipping");
              tri_parent += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else {
              COUT2("      - equivalent to " << tris << " tris");
              tri_count += tris;
            }
          }
          else if (faType == 0 || faType == 5) {
            int no_per_fa;
            int tris = 0;

            for (int ifa = start; ifa <= end; ++ifa) {
              fr.readBinaryInt(no_per_fa);
              tris += no_per_fa - 2;

              int x[no_per_fa+2];
              fr.readBinaryFaces(x,no_per_fa);
              // check if second cell is non-zero
              if (x[no_per_fa+1] != 0) isInternal = true;
            }

            if (isInternal) {
              COUT2("      ! internal face zone detected; skipping");
              tri_internal += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else if (bcType == 31) {
              COUT2("      ! parent hanging-node section; skipping");
              tri_parent += end-start+1;
              skipFaceZoneIds.insert(id);
            }
            else {
              COUT2("      - equivalent to " << tris << " tris");
              tri_count += tris;
            }
          }
        }
      }
      else if (strcmp(token,"3010")==0 || strcmp(token,"2010")==0) {
        // Need to properly stride across binary sections
        const int id    = fr.getNextTokenAsHex(2);
        const int start = fr.getNextTokenAsHex(2);
        const int end   = fr.getNextTokenAsHex(2);
        const int type  = fr.getNextTokenAsHex(2);
        const int noND  = fr.getNextTokenAsHex(2);
        UNUSED(id);
        UNUSED(type);
        UNUSED(noND);
        fr.advanceToLevel(2);

        if (strcmp(token,"3010")==0) {
          // read double precision from binary
          double d[3];
          for (int i = start; i <= end; ++i) fr.readBinaryNodes<double>(d,3);
        }
        else {
          assert(strcmp(token,"2010")==0);
          // read single precision from binary
          float d[3];
          for (int i = start; i <= end; ++i) fr.readBinaryNodes<float>(d,3);
        }
        // ------------------------------------------

      }
      else if (strcmp(token,"2012")==0 || strcmp(token,"3012")==0) {
        // Need to properly stride across binary sections
        // (2012 (id start end type elem-type) ())
        const int id     = fr.getNextTokenAsHex(2);
        const int start  = fr.getNextTokenAsHex(2);
        const int end    = fr.getNextTokenAsHex(2);
        const int type   = fr.getNextTokenAsHex(2);
        const int elemType = fr.getNextTokenAsHex(2);
        UNUSED(id);
        UNUSED(type);

        // only need to read cell description if of mixed-type
        if (elemType == 0) {
          fr.advanceToLevel(2);

          int cellType;
          for (int i = start; i <= end; ++i) {
            fr.readBinaryInt(cellType);
          }
        }
        // otherwise cell block is empty

      }
      else if (strcmp(token,"2041")==0) {
        // Need to properly stride across binary sections
        // (2041 (start end) ())
        const int start  = fr.getNextTokenAsHex(2);
        const int end    = fr.getNextTokenAsHex(2);

        fr.advanceToLevel(2);

        // assumes an int flag
        int tmp_flag;
        for (int i = start; i <= end; ++i) {
          fr.readBinaryInt(tmp_flag);
        }
      }
      else if (strcmp(token,"2059")==0 || strcmp(token,"2058")==0) {
        // Need to properly stride across binary sections
        // (2059/58 (start end parent-zone child-zone) ())
        // where zones are either face or cell blocks, depending
        const int start = fr.getNextTokenAsHex(2);
        const int end = fr.getNextTokenAsHex(2);
        const int parentZone = fr.getNextTokenAsHex(2);
        const int childZone = fr.getNextTokenAsHex(2);
        UNUSED(parentZone);
        UNUSED(childZone);

        fr.advanceToLevel(2);

        int n_children;
        for (int i = start; i <= end; ++i) {
          fr.readBinaryInt(n_children);
          for (int j=0; j<n_children; ++j) fr.readBinary<int,int>();  // don't need to store this info
        }
      }
    }
    COUT1("    > total face-to-tri count: " << tri_count);
    COUT1(" > reading data");

    for (int i = 0; i < 6; ++i)
      cout << " >> fa_type: " << i << " fa_type_count: " << fa_type_count[i] << endl;
    cout << " >> zoneVec.size(): " << zoneVec.size() << endl;
    getchar();

    fr.rewindFile();

    vector<int> zoneBcType;

    int current_tri = 0;
    int nno_count = 0;
    int nfa_count = 0;
    int nfa_total = 0;
    int nozone_count = 0;
    int fazone_count = 0;
    int zoHeader_count = 0;
    int cvzone_count = 0;

    while (fr.advanceToLevel(1)) {

      int level = fr.getNextToken(token);
      assert(level == 1);

      if (strcmp(token,"0")==0) {
      }
      else if (strcmp(token,"1")==0) {
      }
      else if (strcmp(token,"4")==0) {
      }
      else if (strcmp(token,"37")==0) {
      }
      else if (strcmp(token,"38")==0) {
      }
      else if (strcmp(token,"64")==0) {
      }
      else if (strcmp(token,"2")==0) {
      }
      else if (strcmp(token,"10")==0) {















        MPI_Pause("fsdfsdsfd");







        int work_rank = 0;
        if (mpi_rank == work_rank) {
          
          
          cout << "work_rank: " << work_rank << " got n1: " << n1 << " n2: " << n2 << " h: " << h << endl;

          // grab the tris associated with the surface patch and put them in an adt...
          // this surface group's tris are flagged as follows...
          vector<int> istVec;
          for (int ist = 0; ist < surface->nst; ++ist) {
            int igr_;
            if (partVec[ipart]->getGroupForSt(igr_,ist)) {
              if (igr_ == igr) {
                istVec.push_back(ist);
              }
            }
          }
          cout << " > istVec.size(): " << istVec.size() << endl;
          const int ntri = istVec.size();
          double (*bbmin)[3] = new double[ntri][3];
          double (*bbmax)[3] = new double[ntri][3];
          for (int itri = 0; itri < ntri; ++itri) {
            const int ist = istVec[itri];
            FOR_I3 bbmin[itri][i] = HUGE_VAL;
            FOR_I3 bbmax[itri][i] = -HUGE_VAL;
            FOR_I3 {
              const double * xsp = surface->xsp[surface->spost[ist][i]];
              FOR_J3 bbmin[itri][j] = min(bbmin[itri][j],xsp[j]);
              FOR_J3 bbmax[itri][j] = max(bbmax[itri][j],xsp[j]);
            }
          }
          Adt<double> adt(ntri,bbmin,bbmax);
          delete[] bbmin;
          delete[] bbmax;
          double (*xgr)[3] = new double[(n1+1)*(n2+1)][3];
          double xws[3]; FOR_I3 xws[i] = surface->xsp[spoli_v[idata[0]]][i];
          double xes[3]; FOR_I3 xes[i] = surface->xsp[spoli_v[idata[1]]][i];
          double xen[3]; FOR_I3 xen[i] = surface->xsp[spoli_v[idata[2]]][i];
          double xwn[3]; FOR_I3 xwn[i] = surface->xsp[spoli_v[idata[3]]][i];
          double d2_max = 0.0;
          vector<int> intVec;
          for (int i = 0; i <= n1; ++i) {
            const double xi = double(i)/double(n1);
            // coordinate values along the south and north edge...
            double xs[3]; csplineVec[0].getX(xs,xi);
            double xn[3]; csplineVec[2].getX(xn,1.0-xi);
            for (int j = 0; j <= n2; ++j) {
              const double eta = double(j)/double(n2);
              // coordinate values along the west and east edge...
              double xw[3]; csplineVec[3].getX(xw,1.0-eta);
              double xe[3]; csplineVec[1].getX(xe,eta);
              // transfinite interp...
              double x[3]; FOR_K3 x[k] = (1.0-eta)*xs[k] + eta*xn[k] + (1.0-xi)*xw[k] + xi*xe[k] - ( xi*eta*xen[k] + xi*(1.0-eta)*xes[k] + (1.0-xi)*eta*xwn[k] + (1.0-xi)*(1.0-eta)*xws[k] );
              if ((i == 0)||(i == n1)||(j == 0)||(j == n2)) {
                // this is an edge (or corner) point, so no projection is necessary...
                FOR_K3 xgr[IJ(i,j)][k] = x[k];
              }
              else {
                // this is an internal point, so project...  
                assert(intVec.empty());
                adt.buildListForClosestPoint(intVec,x);
                assert(!intVec.empty());
                double d2_min = HUGE_VAL;
                double xp_min[3];
                for (int ii = 0; ii < intVec.size(); ++ii) {
                  const int ist = istVec[intVec[ii]];
                  double xp[3]; MiscUtils::getClosestPointOnTriRobust(xp,x,surface->xsp[surface->spost[ist][0]],surface->xsp[surface->spost[ist][1]],surface->xsp[surface->spost[ist][2]]);
                  const double d2 = DIST2(xp,x);
                  if (d2 < d2_min) {
                    d2_min = d2;
                    FOR_K3 xp_min[k] = xp[k];
                  }
                }
                intVec.clear();
                assert(d2_min < HUGE_VAL);
                FOR_K3 xgr[IJ(i,j)][k] = xp_min[k];
                d2_max = max(d2_max,d2_min);
              }
            }
          }
        
          cout << " > max distance of initial transfinite points from surface: " << sqrt(d2_max) << endl;
          
          // now smooth and re-project the internal points a few times...
          
          for (int iter = 0; iter < 100; ++iter) {
            
            double d2_max = 0.0;
            for (int i = 1; i < n1; ++i) {
              for (int j = 1; j < n2; ++j) {
                // use transfinite interp as a 
                double x[3]; FOR_K3 x[k] = (1.0-0.5)*xgr[IJ(i,j-1)][k] + 0.5*xgr[IJ(i,j+1)][k] + (1.0-0.5)*xgr[IJ(i-1,j)][k] + 0.5*xgr[IJ(i+1,j)][k] - 
                               ( 0.5*0.5*xgr[IJ(i+1,j+1)][k] + 0.5*(1.0-0.5)*xgr[IJ(i+1,j-1)][k] + (1.0-0.5)*0.5*xgr[IJ(i-1,j+1)][k] + (1.0-0.5)*(1.0-0.5)*xgr[IJ(i-1,j-1)][k] );
                const double d2 = DIST2(xgr[IJ(i,j)],x);
                d2_max = max(d2_max,d2);
                FOR_K3 xgr[IJ(i,j)][k] = x[k];
              }
            }
            cout << " > smoothing iter: " << iter << " d: " << sqrt(d2_max) << endl;
            
          }

          
          // compute the max stand-off after filtering...

          d2_max = 0.0;
          for (int i = 1; i < n1; ++i) {
            for (int j = 1; j < n2; ++j) {
              assert(intVec.empty());
              adt.buildListForClosestPoint(intVec,xgr[IJ(i,j)]);
              assert(!intVec.empty());
              double d2_min = HUGE_VAL;
              double xp_min[3];
              for (int ii = 0; ii < intVec.size(); ++ii) {
                const int ist = istVec[intVec[ii]];
                double xp[3]; MiscUtils::getClosestPointOnTriRobust(xp,xgr[IJ(i,j)],surface->xsp[surface->spost[ist][0]],surface->xsp[surface->spost[ist][1]],surface->xsp[surface->spost[ist][2]]);
                const double d2 = DIST2(xp,xgr[IJ(i,j)]);
                if (d2 < d2_min) {
                  d2_min = d2;
                  FOR_K3 xp_min[k] = xp[k];
                }
              }
              intVec.clear();
              assert(d2_min < HUGE_VAL);
              d2_max = max(d2_max,d2_min);
            }
          }
          
          cout << " max stand-off distance after filtering: " << sqrt(d2_max) << " normalized by dn: " << sqrt(d2_max)/dn << endl;
          
          FILE * fp = fopen("pts_f.dat","w");
          for (int i = 0; i <= n1; ++i) {
            for (int j = 0; j <= n2; ++j) {
              fprintf(fp,"%18.15le %18.15le %18.15le\n",xgr[IJ(i,j)][0],xgr[IJ(i,j)][1],xgr[IJ(i,j)][2]);
            }
          }
          fclose(fp);
          
          // stretching stuff...
          // a few equation first:
          // for a stretched grid of n spaces with uniform stretching ratio between 
          // adjacent cvs, and first spacing dn,
          // and last spacing dt, we have:
          //   sf = pow(dt/dn,1.0/double(n-1))
          // total height;
          //   delta = (dt1*sf-dn)/(sf-1.0); 
          // and height at top of each interval, m = 1,2,3 ... n
          //   dx = dn*(pow(sf,m)-1.0)/(sf-1.0)
          
          fp = fopen("grid.dat","w");

          const double delta = h;
          const double dt = delta/double(n);
          
          
          int np = n;
          while (1) {
            cout << "np: " << np << endl;
            if (np == n) {
              // uniform spacing at h/n...
              for (int m = 0; m <= np; ++m) {
                double x = double(m)*dt;
                fprintf(fp,"%d %18.15le\n",np,x);
              }
            }
            else {
              
              assert(np > n);
              
              {
                const double t1 = log(double(np-1)*dt/(delta-dt))*double(np-1)/double(np);
                //const double sf = (exp(t1)*delta-dt)/(exp(t1)*(delta-dt));
                double sf = 2.0*(exp(t1)*delta-dt)/(exp(t1)*(delta-dt))-1.0;
                int iter = 0;
                while (1) {
                  ++iter;
                  if (iter > 30)
                    break;
                  const double t2 = pow(dt/(delta+sf*(dt-delta)),1.0/double(np-1));
                  const double f = sf - t2;
                  const double fp = 1.0 - t2*(delta-dt)/(double(np-1)*(delta+sf*(dt-delta)));
                  cout << "np = " << np << " got sf: " << sf << " f: " << f << " fp: " << fp << endl;
                  sf -= f/fp;
                
                  if (fabs(f/fp) < 1.0E-12)
                    break;
                }
              
                const double dn = dt*sf - delta*(sf-1.0); 
                const double delta_check = (dt*sf-dn)/(sf-1.0); 
              
                cout << " got sf: " << sf << " dn: " << dn << " delta_check: " << delta_check << " delta: " << delta << endl;
              
              }

              // or, try solving for dn...
              
              {
                
                // make an initial guess of 1/2 the slope zero value... 
                double dn = 0.5*exp(log(dt*double(np-1)/(delta-dt))/double(np))*(delta-dt)/double(np-1);
                int iter = 0;
                while (1) {
                  ++iter;
                  if (iter > 30) {
                    cout << "WOW: check this one out!" << endl;
                    break;
                  }
                  const double t1 = pow(dt/dn,double(np)/double(np-1));
                  const double t2 = pow(dt/dn,1.0/double(np-1));
                  const double f = dn*t1-delta*t2+delta-dn;
                  const double fp = (delta*t2-dn*t1-dn*double(np-1))/(dn*double(np-1));
                  cout << "XXX np = " << np << " got dn: " << dn << " f: " << f << " fp: " << fp << endl;
                  if (f > 0.5*dn*fp)
                    dn *= 0.5; // revert to bisection for stability
                  else {                       
                    dn -= f/fp;
                    if (fabs(f/fp) < 1.0E-15*dt)
                      break;
                  }
                }
              
                const double sf = pow(dt/dn,1.0/double(np-1));
                const double delta_check = (dt*sf-dn)/(sf-1.0); 

                cout << " XXXX got sf: " << sf << " dn: " << dn << " delta_check: " << delta_check << " delta: " << delta << endl;

                for (int m = 0; m <= np; ++m) {
                  double x = dn*(pow(sf,m)-1.0)/(sf-1.0);
                  fprintf(fp,"%d %18.15le\n",np,x);
                }
                
                
              }
              






            }
            ++np;
            if (np > 10*n)
              break;
          }

          fclose(fp);
          
          
        }
        
        MPI_Pause("take a look");
        assert(0);
        




        


        
        
        for (int ip = 0; ip < vb.points->np; ++ip) {
                const double dx[3] = DIFF(vb.points->xp[ip],xp);
                const double r = vb.points->delta[ip];
                if (fabs(DOT_PRODUCT(dx,unit_np)) <= r) {
                  FOR_I3 x_vv[count][i] = vb.points->xp[ip][i];
                  r_vv[count] = r;
                  int level = 0;
                  while (2.0*vb.points->delta[ip] < hcp.getPointsRvvForLevel(level))
                    ++level;
                  i_vv[count] = level;
                  ++count;
                }
              }
        


      
        // now all ranks count (and then write) all their local points...
      
      int my_np = 0;
      for (int ipart = 0; ipart < partVec.size(); ++ipart) {
        if (partVec[ipart]->pts) {
          my_np += partVec[ipart]->pts->np;
        }
      }
      if (hcpPts) my_np += hcpPts->np;












#ifdef JUFDHKDF

    // parts and then prepare the adt_2d...
    
    for (int ipart = 0; ipart < partVec.size(); ++ipart) {
      bool b_ff = false;
      int xy_ff_min[2] = { TWO_BILLION, TWO_BILLION };
      int xy_ff_max[2] = { -TWO_BILLION, -TWO_BILLION };
      bool b_solid = false;
      int xy_solid_min[2] = { TWO_BILLION, TWO_BILLION };
      int xy_solid_max[2] = { -TWO_BILLION, -TWO_BILLION };
      // this is the isInside logic... 
      for (int ipart1 = 0; ipart1 < partVec.size(); ++ipart1) {
        if (partVec[ipart1]->pts) {
          // we are going to include these ipart1 points in the build, if and only if they
          // are NOT inside the FF of every part later than us in the list (these parts take priority)
          // AND they are not inside the solid of any part. Since we are checking the FF of the
          // later parts, we can just check the solid of earlier parts...
          if ((ipart >= ipart1+1)&&(ipart < partVec.size())) {
            //if (partVec[ipart2]->isInsideFF(partVec[ipart1]->pts->xp[ip])) {
            b_ff = true;
            if (!b_dtoi) setDtoiStuff();
            for (int ip = 0; ip < partVec[ipart1]->pts->np; ++ip) {
              int xy[2]; 
              xy[0] = getEvenInt((partVec[ipart1]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e1_ff[0] + 
                                 (partVec[ipart1]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e1_ff[1] + 
                                 (partVec[ipart1]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e1_ff[2],dtoi_delta);
              xy[1] = getEvenInt((partVec[ipart1]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e2_ff[0] + 
                                 (partVec[ipart1]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e2_ff[1] + 
                                 (partVec[ipart1]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e2_ff[2],dtoi_delta);
              FOR_I2 {
                xy_ff_min[i] = min(xy_ff_min[i],xy[i]);
                xy_ff_max[i] = max(xy_ff_max[i],xy[i]);
              }
            }
          }
          if ((ipart >= 0)&&(ipart < ipart1)) {
            //if (partVec[ipart]->isInsideSolid(partVec[ipart]->pts->xp[ip],ipart==0)) {
            b_solid = true;
            if (!b_dtoi) setDtoiStuff();
            for (int ip = 0; ip < partVec[ipart1]->pts->np; ++ip) {
              int xy[2]; 
              xy[0] = getEvenInt((partVec[ipart1]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e1_ff[0] + 
                                 (partVec[ipart1]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e1_ff[1] + 
                                 (partVec[ipart1]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e1_ff[2],dtoi_delta);
              xy[1] = getEvenInt((partVec[ipart1]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e2_ff[0] + 
                                 (partVec[ipart1]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e2_ff[1] + 
                                 (partVec[ipart1]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e2_ff[2],dtoi_delta);
              FOR_I2 {
                xy_solid_min[i] = min(xy_solid_min[i],xy[i]);
                xy_solid_max[i] = max(xy_solid_max[i],xy[i]);
              }
            }
          }
        }
      }
      if (mpi_rank == 0) cout << "XXXX ipart: " << ipart << " b_ff: " << b_ff << " b_solid: " << b_solid << endl;
      //MPI_Pause("fgjkfjkl");

      if (b_ff) {
        if (partVec[ipart]->adt2d_ff == NULL) {
          partVec[ipart]->prepareIsInsideFF(xy_ff_min,xy_ff_max);
        }
      }
      if (b_solid) {
        if (partVec[ipart]->adt2d_solid == NULL) {
          partVec[ipart]->prepareIsInsideSolid(xy_solid_min,xy_solid_max);
        }
      }

    }
    
    return;



    // HACK: discard this....









    for (int ipart = 0; ipart < partVec.size(); ++ipart) {

      bool b_ff = false;
      int xy_ff_min[2] = { TWO_BILLION, TWO_BILLION };
      int xy_ff_max[2] = { -TWO_BILLION, -TWO_BILLION };

      bool b_solid = false;
      int xy_solid_min[2] = { TWO_BILLION, TWO_BILLION };
      int xy_solid_max[2] = { -TWO_BILLION, -TWO_BILLION };

      // now set the bbox depending on the ff_type and solid_type...

      // -------------------------------------------
      // step 1: consider ff first...
      // -------------------------------------------
      
      if (partVec[ipart]->ff_type == FAZONE_FF) {
        // TODO: need to consider the case when ff_surface is used: later...
        assert(partVec[ipart]->surface);
        assert(partVec[ipart]->surface_zn_flag);
        assert(partVec[ipart]->ff_surface == NULL);
        // this part needs an adt2d_ff. If one already exists, we assume it
        // is suitable...
        if (partVec[ipart]->adt2d_ff == NULL) {
          // we will need double-to-integer conversion. Make sure this is current...
          if (!b_dtoi) setDtoiStuff();
          // all lower priority part points will be checked against this part's
          // FF surface. First build the bbox of those points...
          int xy[2]; 
          for (int ipart2 = 0; ipart2 < ipart; ++ipart2) {
            if (partVec[ipart2]->pts) {
              for (int ip = 0; ip < partVec[ipart2]->pts->np; ++ip) {
                xy[0] = getEvenInt((partVec[ipart2]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e1_ff[0] + 
                                   (partVec[ipart2]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e1_ff[1] + 
                                   (partVec[ipart2]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e1_ff[2],dtoi_delta);
                xy[1] = getEvenInt((partVec[ipart2]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e2_ff[0] + 
                                   (partVec[ipart2]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e2_ff[1] + 
                                   (partVec[ipart2]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e2_ff[2],dtoi_delta);
                b_ff = true;
                FOR_I2 {
                  xy_ff_min[i] = min(xy_ff_min[i],xy[i]);
                  xy_ff_max[i] = max(xy_ff_max[i],xy[i]);
                }
              }
            }
          }
        }
      }
      else if (partVec[ipart]->ff_type == NO_FF) {
        // this part will use the adt2d_solid to check against the ff of lower points...
        assert(partVec[ipart]->surface);
        if (partVec[ipart]->adt2d_solid == NULL) {
          // we will need double-to-integer conversion. Make sure this is current...
          if (!b_dtoi) 
            setDtoiStuff();
          int xy[2]; 
          for (int ipart2 = 0; ipart2 < ipart; ++ipart2) {
            if (partVec[ipart2]->pts) {
              for (int ip = 0; ip < partVec[ipart2]->pts->np; ++ip) {
                xy[0] = getEvenInt((partVec[ipart2]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e1_ff[0] + 
                                   (partVec[ipart2]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e1_ff[1] + 
                                   (partVec[ipart2]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e1_ff[2],dtoi_delta);
                xy[1] = getEvenInt((partVec[ipart2]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e2_ff[0] + 
                                   (partVec[ipart2]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e2_ff[1] + 
                                   (partVec[ipart2]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e2_ff[2],dtoi_delta);
                b_solid = true;
                FOR_I2 {
                  xy_solid_min[i] = min(xy_solid_min[i],xy[i]);
                  xy_solid_max[i] = max(xy_solid_max[i],xy[i]);
                }
              }
            }
          }
        }
      }
      else {
        if (mpi_rank == 0) cout << "Warning: don't know how to prepareIsInside for partVec[ipart]->ff_type: " << partVec[ipart]->ff_type << endl;
      }
      
      // -------------------------------------------
      // step 2: consider solid second...
      // -------------------------------------------
      
      if (partVec[ipart]->solid_type == FAZONE_SOLID) {
        assert(partVec[ipart]->surface);
        // this part needs an adt2d_solid. If one already exists, we assume it
        // is suitable...
        if (partVec[ipart]->adt2d_solid == NULL) {
          // we will need double-to-integer conversion. Make sure this is current...
          if (!b_dtoi) setDtoiStuff();
          // all higher priority part points will be checked against this part's
          // solid. First build the bbox of those points...
          int xy[2]; 
          for (int ipart2 = ipart+1; ipart2 < partVec.size(); ++ipart2) {
            if (partVec[ipart2]->pts) {
              for (int ip = 0; ip < partVec[ipart2]->pts->np; ++ip) {
                xy[0] = getEvenInt((partVec[ipart2]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e1_ff[0] + 
                                   (partVec[ipart2]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e1_ff[1] + 
                                   (partVec[ipart2]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e1_ff[2],dtoi_delta);
                xy[1] = getEvenInt((partVec[ipart2]->pts->xp[ip][0]-dtoi_x0[0])*partVec[ipart]->e2_ff[0] + 
                                   (partVec[ipart2]->pts->xp[ip][1]-dtoi_x0[1])*partVec[ipart]->e2_ff[1] + 
                                   (partVec[ipart2]->pts->xp[ip][2]-dtoi_x0[2])*partVec[ipart]->e2_ff[2],dtoi_delta);
                b_solid = true;
                FOR_I2 {
                  xy_solid_min[i] = min(xy_solid_min[i],xy[i]);
                  xy_solid_max[i] = max(xy_solid_max[i],xy[i]);
                }
              }
            }
          }
        }
      }
      else {
        if (mpi_rank == 0) cout << "Warning: don't know prepareIsInside partVec[ipart]->solid_type: " << partVec[ipart]->solid_type << endl;
      }
      
      // -------------------------------------------
      // finally, call the part prepare routines is required...
      // -------------------------------------------

      if (b_ff)    partVec[ipart]->prepareIsInsideFF(xy_ff_min,xy_ff_max);
      if (b_solid) partVec[ipart]->prepareIsInsideSolid(xy_solid_min,xy_solid_max);
      
    }

#endif





void makeTcone(const double x0[3],const double x1[3],const double r0,const double r1,const int n) {
    
    // x0,x1 are at the centers of the left and right cylinder cap. r is the radius
    
    assert(zoneVec.empty());
    assert(xsp == NULL);
    assert(spost == NULL);
    assert(znost == NULL);
    assert(pbi == NULL);
    
    // everyone gets the zones...
    
    const int zone_x0 = 0; zoneVec.push_back(StZone("x0")); 
    const int zone_x1 = 1; zoneVec.push_back(StZone("x1"));
    const int zone_tcone = 2; zoneVec.push_back(StZone("tcone"));
    
    // shm allocation...
    
    init(2+n*2,n*4);
    
    if (mpi_rank_shared == 0) {

      // n points around base...
      const double dx[3] = DIFF(x1,x0);
      const double dx_mag = MAG(dx);
      assert(dx_mag > 0.0);

      // absolute value ensures no singularity in the middle of the tcone as well as positive volume
      assert(r0 > 0.0);
      assert(r1 > 0.0);

      // first and last node are cap centers
      FOR_I3 {
        xsp[0][i] = x0[i];
        xsp[nsp-1][i] = x1[i];
      }
      
      // create nodes around each cap, cap0 first [1:n],
      // then cap1 [n+1:2n]
      GeomUtils::createCirclePts(xsp+1,n,x0,dx,r0);
      GeomUtils::createCirclePts(xsp+n+1,n,x1,dx,r1);

      // cap0, cap1
      GeomUtils::facetCircleToPoint(spost+0,znost,0,1,0,n,false);
      GeomUtils::facetCircleToPoint(spost+3*n,znost,nsp-1,n+1,1new_zone,n,true);
      
      // tcone
      GeomUtils::facetCircleToCircle(spost+n,znost,1,n+1,new_zone,n,true,true);
      
    }

    MPI_Barrier(mpi_comm_shared);

}



  void processWriteImageOld(Param * param) {
    
    // here we use a 2-step initialization of the scene, where we 
    // initialize a "wid" first using the wid.init(param,step) method
    // which will return non-zero if step%interval != 0, and we 
    // can return quickly without further instantiation...

    // note that we hard-code step = 0 here but some day when this 
    // is part of stitch lloyd iterations, this may be useful...
   
#ifdef WITH_CHRONO
    auto t0 = std::chrono::high_resolution_clock::now();
#endif

    int step = 0;
    WriteImageData wid;
    if (wid.init(param,step) != 0)
      return;
    
    CtiScene * scene = new CtiScene(wid);
    
    // pass details about the model geometry to the scene->..
    // TODO: make sure the following are also parallel...
    
    scene->setRmax(getBoundingBoxRmax());
    double bbmin[3],bbmax[3];
    getBbox(bbmin,bbmax);
    scene->setBoundingBbox(bbmin[0],bbmax[0],bbmin[1],bbmax[1],bbmin[2],bbmax[2]);
    double center[3];
    getBoundingBoxCenter(center);
    scene->setCenter(center[0],center[1],center[2]);
    //scene->setMaxIndex(35);

    // and draw...
    
    for (int izone = 0; izone < zoneVec.size(); ++izone) scene->addZoneName(zoneVec[izone].getName()); // ME/DP why do we need to do this? can't we just use indexed-based access to zones
    scene->initCanvas();
    
    // put this following into init...
    
    if (scene->hasGeomPlane()) {
      scene->setGeomPlaneAsDataPlane();
      if (scene->blankDataPlane()) 
        scene->addGeomPlaneAsBlankPlane(); // should be changed to back in scene/canvas
    }
      
    // need full surface (for now) to get properly masked canvas, similar to "points" viz in stitch...
      
    for (int ipart = 0; ipart < partVec.size(); ++ipart) {
      if (partVec[ipart]->surface) {
        // divide up surface tris evenly and contiguously amongst all ranks...
        int my_nst_avg = partVec[ipart]->surface->nst/mpi_size;
        if (partVec[ipart]->surface->nst%mpi_size) ++my_nst_avg;
        const int ist0 = min(partVec[ipart]->surface->nst,mpi_rank*my_nst_avg);
        const int ist1 = min(partVec[ipart]->surface->nst,(mpi_rank+1)*my_nst_avg);
        assert(ist1-ist0 <= my_nst_avg);
        // for the zone information, we provide a local array that maps the surface tri zone to the 
        // solver zone using the part's znosz (zone-of-surface-zone)...
        int * zone = new int[ist1-ist0];
        //int (*spost)[3] = new int[ist1-ist0][3];
        int nst_render = 0;
        for (int ist = ist0; ist < ist1; ++ist) {
          // TODO: this added to stop automatic FF render in moving solver: need to rethink here  
          //if ((partVec[ipart]->surface_zone_flag == NULL)||(partVec[ipart]->surface_zone_flag[partVec[ipart]->surface->znost[ist]] == 0)) {
          zone[nst_render] = partVec[ipart]->znosz[partVec[ipart]->surface->znost[ist]];
          //FOR_I3 spost[nst_render][i] = partVec[ipart]->surface->spost[ist][i];
          ++nst_render;
          //}
        }
        assert(nst_render == ist1-ist0);
        scene->addTris(partVec[ipart]->surface->xsp,partVec[ipart]->surface->spost+ist0,zone,nst_render);
        delete[] zone;
        //delete[] spost;
      }
    }

    // look at ff zones as well?...

    /*
      for (int ipart = 0; ipart < partVec.size(); ++ipart) {
      if (partVec[ipart]->ff_surface) {
      // divide up surface tris evenly and contiguously amongst all ranks...
      int my_nst_avg = partVec[ipart]->ff_surface->nst/mpi_size;
      if (partVec[ipart]->ff_surface->nst%mpi_size) ++my_nst_avg;
      const int ist0 = min(partVec[ipart]->ff_surface->nst,mpi_rank*my_nst_avg);
      const int ist1 = min(partVec[ipart]->ff_surface->nst,(mpi_rank+1)*my_nst_avg);
      assert(ist1-ist0 <= my_nst_avg);
      // for the zone information, we provide a local array that maps the surface tri zone to the 
      // solver zone using the part's znosz (zone-of-surface-zone)...
      int * zone = new int[ist1-ist0];
      //int (*spost)[3] = new int[ist1-ist0][3];
      int nst_render = 0;
      for (int ist = ist0; ist < ist1; ++ist) {
      // TODO: this added to stop automatic FF render in moving solver: need to rethink here  
      //if ((partVec[ipart]->surface_zone_flag == NULL)||(partVec[ipart]->surface_zone_flag[partVec[ipart]->surface->znost[ist]] == 0)) {
      zone[nst_render] = 12345; // TODO ????
      //FOR_I3 spost[nst_render][i] = partVec[ipart]->surface->spost[ist][i];
      ++nst_render;
      //}
      }
      assert(nst_render == ist1-ist0);
      scene->addTris(partVec[ipart]->ff_surface->xsp,partVec[ipart]->ff_surface->spost+ist0,zone,nst_render);
      delete[] zone;
      //delete[] spost;
      }
      }
    */
    
    if (scene->hasGeomPlane()) {
      
      if (scene->hasVar()) assert((scene->getVar() == "mesh")||(scene->getVar() == "points")||(scene->getVar() == "r_vv"));
      
      if (mpi_rank == 0) cout << "scene->hasVar(): " << scene->hasVar() << endl;
  
      double xp[3],np[3];
      scene->getGeomPlaneXpAndNp(xp,np);
      if (mpi_rank == 0) cout << "getGeomPlaneXpAndNp: " << COUT_VEC(xp) << " " << COUT_VEC(np) << endl;

      if (!((b_all_mesh_points)||(b_plane_mesh_points&&(plane_mesh_points_x[0]==xp[0])&&
				  (plane_mesh_points_x[1]==xp[1])&&(plane_mesh_points_x[2]==xp[2])&&
				  (plane_mesh_points_n[0]==np[0])&&(plane_mesh_points_n[1]==np[1])&&
				  (plane_mesh_points_n[2]==np[2])))) {
	// we do not have the correct points built for this view. So build the points in 
	// the requested plane...
	FOR_I3 plane_mesh_points_x[i] = xp[i];
	FOR_I3 plane_mesh_points_n[i] = np[i];
	buildPointsNearPlane(xp,np);
	b_plane_mesh_points = true;
        b_all_mesh_points = false;
      }

      int count = vertexVec.size();
      double (*x_vv)[3] = new double[count][3];
      double *r_vv = new double[count];
      int * i_vv = new int[count];
      if (b_plane_mesh_points) {

        // put all points into write...
        for (int iv = 0; iv < vertexVec.size(); ++iv) {
          FOR_I3 x_vv[iv][i] = vertexVec[iv].x[i];
          r_vv[iv] = hcp_packing_factor*hcp_delta_factor*hcp_delta/double(1<<vertexVec[iv].level);
          i_vv[iv] = (vertexVec[iv].window<<HCP_WINDOW_SHIFT_BITS)|vertexVec[iv].level;
        }
        //MiscUtils::dumpRange(i_vv,vertexVec.size(),"i_vv");

      }
      else if (b_all_mesh_points) {

        // need to prune points to those within thickened plane...
        count = 0;
        const double mag = MAG(np); assert(mag > 0.0);
        const double unit_np[3] = {np[0]/mag,np[1]/mag,np[2]/mag};
        for (int iv = 0; iv < vertexVec.size(); ++iv) {
          const double dx[3] = DIFF(vertexVec[iv].x,xp);
          const double r = hcp_packing_factor*hcp_delta_factor*hcp_delta/double(1<<vertexVec[iv].level);
          if (fabs(DOT_PRODUCT(dx,unit_np)) <= r) {
            FOR_I3 x_vv[count][i] = vertexVec[iv].x[i];
            r_vv[count] = r;
            i_vv[count] = (vertexVec[iv].window<<HCP_WINDOW_SHIFT_BITS)|vertexVec[iv].level;
            count++;
          }
        }

      }

      if (scene->getVar() == "mesh") {
        scene->addPlaneMesh(x_vv,r_vv,i_vv,count,2.0);
      }
      else if (scene->getVar() == "points") {
        scene->addPointsMesh(x_vv,r_vv,i_vv,count,1.0);
      }
      else {
        assert(scene->getVar() == "r_vv");
        scene->addPlaneData(r_vv,x_vv,r_vv,count,1.0);
      }

      delete[] x_vv;
      delete[] r_vv;
      delete[] i_vv;

      // also add any part-based pts that we have...
      for (int ipart = 0; ipart < partVec.size(); ++ipart) {
        if (partVec[ipart]->pts) {
          int * flag = new int[partVec[ipart]->pts->np];
          for (int ip = 0; ip < partVec[ipart]->pts->np; ++ip) {
            flag[ip] = ((hcpWindowList.size()+ipart+1)<<HCP_WINDOW_SHIFT_BITS)|LEVEL_MASK_BITS;
          }
          if (scene->getVar() == "mesh") {
            scene->addPlaneMesh(partVec[ipart]->pts->xp,partVec[ipart]->pts->delta,flag,partVec[ipart]->pts->np,2.0);
          }
          else if (scene->getVar() == "points") {
            scene->addPointsMesh(partVec[ipart]->pts->xp,partVec[ipart]->pts->delta,flag,partVec[ipart]->pts->np,1.0);
          }
          else {
            assert(scene->getVar() == "r_vv");
            scene->addPlaneData(partVec[ipart]->pts->delta,partVec[ipart]->pts->xp,partVec[ipart]->pts->delta,partVec[ipart]->pts->np,1.0);
          }
          delete[] flag;
        }
      }
      
    }
      

#ifdef WITH_CHRONO
    auto t1 = std::chrono::high_resolution_clock::now();
#endif
    
    // --------------------------------------
    // finally, write the image...
    // --------------------------------------

    if ( scene->isClientRequest() ) {
      // don't add step index to filename when interacting with Cascade client...
      scene->writeImage();
    }
    else { 
      scene->writeImage(step);
    }

    delete scene;
    
#ifdef WITH_CHRONO
    auto t2 = std::chrono::high_resolution_clock::now();
    {
      std::chrono::duration<double> elapsed1 = t1-t0;
      std::chrono::duration<double> elapsed2 = t2-t1;
      double my_buf[2];
      my_buf[0] = elapsed1.count();
      my_buf[1] = elapsed2.count();
      double buf[2];
      MPI_Reduce(my_buf,buf,2,MPI_DOUBLE,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
        cout << "[TIMING]: " << buf[0]/double(mpi_size) << " " << buf[1]/double(mpi_size) << endl;
      }
    }
#endif
    
  }


double VoronoiBuilder::calcSolidBodyRotation(double R[3][3], double t[3], const int ip, const set<uint8>& rbiNbrSet,
                                             const double (*xp0)[3], const map<const uint8,int>& rbiMap, const double (*xg)[3], const double (*xg0)[3]) const { // returns error

  // serial for now...
  //assert(mpi_size == 1);

  // 1. compute the centroids of both point sets, p and q...
  const int npop = 1+rbiNbrSet.size();
  //cout << "npop: " << npop << endl;
  double p[3] = {xp0[ip][0],xp0[ip][1],xp0[ip][2]};
  double q[3] = {points->xp[ip][0],points->xp[ip][1],points->xp[ip][2]};
  for (set<uint8>::const_iterator iter = rbiNbrSet.begin(); iter != rbiNbrSet.end(); ++iter) {
    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,*iter);
    if (rank == mpi_rank) {
      assert((index >= 0)&&(index < points->np));
      assert(index != ip);
      FOR_I3 p[i] += xp0[index][i];
      FOR_I3 q[i] += points->xp[index][i];
    }
    else {
      map<const uint8,int>::const_iterator iter2 = rbiMap.find(*iter);
      assert(iter2 != rbiMap.end());
      FOR_I3 p[i] += xg0[iter2->second][i];
      FOR_I3 q[i] += xg[iter2->second][i];
    }
  }
  FOR_I3 p[i] /= (double)npop;
  FOR_I3 q[i] /= (double)npop;

  // 2. compute the centered vectors, dp and dq...
  double (*dp)[3] = new double[npop][3];
  double (*dq)[3] = new double[npop][3];
  FOR_I3 dp[0][i] = xp0[ip][i] - p[i];
  FOR_I3 dq[0][i] = points->xp[ip][i] - q[i];
  int ipop = 0;
  for (set<uint8>::const_iterator iter = rbiNbrSet.begin(); iter != rbiNbrSet.end(); ++iter) {
    ++ipop;
    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,*iter);
    if (rank == mpi_rank) {
      assert((index >= 0)&&(index < points->np));
      assert(index != ip);
      FOR_I3 dp[ipop][i] = xp0[index][i] - p[i];
      FOR_I3 dq[ipop][i] = points->xp[index][i] - q[i];
    }
    else {
      map<const uint8,int>::const_iterator iter2 = rbiMap.find(*iter);
      assert(iter2 != rbiMap.end());
      FOR_I3 dp[ipop][i] = xg0[iter2->second][i] - p[i];
      FOR_I3 dq[ipop][i] = xg[iter2->second][i] - q[i];
    }
  }

  // 3. compute the 3x3 covariance matrix, S...
  double S[3][3];
  FOR_I3 {
    FOR_J3 {
      S[i][j] = 0.0;
      for (int ipop = 0; ipop < npop; ++ipop) {
        S[i][j] += dp[ipop][i]*dq[ipop][j];
      }
    }
  }
  delete[] dp;
  delete[] dq;

  // 4. compute the 3x3 singular value decomposition, S = U * E * Transpose[V]...
  double U[3][3], E[3][3], V[3][3];
  svd(S[0][0], S[0][1], S[0][2], S[1][0], S[1][1], S[1][2], S[2][0], S[2][1], S[2][2],
      U[0][0], U[0][1], U[0][2], U[1][0], U[1][1], U[1][2], U[2][0], U[2][1], U[2][2],
      E[0][0], E[0][1], E[0][2], E[1][0], E[1][1], E[1][2], E[2][0], E[2][1], E[2][2],
      V[0][0], V[0][1], V[0][2], V[1][0], V[1][1], V[1][2], V[2][0], V[2][1], V[2][2]);

  // 5. compute the optimal rotation and translation, R and t...
  double VUt[3][3] = MAT_TMAT_MULT(V,U);

  double det = DETERMINANT(VUt);

  multADBt(V[0][0], V[0][1], V[0][2], V[1][0], V[1][1], V[1][2], V[2][0], V[2][1], V[2][2],
           1.0, 1.0, det,
           U[0][0], U[0][1], U[0][2], U[1][0], U[1][1], U[1][2], U[2][0], U[2][1], U[2][2],
           R[0][0], R[0][1], R[0][2], R[1][0], R[1][1], R[1][2], R[2][0], R[2][1], R[2][2]);

  FOR_I3 t[i] = q[i] - (R[i][0]*p[0]+R[i][1]*p[1]+R[i][2]*p[2]);

  // 6. compute error in using R and t
  double max_error;
  {
    const double Rp[3] = MAT_VEC_MULT(R,xp0[ip]);
    double error[3]; FOR_I3 error[i] = fabs(points->xp[ip][i]-Rp[i]-t[i]);
    max_error = MAG(error);
  }
  for (set<uint8>::const_iterator iter = rbiNbrSet.begin(); iter != rbiNbrSet.end(); ++iter) {
    ++ipop;
    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,*iter);
    if (rank == mpi_rank) {
      assert((index >= 0)&&(index < points->np));
      assert(index != ip);
      const double Rp[3] = MAT_VEC_MULT(R,xp0[index]);
      double error[3]; FOR_I3 error[i] = fabs(points->xp[index][i]-Rp[i]-t[i]);
      double my_error = MAG(error);
      max_error = fmax(max_error,my_error);
    }
    else {
      map<const uint8,int>::const_iterator iter2 = rbiMap.find(*iter);
      assert(iter2 != rbiMap.end());
      const double Rp[3] = MAT_VEC_MULT(R,xg0[iter2->second]);
      double error[3]; FOR_I3 error[i] = fabs(xg[iter2->second][i]-Rp[i]-t[i]);
      double my_error = MAG(error);
      max_error = fmax(max_error,my_error);
    }
  }
  return max_error/points->delta[ip];

}















      
      SurfaceShm * surface = NULL;
      bool b_hcp = false;
      
      int ierr = 0;
      FOR_PARAM_MATCHING("PART") {
        
        int iarg = 0;
        while (iarg < param->size()) {
          string token = param->getString(iarg++);
          if (token == "NAME") {
            if (mpi_rank == 0) cout << "PART NAME " << param->getString(iarg++) << endl;
          }
          else if (token == "SURF") {
            token = param->getString(iarg++);
            if ((token == "SBIN")||(token == "BIN")) {
              assert(surface == NULL);
              surface = new SurfaceShm(param->getString(iarg++));
            }
            else {
              assert(0);
            }
          }
          else if (token == "PTS") {
            token = param->getString(iarg++);
            if (token == "HCP") {
              b_hcp = true;
            }
            else {
              assert(0);
            }
          }
          else {
            if (mpi_rank == 0) cout << "Error: unrecognized PART token: " << token << endl;
            ierr = -1;
          }
        }
      }

      // now build the 
      assert(surface);
      assert(b_hcp);
      vector<int> rayIntVec;
      vector<double> rayDoubleVec;
      HcpPointBuilderNew hpb(surface);

      if (checkParam("DOIT"))
        hpb.doit(rayIntVec,rayDoubleVec);
      else if (checkParam("DOIT2"))
        hpb.doit2(rayIntVec,rayDoubleVec);
      else if (checkParam("DOIT3"))
        hpb.doit3(rayIntVec,rayDoubleVec);
      else if (checkParam("DOIT4"))
        hpb.doit4(rayIntVec,rayDoubleVec);
      else
        hpb.doit5();
      
      
        
      int8 my_memory = rayIntVec.size()*4 + rayDoubleVec.size()*8;
      int8 memory;
      MPI_Reduce(&my_memory,&memory,1,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) 
        cout << "done. compressed seed memory: " << double(memory)*1.0E-6 << " [MB] total, or: " << double(memory)/double(mpi_size)*1.0E-6 << " [MB] per rank" << endl;
    










    {
      int ileaf_max = 0;
      int nbb_max = nbb;
      while (nbb_max > 1) {
        // recall that any leaf will have children 2*ileaf+1 and 2*ileaf+2...
        // if nbb_max is even, then the tree will split evenly, and 
        // the largest leaf will be associated with the right split...
        if (nbb_max%2 == 0) {
          // this is an even split, so choose the right path...
          ileaf_max = 2*ileaf_max + 2;
          nbb_max = nbb_max/2;
        }
        else {
          // this is an odd split, so choose the left path...
          ileaf_max = 2*ileaf_max + 1;
          nbb_max = nbb_max/2 + 1;
        }
      }
      if (mpi_rank == 0) cout << " > minimal global nleaves: " << ileaf_max+1 << endl; 
    }
    
    /*
    int nleaves = 1;
    int nleaves_level = 1;
    while (nleaves_level < nbb) {
      nleaves_level *= 2;
      nleaves += nleaves_level;
    }
    if (mpi_rank == 0) cout << " > global nbb: " << nbb << " nleaves: " << nleaves << endl;
    */

    // this is 1 bigger than the above?...

    {
    for (int nbb = 1; nbb < 258; ++nbb) {





    {
      int ileaf_max = 0;
      int nbb_max = nbb;
      while (nbb_max > 1) {
        // recall that any leaf will have children 2*ileaf+1 and 2*ileaf+2...
        // if nbb_max is even, then the tree will split evenly, and 
        // the largest leaf will be associated with the right split...
        if (nbb_max%2 == 0) {
          // this is an even split, so choose the right path...
          ileaf_max = 2*ileaf_max + 2;
          nbb_max = nbb_max/2;
        }
        else {
          // this is an odd split, so choose the left path...
          ileaf_max = 2*ileaf_max + 1;
          nbb_max = nbb_max/2 + 1;
        }
      }
      cout << "XXXXXX " << nbb << " " << nleaves << " " << ileaf_max+1 << endl;
    }




    
    }
    }

    MPI_Pause("OKOK");
    




      
      


      // and do it here...
      int (*leafdata)[6] = new int[nleaves][6]; // jmin, kmin, -jmax, -kmax, i_f, i_l...

      leafdata[0][0] = bbminmax[0]; // jmin
      leafdata[0][1] = bbminmax[1]; // kmin
      leafdata[0][2] = -bbminmax[2]; assert(leafdata[0][2] >= leafdata[0][0]);
      leafdata[0][3] = -bbminmax[3]; assert(leafdata[0][3] >= leafdata[0][1]);
      leafdata[0][4] = 0;
      leafdata[0][5] = my_nbb-1;

      stack[0] = 0;
      int istack = 1;
      
      // also allocate this memory outside the loop...
      int * buf_int = new int[my_nbb*3]; // here we use 3 intead of 2 to ensure it can hold 1/2 of the first batch
      
      while (istack > 0) {
        
	// pop the next leaf off the stack...
	const int ileaf = stack[--istack];
        assert(2*ileaf+2 < nleaves);
        
        // the leaf data contains the range in mybbVec...
	const int ibb_f = leafdata[ileaf][4];
	const int ibb_l = leafdata[ileaf][5];
        const int nbb = ibb_l-ibb_f+1;
        assert(nbb >= 2); // if it were 1 (never 0), should have been handled already!
        const int nbb_half = nbb/2;
        
        if ((mpi_rank == 0)&&(nbb > 1000000)) cout << " > working on nbb: " << nbb << endl;
        
        bbminmax[0] = leafdata[ileaf][0];
        bbminmax[1] = leafdata[ileaf][1];
        bbminmax[2] = -leafdata[ileaf][2];
        bbminmax[3] = -leafdata[ileaf][3];

        // check the bbminmax using the actual range of data....
        /*
        {
          int bbminmax_check[4] = { TWO_BILLION, TWO_BILLION, TWO_BILLION, TWO_BILLION };
          for (int ibb = ibb_f; ibb <= ibb_l; ++ibb) {
            FOR_I4 bbminmax_check[i] = min(bbminmax_check[i],mybbVec[5*ibb+1+i]);
          }
          FOR_I4 assert(bbminmax_check[i] == bbminmax[i]);
        }
        */
                
        // now decide how to split the leafdata...
        int count[4];
        int split[2];
        //int iter = 0;
        while (1) {
          
          FOR_I2 split[i] = bbminmax[i] - (bbminmax[i]+bbminmax[i+2])/2;
          
          FOR_I4 count[i] = 0;
          for (int ibb = ibb_f; ibb <= ibb_l; ++ibb) {
            FOR_I2 {
              if (mybbVec[5*ibb+1+i] < split[i]) 
                //if (buf_int[2*ibb+i] < split[i]) 
                ++count[i];
              else if (mybbVec[5*ibb+1+i] == split[i])
                //else if (buf_int[2*ibb+i] == split[i])
                ++count[i+2];
            }
          }
          
          /*
          ++iter;
          if (mpi_rank == 0) {
            //if (debug) {
            cout << " bbminmax: 0: " << bbminmax[0] << ":" << -bbminmax[2] << 
              " 1: " << bbminmax[1] << ":" << -bbminmax[3] << " split: " << split[0] << " " << split[1] << endl;
            cout << " DEBUG > " << iter << " got count[0]:  " << count[0] << " count[1]: " << count[1] << 
              " nbb/2: " << nbb_half << " nbb: " << nbb << " count[2]: " << count[2] << " count[3]: " << count[3] << endl;
          }
          MPI_Pause("OKOK");
          */

          if ((count[0] <= nbb_half)&&(count[0]+count[2] >= nbb_half)&&(count[1] <= nbb_half)&&(count[1]+count[3] >= nbb_half))
            break;
          
          FOR_I2 {
            if (count[i] < nbb_half) {
              bbminmax[i] = split[i];
            }
            else {
              bbminmax[i+2] = -split[i];
            }
          }
          
        }
        
        int child_bbminmax[4][4];
        FOR_I4 FOR_J4 child_bbminmax[i][j] = TWO_BILLION; // max's are negative
        int equal_count[2] = { 0, 0 };
        for (int ibb = ibb_f; ibb <= ibb_l; ++ibb) {
          FOR_I2 {
            if (mybbVec[5*ibb+1+i] < split[i]) {
              // left 
              FOR_J4 child_bbminmax[2*i][j] = min(child_bbminmax[2*i][j],mybbVec[5*ibb+1+j]);
            }
            else if ((mybbVec[5*ibb+1+i] == split[i])&&(count[i]+equal_count[i] < nbb_half)) {
              // left (matching)...
              ++equal_count[i];
              FOR_J4 child_bbminmax[2*i][j] = min(child_bbminmax[2*i][j],mybbVec[5*ibb+1+j]);
            }
            else {
              // right (may be matching)...
              FOR_J4 child_bbminmax[2*i+1][j] = min(child_bbminmax[2*i+1][j],mybbVec[5*ibb+1+j]);
            }
          }
        }
        FOR_I2 assert(count[i]+equal_count[i] == nbb_half);
        
        int8 area[2];
        FOR_I2 {
          const int8 area0 = 
            int8(child_bbminmax[2*i][0]  +child_bbminmax[2*i][2])*
            int8(child_bbminmax[2*i][1]  +child_bbminmax[2*i][3]);
          const int8 area1 = 
            int8(child_bbminmax[2*i+1][0]+child_bbminmax[2*i+1][2])*
            int8(child_bbminmax[2*i+1][1]+child_bbminmax[2*i+1][3]);
          area[i] = area0 + area1;
        }
        
        // choose a direction for splitting based on minimizing the 
        // child area...
        
        int id = 0;
        if (area[1] < area[0])
          id = 1;
        
        int nbb_left = 0;
        int nbb_right = 0;
        int equal_count_id = 0;
        for (int ibb = ibb_f; ibb <= ibb_l; ++ibb) {
          if (mybbVec[5*ibb+1+id] < split[id]) {
            // left...
            FOR_I5 mybbVec[5*(ibb_f+nbb_left)+i] = mybbVec[5*ibb+i];
            ++nbb_left;
          }
          else if ((mybbVec[5*ibb+1+id] == split[id])&&(count[id]+equal_count_id < nbb_half)) {
            // left (matching)...
            ++equal_count_id;
            FOR_I5 mybbVec[5*(ibb_f+nbb_left)+i] = mybbVec[5*ibb+i];
            ++nbb_left;
          }
          else {
            // this is a right...
            FOR_I5 buf_int[5*nbb_right+i] = mybbVec[5*ibb+i];
            ++nbb_right;
          }
        }
        assert(nbb_left == nbb_half);
        assert(nbb_right == nbb - nbb_half);

        // now copy the right values back into the right part of mybbVec...
        for (int ibb = 0; ibb < nbb_right; ++ibb) {
          FOR_I5 mybbVec[5*(ibb_f+nbb_left+ibb)+i] = buf_int[5*ibb+i];
        }
        
        // if the left and/or right contains 1 entry, then we terminate, otherwise
        // put another leaf on the stack...
        
        leafdata[2*ileaf+1][0] = child_bbminmax[2*id][0]; // jmin
        leafdata[2*ileaf+1][1] = child_bbminmax[2*id][1]; // kmin
        leafdata[2*ileaf+1][2] = -child_bbminmax[2*id][2]; assert(leafdata[2*ileaf+1][2] >= leafdata[2*ileaf+1][0]); // jmax
        leafdata[2*ileaf+1][3] = -child_bbminmax[2*id][3]; assert(leafdata[2*ileaf+1][3] >= leafdata[2*ileaf+1][1]); // kmax
        
        if (nbb_left == 1) {
          // this is the terminal leaf...
          leafdata[2*ileaf+1][4] = leafdata[2*ileaf+1][5] = mybbVec[5*ibb_f]; // index
        }
        else {
          // put the leaf on the stack...
          assert(nbb_left > 1);
          leafdata[2*ileaf+1][4] = ibb_f;
          leafdata[2*ileaf+1][5] = ibb_f + nbb_left - 1;
          stack[istack++] = 2*ileaf+1;
        }
        
        leafdata[2*ileaf+2][0] = child_bbminmax[2*id+1][0]; // jmin
        leafdata[2*ileaf+2][1] = child_bbminmax[2*id+1][1]; // kmin
        leafdata[2*ileaf+2][2] = -child_bbminmax[2*id+1][2]; assert(leafdata[2*ileaf+2][2] >= leafdata[2*ileaf+2][0]); // jmax
        leafdata[2*ileaf+2][3] = -child_bbminmax[2*id+1][3]; assert(leafdata[2*ileaf+2][3] >= leafdata[2*ileaf+2][1]); // kmax
        
        if (nbb_right == 1) {
          // this is the terminal leaf...
          leafdata[2*ileaf+2][4] = leafdata[2*ileaf+2][5] = mybbVec[5*ibb_l]; // index
        }
        else {
          // put the leaf on the stack...
          assert(nbb_right > 1);
          leafdata[2*ileaf+2][4] = ibb_f + nbb_left;
          leafdata[2*ileaf+2][5] = ibb_l;
          stack[istack++] = 2*ileaf+2;
        }
        
      }
      
      delete[] buf_int;
      
      if (mpi_rank == 0) cout << "HOW WAS THAT??????????: " << MPI_Wtime() - wtime << endl;
     






      /*
      if (hcp_packing == HCP_PACKING_ONE) {
        hcp_x0[0] += 0.25*hcp_delta;
        hcp_x0[1] += 0.25*hcp_delta;
        hcp_x0[2] += 0.25*hcp_delta;
      }
      else if (hcp_packing == HCP_PACKING_ROOT2) {
        hcp_x0[0] += 0.25*hcp_delta;
        hcp_x0[1] += 0.25*sqrt(2.0)*hcp_delta;
        hcp_x0[2] += 0.25*sqrt(2.0)*hcp_delta;
      }
      else if (hcp_packing == HCP_PACKING_ROOT3) {
        hcp_x0[0] += 0.25*hcp_delta;
        hcp_x0[1] += 0.25*sqrt(3.0)*hcp_delta;
        hcp_x0[2] += 0.25*sqrt(3.0)*hcp_delta;
      }
      */


  /*
    int& getSpose(const int ise,const int i) {
    assert( (ise >= 0) && ( ((nse_new == -1)&&(ise < nse)) || ((nse_new > 0)&&(ise < nse+nse_new)) ) );
    assert((i >= 0)&&(i < 2));
    if (ise < nse) {
    return( spose[ise][i] );
    }
    else {
    return( spose_new[ise-nse][i] );
    }
    }

    int getSpose(const int ise,const int i) const {
    assert( (ise >= 0) && ( ((nse_new == -1)&&(ise < nse)) || ((nse_new > 0)&&(ise < nse+nse_new)) ) );
    assert((i >= 0)&&(i < 2));
    if (ise < nse) {
    return( spose[ise][i] );
    }
    else {
    return( spose_new[ise-nse][i] );
    }
    }

    int& getStose(const int ise,const int i) {
    assert( (ise >= 0) && ( ((nse_new == -1)&&(ise < nse)) || ((nse_new > 0)&&(ise < nse+nse_new)) ) );
    assert((i >= 0)&&(i < 2));
    if (ise < nse) {
    return( stose[ise][i] );
    }
    else {
    return( stose_new[ise-nse][i] );
    }
    }

    int getStose(const int ise,const int i) const {
    assert( (ise >= 0) && ( ((nse_new == -1)&&(ise < nse)) || ((nse_new > 0)&&(ise < nse+nse_new)) ) );
    assert((i >= 0)&&(i < 2));
    if (ise < nse) {
    return( stose[ise][i] );
    }
    else {
    return( stose_new[ise-nse][i] );
    }
    }

    int& getSpost(const int ist,const int i) {
    assert( (ist >= 0) && ( ((nst_new == -1)&&(ist < nst)) || ((nst_new > 0)&&(ist < nst+nst_new)) ) );
    assert((i >= 0)&&(i < 3));
    if (ist < nst) {
    return( spost[ist][i] );
    }
    else {
    return( spost_new[ist-nst][i] );
    }
    }

    int getSpost(const int ist,const int i) const {
    assert( (ist >= 0) && ( ((nst_new == -1)&&(ist < nst)) || ((nst_new > 0)&&(ist < nst+nst_new)) ) );
    assert((i >= 0)&&(i < 3));
    if (ist < nst) {
    return( spost[ist][i] );
    }
    else {
    return( spost_new[ist-nst][i] );
    }
    }

    int& getSeost(const int ist,const int i) {
    assert( (ist >= 0) && ( ((nst_new == -1)&&(ist < nst)) || ((nst_new > 0)&&(ist < nst+nst_new)) ) );
    assert((i >= 0)&&(i < 3));
    if (ist < nst) {
    return( seost[ist][i] );
    }
    else {
    return( seost_new[ist-nst][i] );
    }
    }

    int getSeost(const int ist,const int i) const {
    assert( (ist >= 0) && ( ((nst_new == -1)&&(ist < nst)) || ((nst_new > 0)&&(ist < nst+nst_new)) ) );
    assert((i >= 0)&&(i < 3));
    if (ist < nst) {
    return( seost[ist][i] );
    }
    else {
    return( seost_new[ist-nst][i] );
    }
    }

    int& getZnost(const int ist) {
    assert( (ist >= 0) && ( ((nst_new == -1)&&(ist < nst)) || ((nst_new > 0)&&(ist < nst+nst_new)) ) );
    if (ist < nst) {
    return( znost[ist] );
    }
    else {
    return( znost_new[ist-nst] );
    }
    }

    int getZnost(const int ist) const {
    assert( (ist >= 0) && ( ((nst_new == -1)&&(ist < nst)) || ((nst_new > 0)&&(ist < nst+nst_new)) ) );
    if (ist < nst) {
    return( znost[ist] );
    }
    else {
    return( znost_new[ist-nst] );
    }
    }

    int getNsp() const {
    if (nsp_new == -1)
    return(nsp);
    else
    return(nsp+nsp_new);
    }

    int getNse() const {
    if (nse_new == -1)
    return(nse);
    else
    return(nse+nse_new);
    }

    int getNst() const {
    if (nst_new == -1)
    return(nst);
    else
    return(nst+nst_new);
    }

    void checkMem() const {

    //cout << "checkMem()" << endl;

    for (int ist = 0; ist < getNst(); ++ist) {
    FOR_I3 {
    const int ise = getSeost(ist,i);
    if (getStose(ise,0) == ist) {
    assert( getSpost(ist,i) == getSpose(ise,0) );
    assert( getSpost(ist,(i+1)%3) == getSpose(ise,1) );
    }
    else {
    assert( getStose(ise,1) == ist );
    assert( getSpost(ist,i) == getSpose(ise,1) );
    assert( getSpost(ist,(i+1)%3) == getSpose(ise,0) );
    }
    }
    }

    //cout << "OKOK" << endl;

    }

    void combineMemCollective() {

    assert(status == SHM_SURFACE);

    // edge stuff is only on rank0 anyways, so no specific use of shared memory...
    // here we just

    if (mpi_rank_shared == 0) {

    if (nse_new > 0) {

    int (*spose_)[2] = new int[nse+nse_new][2];
    FOR_ISE FOR_I2 spose_[ise][i] = spose[ise][i];
    for (int ise = 0; ise < nse_new; ++ise) FOR_I2 spose_[nse+ise][i] = spose_new[ise][i];
    delete[] spose_new; spose_new = NULL;
    delete[] spose; spose = spose_;

    int (*stose_)[2] = new int[nse+nse_new][2];
    FOR_ISE FOR_I2 stose_[ise][i] = stose[ise][i];
    for (int ise = 0; ise < nse_new; ++ise) FOR_I2 stose_[nse+ise][i] = stose_new[ise][i];
    delete[] stose_new; stose_new = NULL;
    delete[] stose; stose = stose_;

    nse += nse_new;
    nse_new = -1;

    }

    if (nst_new > 0) {

    int (*seost_)[3] = new int[nst+nst_new][3];
    FOR_IST FOR_I3 seost_[ist][i] = seost[ist][i];
    for (int ist = 0; ist < nst_new; ++ist) FOR_I3 seost_[nst+ist][i] = seost_new[ist][i];
    delete[] seost_new; seost_new = NULL;
    delete[] seost; seost = seost_;

    // nst and nst_new get reset to -1 below...

    }

    }

    // for the shared memory part,

    int count[2];
    if (mpi_rank_shared == 0) {
    count[0] = nsp_new;
    count[1] = nst_new;
    }
    MPI_Bcast(count,2,MPI_INT,0,mpi_comm_shared);

    // nsp...

    if (count[0] > 0) {

    // pbi...

    uint * pbi_ = NULL; MpiStuff::CTI_Mmap(pbi_,nsp+count[0]);

    if (mpi_rank_shared == 0) {
    FOR_ISP pbi_[isp] = pbi[isp];
    for (int isp = 0; isp < nsp_new; ++isp) pbi_[nsp+isp] = pbi_new[isp];
    delete[] pbi_new; pbi_new = NULL;
    }

    MpiStuff::CTI_Munmap(pbi,nsp);
    pbi = pbi_;

    // xp...

    double (*xp_)[3] = NULL; MpiStuff::CTI_Mmap(xp_,nsp+count[0]);

    if (mpi_rank_shared == 0) {
    FOR_ISP FOR_I3 xp_[isp][i] = xp[isp][i];
    for (int isp = 0; isp < nsp_new; ++isp) FOR_I3 xp_[nsp+isp][i] = xp_new[isp][i];
    delete[] xp_new; xp_new = NULL;
    // last one, so cleanup...
    nsp_new = -1;
    }
    else {
    assert(xp_new == NULL);
    assert(pbi_new == NULL);
    assert(nsp_new == -1);
    }

    MpiStuff::CTI_Munmap(xp,nsp);
    xp = xp_;

    nsp += count[0];

    }

    // nst...

    if (count[1] > 0) {

    // spost...

    int (*spost_)[3] = NULL; MpiStuff::CTI_Mmap(spost_,nst+count[1]);

    if (mpi_rank_shared == 0) {
    FOR_IST FOR_I3 spost_[ist][i] = spost[ist][i];
    for (int ist = 0; ist < nst_new; ++ist) FOR_I3 spost_[nst+ist][i] = spost_new[ist][i];
    delete[] spost_new; spost_new = NULL;
    }

    MpiStuff::CTI_Munmap(spost,nst);
    spost = spost_;

    // znost...

    int *znost_ = NULL;      MpiStuff::CTI_Mmap(znost_,nst+count[1]);

    if (mpi_rank_shared == 0) {
    FOR_IST znost_[ist] = znost[ist];
    for (int ist = 0; ist < nst_new; ++ist) znost_[nst+ist] = znost_new[ist];
    delete[] znost_new; znost_new = NULL;
    // on the last one, reset nst_new...
    nst_new = -1;
    }

    MpiStuff::CTI_Munmap(znost,nst);
    znost = znost_;

    nst += count[1];

    }

    // make sure everyone has their mem stuff cleared...

    assert(nse_new == -1);
    assert(nsp_new == -1);
    assert(nst_new == -1);
    assert(xp_new == NULL);
    assert(pbi_new == NULL);
    assert(spose_new == NULL);
    assert(stose_new == NULL);
    assert(spost_new == NULL);
    assert(znost_new == NULL);
    assert(seost_new == NULL);

    }
  */

  // ===========================================================================================
  // end of memory management routines...
  // ===========================================================================================








// old injection stuff

      /*
	if ((cvd.ned == 0) && (nbrVec.size() >= 14)) {
	const double d2 = nbrVec[0].first;;
        cout << "delta2 d2: " << delta*delta << " " << d2 << endl;
	for (int ii = 0; ii < 14; ++ii) {
	cout << std::setprecision(15) << "ii: " << ii << " (nbrVec[ii].first)/d2: " << nbrVec[ii].first/d2 << " = " << 1.0 << "," << 1.5 << " or " << 4/3 << "?" << endl;
        }
	//for (int ii = 0; ii < nbrVec.size(); ++ii) {
	//  irecv_double = nbrVec[ii].second.second;
	//  double dn[3]; FOR_I3 dn[i] = recv_buf_double[irecv_double+i] - xp[i];
	//  cout << " > ii: " << ii << " dist: " << sqrt(nbrVec[ii].first) << " pos: " << COUT_VEC(dn) << endl;
	//}
	//getchar();
	}
      */
      
      // at this point, we may have zero elements in the cvd because there were 
      // none to start with, OR they were all cut away...
      
      // assume we are not special....
      bool one = false;
      bool root2 = false;
      bool root3 = false; 
      if (cvd.ned == 0) {
        const double d2 = nbrVec[0].first;
        // check last pt to see if we are looking for a root2 or root3 or one case
        const double four_thirds = 4.0/3.0;
        const double d2_rel_tol = 1.0E-12;
        // for one the scaled dist^2 for the 12th point is 1.0
        if ( (nbrVec.size() >= 12) && (fabs(nbrVec[11].first/d2 - 1.0) <= d2_rel_tol) ) {
          one = true;
        }
        // for root3 the scaled dist^2 for the 14th point is 1.5 
        else if ( (nbrVec.size() >= 14) && (fabs(nbrVec[13].first/d2 - 1.5) <= d2_rel_tol) ) {
          root3 = true;
        }
        // for root2 the scaled dist^2 for the 14th point is 4/3
        else if ( (nbrVec.size() >= 14) && (fabs(nbrVec[13].first/d2 - four_thirds) <= d2_rel_tol) ) {
          root2 = true;
        }
        // check other pts to see if we are still a root2/root3 truncated octahedron or a rhombic dodecahedron
        if (one) {
          for (int ii = 1; ii < 11; ++ii) {
            if (fabs(nbrVec[ii].first/d2 - 1.0) > d2_rel_tol) {
              one = false;
              break;
            }
          }
        }
        else if (root3) {
          for (int ii = 1; ii < 10; ++ii) {
            if (fabs(nbrVec[ii].first/d2 - 1.0) > d2_rel_tol) {
              root3 = false;
              break;
            }
          }
          if (root3) {
            for (int ii = 10; ii < 13; ++ii) {
              if (fabs(nbrVec[ii].first/d2 - 1.5) > d2_rel_tol) {
                root3 = false;
                break;
              }
            }
          }
        }
        else if (root2) {
          for (int ii = 1; ii < 8; ++ii) {
            if (fabs(nbrVec[ii].first/d2 - 1.0) > d2_rel_tol) {
              root2 = false;
              break;
            }
          }
          if (root2) {
            for (int ii = 8; ii < 13; ++ii) {
              if (fabs(nbrVec[ii].first/d2 - four_thirds) > d2_rel_tol) {
                root2 = false;
                break;
              }
            }
          }
        }
      }
      // TRY to add truncated octahedron/ rhombic dodecahedron
      // can still back out if the geometry isn't sound
      if (one || root3 || root2) {
        ++my_count[4]; 
        // the length is scaled by 1/2 the min distance b/w vd and nbrs
        if (one) {
          const double L = sqrt(2.0*nbrVec[0].first);
          cvd.addRhombicDodecahedron(L);

          // calc face midpoints
          double x_fa[12][3]; 
          int count_fa[12]; // also used to hold -8 infexed faces/ flag
          for (int ifa = 0; ifa < 12; ++ifa) {
            FOR_I3 x_fa[ifa][i] = 0.0;
            count_fa[ifa] = 0;
          }
          for (int ied = 0; ied < cvd.ned; ++ied) {
            FOR_I2 {
              const int ifa = -cvd.faoed[ied][i]-8;
              FOR_J2 {
                const int ino = cvd.nooed[ied][j];
                FOR_K3 x_fa[ifa][k] += cvd.x_no[ino][k];
                count_fa[ifa] += 1;
              }
            }
          }
          for (int ifa = 0; ifa < 12; ++ifa) {
            FOR_I3 x_fa[ifa][i] /= double(count_fa[ifa]);
          }

          // figure out if the midpoint associated with the first 12 nbrs matches one of these faces.
          // if ANY of the faces don't match with d2_tol, then back out of the insertion and start with 
          // a cube again.
             
          // rhombi...
          for (int ii = 0; ii < 12; ++ii) {
            irecv_double = nbrVec[ii].second.second;
            double dx_fa[3]; FOR_I3 dx_fa[i] = 0.5*(recv_buf_double[irecv_double+i] - xp[i]);

            int ifa_closest = -1;
            double d2_closest;
            for (int ifa = 0; ifa < 12; ++ifa) if (count_fa[ifa] >= 0) {
	      const double d2 = DIST2(dx_fa,x_fa[ifa]);
	      if ((ifa_closest == -1)||(d2 < d2_closest)) {
		ifa_closest = ifa;
		d2_closest = d2;
	      }
	    }
            if (d2_closest > d2_tol*nbrVec[0].first) {
              one = false; // can't confidentally insert rhombic dodecahedron
              //cout << xp[0]+1.00012*xp[1]+2.18391*xp[2] << " RESET " << xp[0] << " " << xp[1] << " " << xp[2] << endl; 
              break;
            }
            count_fa[ifa_closest] = -ii-8; // override with -8 indexed orig face info (flag as found)
          }

          // overwrite the face indices...
          if (one) {
            for (int ied = 0; ied < cvd.ned; ++ied) {
              FOR_I2 {
                const int ifa = -cvd.faoed[ied][i]-8;
                assert( (ifa >= 0) && (ifa < 12) );
                const int ifa_orig = count_fa[ifa];
                assert( (ifa_orig <= -8) && (ifa_orig > -20) ); // check that it has a match and is -8 indexed
                cvd.faoed[ied][i] = ifa_orig; 
              }
            }
          }
          // remove rhombic dodecahedron to prepare for addCube
          else {
            const int nno_orig = cvd.nno;
            cvd.resize_nno(nno_orig-14);
            const int ned_orig = cvd.ned;
            cvd.resize_ned(ned_orig-24);
          }
        }
        else if (root3) {
          const double L = sqrt(nbrVec[0].first);
          cvd.addTruncatedOctahedronRoot3(L);

          // calc face midpoints
          double x_fa[14][3]; 
          int count_fa[14]; // also used to hold -8 infexed faces/ flag
          for (int ifa = 0; ifa < 14; ++ifa) {
            FOR_I3 x_fa[ifa][i] = 0.0;
            count_fa[ifa] = 0;
          }
          for (int ied = 0; ied < cvd.ned; ++ied) {
            FOR_I2 {
              const int ifa = -cvd.faoed[ied][i]-8;
              FOR_J2 {
                const int ino = cvd.nooed[ied][j];
                FOR_K3 x_fa[ifa][k] += cvd.x_no[ino][k];
                count_fa[ifa] += 1;
              }
            }
          }
          for (int ifa = 0; ifa < 14; ++ifa) {
            FOR_I3 x_fa[ifa][i] /= double(count_fa[ifa]);
          }
          
          // figure out if the midpoint assocaited with the first 14 nbrs matches one of these faces.
          // if ANY of the faces don't match with d2_tol, then back out of the inertian and start with 
          // a cube again.
             
          // hex's...
          for (int ii = 0; ii < 10; ++ii) {
            irecv_double = nbrVec[ii].second.second;
            double dx_fa[3]; FOR_I3 dx_fa[i] = 0.5*(recv_buf_double[irecv_double+i] - xp[i]);

            int ifa_closest = -1;
            double d2_closest;
            for (int ifa = 0; ifa < 10; ++ifa) if (count_fa[ifa] >= 0) {
	      const double d2 = DIST2(dx_fa,x_fa[ifa]);
	      if ((ifa_closest == -1)||(d2 < d2_closest)) {
		ifa_closest = ifa;
		d2_closest = d2;
	      }
	    }
            if (d2_closest > d2_tol*nbrVec[0].first) {
              root3 = false; // can't confidentally insert trunc. oct.
              break;
            }
            count_fa[ifa_closest] = -ii-8; // override with -8 indexed orig face info (flag as found)
          }
          // quads...
          if (root3) {
            for (int ii = 10; ii < 14; ++ii) {
              irecv_double = nbrVec[ii].second.second;
              double dx_fa[3]; FOR_I3 dx_fa[i] = 0.5*(recv_buf_double[irecv_double+i] - xp[i]);

              int ifa_closest = -1;
              double d2_closest;
              for (int ifa = 10; ifa < 14; ++ifa) if (count_fa[ifa] >= 0) {
		const double d2 = DIST2(dx_fa,x_fa[ifa]);
		if ((ifa_closest == -1)||(d2 < d2_closest)) {
		  ifa_closest = ifa;
		  d2_closest = d2;
		}
	      }
              count_fa[ifa_closest] = -ii-8; // override with -8 indexed orig face info (flag as found)
              if (d2_closest > d2_tol*nbrVec[0].first) {
                root3 = false;
                break;
              }
            }
          }

          // overwrite the face indices...
          if (root3) {
            for (int ied = 0; ied < cvd.ned; ++ied) {
              FOR_I2 {
                const int ifa = -cvd.faoed[ied][i]-8;
                assert( (ifa >= 0) && (ifa < 14) );
                const int ifa_orig = count_fa[ifa];
                assert( (ifa_orig <= -8) && (ifa_orig > -22) ); // check that it has a match and is -8 indexed
                cvd.faoed[ied][i] = ifa_orig; 
              }
            }
          }
          // remove truncated octahedron to prepare for addCube
          else {
            const int nno_orig = cvd.nno;
            cvd.resize_nno(nno_orig-24);
            const int ned_orig = cvd.ned;
            cvd.resize_ned(ned_orig-36);
          }
	  
        }
        else { 
          assert(root2);
          const double L = sqrt(3.0*nbrVec[0].first)/1.5;
          cvd.addTruncatedOctahedronRoot2(L);

          // calc face midpoints
          double x_fa[14][3]; 
          int count_fa[14]; // also used to hold -8 infexed faces/ flag
          for (int ifa = 0; ifa < 14; ++ifa) {
            FOR_I3 x_fa[ifa][i] = 0.0;
            count_fa[ifa] = 0;
          }
          for (int ied = 0; ied < cvd.ned; ++ied) {
            FOR_I2 {
              const int ifa = -cvd.faoed[ied][i]-8;
              FOR_J2 {
                const int ino = cvd.nooed[ied][j];
                FOR_K3 x_fa[ifa][k] += cvd.x_no[ino][k];
                count_fa[ifa] += 1;
              }
            }
          }
          for (int ifa = 0; ifa < 14; ++ifa) {
            FOR_I3 x_fa[ifa][i] /= double(count_fa[ifa]);
          }

          // figure out if the midpoint assocaited with the first 14 nbrs matches one of these faces.
          // if ANY of the faces don't match with d2_tol, then back out of the inertian and start with 
          // a cube again.
             
          // hex's...
          for (int ii = 0; ii < 8; ++ii) {
            irecv_double = nbrVec[ii].second.second;
            double dx_fa[3]; FOR_I3 dx_fa[i] = 0.5*(recv_buf_double[irecv_double+i] - xp[i]);

            int ifa_closest = -1;
            double d2_closest;
            for (int ifa = 0; ifa < 8; ++ifa) if (count_fa[ifa] >= 0) {
	      const double d2 = DIST2(dx_fa,x_fa[ifa]);
	      if ((ifa_closest == -1)||(d2 < d2_closest)) {
		ifa_closest = ifa;
		d2_closest = d2;
	      }
	    }
            if (d2_closest > d2_tol*nbrVec[0].first) {
              root2 = false; // can't confidentally insert trunc. oct.
              break;
            }
            count_fa[ifa_closest] = -ii-8; // override with -8 indexed orig face info (flag as found)
          }
          // quads...
          if (root2) {
            for (int ii = 8; ii < 14; ++ii) {
              irecv_double = nbrVec[ii].second.second;
              double dx_fa[3]; FOR_I3 dx_fa[i] = 0.5*(recv_buf_double[irecv_double+i] - xp[i]);

              int ifa_closest = -1;
              double d2_closest;
              for (int ifa = 8; ifa < 14; ++ifa) if (count_fa[ifa] >= 0) {
		const double d2 = DIST2(dx_fa,x_fa[ifa]);
		if ((ifa_closest == -1)||(d2 < d2_closest)) {
		  ifa_closest = ifa;
		  d2_closest = d2;
		}
	      }
              count_fa[ifa_closest] = -ii-8; // override with -8 indexed orig face info (flag as found)
              if (d2_closest > d2_tol*nbrVec[0].first) {
                root2 = false;
                break;
              }
            }
          }

          // overwrite the face indices...
          if (root2) {
            for (int ied = 0; ied < cvd.ned; ++ied) {
              FOR_I2 {
                const int ifa = -cvd.faoed[ied][i]-8;
                assert( (ifa >= 0) && (ifa < 14) );
                const int ifa_orig = count_fa[ifa];
                assert( (ifa_orig <= -8) && (ifa_orig > -22) ); // check that it has a match and is -8 indexed
                cvd.faoed[ied][i] = ifa_orig; 
              }
            }
          }
          // remove truncated octahedron to prepare for addCube
          else {
            const int nno_orig = cvd.nno;
            cvd.resize_nno(nno_orig-24);
            const int ned_orig = cvd.ned;
            cvd.resize_ned(ned_orig-36);
          }
        }
      }
      int ii_start = 0;
      if (one || root3 || root2) {
        ++my_count[5]; 
        if (one) {
          ii_start = 12; // only need to chop off later nbrs
        }
        else {
          assert(root3 || root2);
          ii_start = 14; // only need to chop off later nbrs
        }
      }
      // if we are not a truncated octahedron or a rhombic dodecahedron, we need to add a cube...
// old periodic stuff

  void setPeriodicOrig() {

    COUT1("setPeriodicOrig()");

    // this new routine should be called AFTER the periodicData has been properly set.
    // It builds the pbi properly, even for multiple periodicity...

    // make sure there are some periodic transforms...

    int nperiodic = 0;
    for (int ii = 0; ii < 3; ++ii) {
      // pairs should be matched...
      assert(periodicData[2*ii+1].getType() == periodicData[2*ii].getType());
      if (periodicData[2*ii].getType() != SURFACE_PERIODIC_NULL)
      ++nperiodic;
    }

    switch (nperiodic) {
      case 1:
        COUT1(" > singly periodic");
        break;
      case 2:
        COUT1(" > doubly periodic");
        break;
      case 3:
        COUT1(" > triply periodic");
        break;
      case 4:
        assert(0);
    }

    // everything looks good -- there is some periodicity. Also check that zone bits are good...

    for (uint izone = 0; izone < zoneVec.size(); ++izone) {
      const int bi = zoneVec[izone].getBi();
      assert((bi >= -1)&&(bi < 6));
      if (bi >= 0) {
        // this one is periodic...
        assert(periodicData[bi].getType() != SURFACE_PERIODIC_NULL);
      }
    }

    // now set the bits in all nodes, with the 6th bit representing a valid zone...

    assert(status == SHM_SURFACE);
    if (pbi == NULL) initPbi();

    int ierr = 0;
    if (mpi_rank_shared == 0) {

      FOR_ISP pbi[isp] = 0;

      FOR_IST {
        if (znost[ist] >= 0) {
          const int bi = zoneVec[znost[ist]].getBi();
          assert((bi >= -1)&&(bi < 6));
          if (bi >= 0) {
            FOR_I3 {
              const int isp = spost[ist][i];
              pbi[isp] |= (1<<bi);
            }
          }
          else {
            FOR_I3 {
              const int isp = spost[ist][i];
              pbi[isp] |= (1<<6);
            }
          }
        }
      }

      // now go through pbi and count everything that is active and has any odd bit. These
      // are the nodes that are a copy of the node that is all even...

      int np_even = 0;
      FOR_ISP {
        if ((pbi[isp] & (1<<6)) && !(pbi[isp] & ((1<<1)|(1<<3)|(1<<5)))) {
          ++np_even;
        }
      }

      if (np_even == 0) {

        FOR_ISP {
          pbi[isp] = uint8(isp); // no bits
        }

      }
      else {

        double (*bbmin)[3] = new double[np_even][3];
        int8 *isp_of_even  = new int8[np_even];

        np_even = 0;
        FOR_ISP {
          if ((pbi[isp] & (1<<6)) && !(pbi[isp] & ((1<<1)|(1<<3)|(1<<5)))) {
            FOR_I3 bbmin[np_even][i] = xp[isp][i];
            isp_of_even[np_even] = isp;
            ++np_even;
          }
        }

        // also grab the smallest length scale nearby...

        double (*d2_even) = new double[nsp];
        FOR_ISP d2_even[isp] = 1.0E+20;

        FOR_IST {
          FOR_I3 {
            const int isp = spost[ist][i];
            if ((pbi[isp] & (1<<6)) && !(pbi[isp] & ((1<<1)|(1<<3)|(1<<5)))) {
              int isp_next = spost[ist][(i+1)%3];
              double d2 = DIST2(xp[isp],xp[isp_next]);
              isp_next = spost[ist][(i+2)%3];
              d2 = min(d2,DIST2(xp[isp],xp[isp_next]));
              assert(d2 > 0.0);
              d2_even[isp] = min(d2_even[isp],d2);
            }
          }
        }

        double (*bbmax)[3] = new double[np_even][3];
        for (int ip = 0; ip < np_even; ++ip) {
          assert( isp_of_even[ip] < TWO_BILLION);
          const int isp = isp_of_even[ip];
          assert(d2_even[isp] < 1.0E+20);
          const double delta = sqrt(d2_even[isp]);
          assert(delta > 0.0);
          FOR_I3 bbmax[ip][i] = bbmin[ip][i] + delta;
          FOR_I3 bbmin[ip][i] -= delta;
        }
        delete[] d2_even;

        Adt<double> * xpEvenAdt = new Adt<double>(np_even,bbmin,bbmax);
        delete[] bbmin;
        delete[] bbmax;

        // now go through and create pbi...

        double d2_max = 0.0;
        vector<int> candidateVec;
        FOR_ISP {
          if ((pbi[isp] & (1<<6)) && (pbi[isp] & ((1<<1)|(1<<3)|(1<<5)))) {
            double xp_t[3]; FOR_I3 xp_t[i] = xp[isp][i];
            // pbi stores the index and bits required to get to us -- i.e. the
            // even bits...
            int even_bits = 0;
            FOR_I3 {
              if (pbi[isp] & (1<<(2*i+1))) {
                even_bits |= (1<<(2*i));
                periodicData[2*i+1].translate(&xp_t,1);
              }
            }
            // find the closest match in xpEvenAdt...
            candidateVec.clear();
            xpEvenAdt->buildListForPoint(candidateVec,xp_t);
            if (candidateVec.empty()) {
              if (mpi_rank == 0)
              cout << "Error: no periodic match found for pt at: " << COUT_VEC(xp[isp]) << " translated to pt: " << COUT_VEC(xp_t) << endl;
              ierr = -1;
            }
            else {
              int8 isp_even_closest = -1;
              double d2_even_closest;
              for (uint ii = 0; ii < candidateVec.size(); ++ii) {
                const int ip = candidateVec[ii];
                const int8 isp_even = isp_of_even[ip];
                const double d2 = DIST2(xp_t,xp[isp_even]);
                if ((isp_even_closest == -1)||(d2 < d2_even_closest)) {
                  isp_even_closest = isp_even;
                  d2_even_closest = d2;
                }
              }
              assert(isp_even_closest >= 0);
              d2_max = max(d2_max,d2_even_closest);
              // correct the odd coordinate to be EXACTLY the value
              // translated from the even location...
              FOR_I3 xp_t[i] = xp[isp_even_closest][i];
              FOR_I3 {
                if (pbi[isp] & (1<<(2*i+1))) {
                  periodicData[2*i].translate(&xp_t,1);
                }
              }
              //cout << "compare original: " << COUT_VEC(xp[isp]) << " and translated: " << COUT_VEC(xp_t) << endl;
              FOR_I3 xp[isp][i] = xp_t[i];
              // and set pbi properly...
              pbi[isp] = BitUtils::makePbiHash(even_bits,isp_even_closest);
            }
          }
          else {
            pbi[isp] = uint8(isp); // no bits
          }
        }

        delete xpEvenAdt;
        delete[] isp_of_even;

        if (mpi_rank == 0)
        cout << " > nodes connected with tolerance (should be small): " << sqrt(d2_max) << endl;

      }

    }

    MPI_Bcast(&ierr,1,MPI_INT,0,mpi_comm_shared);
    if (ierr != 0) {
      if (checkParam("WRITE_SURFACE"))
      writeTecplot("debug_periodic.dat");
      throw(0);
    }

    if (mpi_rank_shared == 0) {

      double d2_max = 0.0;
      int count = 0;
      FOR_ISP {
        if (pbi[isp] != uint8(isp)) {
          int bits;
          int8 index;
          BitUtils::unpackPbiHash(bits,index,pbi[isp]);
          assert(bits);
          double xp_test[3]; FOR_I3 xp_test[i] = xp[index][i];
          periodicTranslate(&xp_test,1,bits);
          const double this_d2 = DIST2(xp_test,xp[isp]);
          d2_max = max(d2_max,this_d2);
          ++count;
        }
      }

      if (mpi_rank == 0)
      cout << " > snapped periodic node count: " << count << ", dist check (should be zero): " << sqrt(d2_max) << endl;

    }

  }

  class SplitEdgeData {
  public:
    int ied,ino;
    double frac;
    SplitEdgeData(const int ied,const double frac) {
      // the edge match version of SplitEdgeData...
      this->ied = ied;
      this->frac = frac;
      this->ino = -1;
    }
    bool operator<(const SplitEdgeData& rhs) const { return ( (ied < rhs.ied) || ((ied == rhs.ied)&&(frac < rhs.frac)) ); }
  };

  void setPeriodic() {

    COUT1("setPeriodic()");

    // this new routine should be called AFTER the periodicData has been properly set.
    // It builds the pbi properly, even for multiple periodicity...

    // make sure there are some periodic transforms...

    int nperiodic = 0;
    for (int ii = 0; ii < 3; ++ii) {
      // pairs should be matched...
      assert(periodicData[2*ii+1].getType() == periodicData[2*ii].getType());
      if (periodicData[2*ii].getType() != SURFACE_PERIODIC_NULL)
      ++nperiodic;
    }

    switch (nperiodic) {
      case 1:
        COUT1(" > singly periodic");
        break;
      case 2:
        COUT1(" > doubly periodic");
        setPeriodicOrig();
        return;
      case 3:
        COUT1(" > triply periodic");
        setPeriodicOrig();
        return;
      case 4:
        assert(0);
    }

    // everything looks good -- there is some periodicity. Also check that zone bits are good...

    for (uint izone = 0; izone < zoneVec.size(); ++izone) {
      const int bi = zoneVec[izone].getBi();
      assert((bi >= -1)&&(bi < 6));
      if (bi >= 0) {
        // this one is periodic...
        assert(periodicData[bi].getType() != SURFACE_PERIODIC_NULL);
      }
    }

    // in the future, we want to use this routine as a way to reconnect internal zones as well...

    int ierr = 0;
    double (*xp_copy)[3] = NULL;
    int (*spost_copy)[3] = NULL;
    int (*znost_copy)     = NULL;
    vector<SplitEdgeData> splitEdgeDataVec;
    unsigned char *sp_bits = NULL;

    if (mpi_rank_shared == 0) {

      // we need the edge connectivity structures...
      assert(stose);
      assert(spose);
      if (se_flag == NULL) se_flag = new int[nse];

      int nbb = 0; // number of edge bounding boxes required
      for (int ise = 0; ise < nse; ++ise) {
        se_flag[ise] = -1;
        // in the absense of a tri on one side or the other of this edge, we
        const int ist0 = stose[ise][0];
        int bi0 = -2;
        if ((ist0 >= 0)&&(znost[ist0] >= 0))
        bi0 = zoneVec[znost[ist0]].getBi();
        const int ist1 = stose[ise][1];
        int bi1 = -2;
        if ((ist1 >= 0)&&(znost[ist1] >= 0))
        bi1 = zoneVec[znost[ist1]].getBi();
        if (bi0 != bi1) {
          // bits differ -- several possibilities here...
          if ((bi0 == -1)&&(bi1 >= 0)) {
            se_flag[ise] = bi1;
            ++nbb;
          }
          else if ((bi1 == -1)&&(bi0 >= 0)) {
            se_flag[ise] = bi0;
            ++nbb;
          }
          else {
            cout << "bi0: " << bi0 << " bi1: " << bi1 << endl;
            assert(0);
          }
        }
        else {
          // bits are the same -- better not both be -2 -- this is a weird hanging edge
          assert(bi0 != -2);
          assert(bi1 != -2);
        }
      }

      sp_bits = new unsigned char[nsp];
      FOR_ISP sp_bits[isp] = 0;

      double (*bbmin)[3] = new double[nbb][3];
      double (*bbmax)[3] = new double[nbb][3];
      int * se_index = new int[nbb];
      double *d2_min = new double[nsp]; // for the edge length scale...

      int ibb = 0;
      for (int ise = 0; ise < nse; ++ise) {
        if (se_flag[ise] != -1) {
          const int ib = se_flag[ise];
          assert((ib >= 0)&&(ib < 6)); // should be a periodicData index...
          const int isp0 = spose[ise][0];
          const int isp1 = spose[ise][1];
          const double this_d2 = DIST2(xp[isp0],xp[isp1]);
          if (sp_bits[isp0] == 0) {
            d2_min[isp0] = this_d2;
            sp_bits[isp0] = (1<<ib);
          }
          else {
            d2_min[isp0] = min(d2_min[isp0],this_d2);
            sp_bits[isp0] |= (1<<ib);
          }
          if (sp_bits[isp1] == 0) {
            d2_min[isp1] = this_d2;
            sp_bits[isp1] = (1<<ib);
          }
          else {
            d2_min[isp1] = min(d2_min[isp1],this_d2);
            sp_bits[isp1] |= (1<<ib);
          }
          double x[6];
          FOR_I3 x[i  ] = xp[isp0][i];
          FOR_I3 x[i+3] = xp[isp1][i];
          periodicData[se_flag[ise]].translate(x,2);
          FOR_I3 bbmin[ibb][i] = min(x[i],x[i+3]);
          FOR_I3 bbmax[ibb][i] = max(x[i],x[i+3]);
          se_index[ibb] = ise;
          ++ibb;
        }
      }
      assert(ibb == nbb);

      // the largest possible tolerance is something like min edge length over 2.0001. This is
      // a global tol, but it avoids any ambiguity in node matches...
      // if the periodic tol is greater than the minimum edge length
      // along the periodic boundary, then there are potentially ambiguous nodes...

      const double tol_factor = 0.50;

      COUT1(" > number of edges around periodic boundaries: " << nbb);

      // now build the edge bbox adt...

      Adt<double> * edAdt = new Adt<double>(nbb,bbmin,bbmax);
      delete[] bbmin;
      delete[] bbmax;

      double periodic_tol = 1.0E-5; // ?? how to set this better?
      if (Param * param = getParam("PERIODIC_NODE_MATCH_TOL")) {
        if (param->size() == 1) periodic_tol = param->getDouble();
      }
      COUT2(" > edge fraction node-match tolerance: " << periodic_tol);
      
      // ok -- now find matches...

      if (sp_flag == NULL) sp_flag = new int[nsp];

      assert(ierr == 0);
      double d2_max = 0.0;
      vector<int> candidateVec;
      FOR_ISP {
        if (sp_bits[isp] != 0) {
          const double delta = tol_factor*sqrt(d2_min[isp]);
          const double this_bbmin[3] = { xp[isp][0]-delta, xp[isp][1]-delta, xp[isp][2]-delta };
          const double this_bbmax[3] = { xp[isp][0]+delta, xp[isp][1]+delta, xp[isp][2]+delta };
          candidateVec.clear();
          edAdt->buildListForBBox(candidateVec,this_bbmin,this_bbmax);
          int ise_closest = -1;
          double frac_closest;
          double d2_closest = delta*delta;
          for (uint ii = 0; ii < candidateVec.size(); ++ii) {
            const int ibb = candidateVec[ii];
            const int ise = se_index[ibb];
            assert(se_flag[ise] != -1);
            const int isp0 = spose[ise][0];
            const int isp1 = spose[ise][1];
            // look out for self-connections. This may be ok once we are using this routine to connect non-periodic zones...
            assert(isp != isp0);
            assert(isp != isp1);
            double x[6];
            FOR_I3 x[i  ] = xp[isp0][i];
            FOR_I3 x[i+3] = xp[isp1][i];
            periodicData[se_flag[ise]].translate(x,2);
            const double dx[3] = DIFF(x+3,x);
            const double dxp[3] = DIFF(xp[isp],x);
            const double dp = DOT_PRODUCT(dx,dxp);
            double this_d2;
            double this_frac;
            if (dp <= 0.0) {
              // we are closest to the first point v0. Note this includes the case when dx is zero, and/or dxp is zero...
              this_d2 = ( dxp[0]*dxp[0] + dxp[1]*dxp[1] + dxp[2]*dxp[2] );
              this_frac = 0.0; // the fraction along the edge
            }
            else {
              const double dx2 = DOT_PRODUCT(dx,dx);
              if (dp >= dx2) {
                // we are closest to the second point v1...
                this_d2 = ( (xp[isp][0]-x[3])*(xp[isp][0]-x[3]) + (xp[isp][1]-x[4])*(xp[isp][1]-x[4]) + (xp[isp][2]-x[5])*(xp[isp][2]-x[5]) );
                this_frac = 1.0;
              }
              else {
                this_d2 = ( dxp[0]*dxp[0] + dxp[1]*dxp[1] + dxp[2]*dxp[2] - dp*dp/dx2 );
                this_frac = dp/dx2;
                // this may still be an end-point connection. check if
                if (this_frac < 0.5) {
                  // we are closer to the first node...
                  const double d2_check = ( dxp[0]*dxp[0] + dxp[1]*dxp[1] + dxp[2]*dxp[2] );
                  if (d2_check < periodic_tol*periodic_tol) {
                    // go for node 0 instead...
                    this_frac = 0.0;
                  }
                }
                else {
                  const double d2_check = ( (xp[isp][0]-x[3])*(xp[isp][0]-x[3]) + (xp[isp][1]-x[4])*(xp[isp][1]-x[4]) + (xp[isp][2]-x[5])*(xp[isp][2]-x[5]) );
                  if (d2_check <= periodic_tol*periodic_tol) {
                    // go for node 1 instead...
                    this_frac = 1.0;
                  }
                }
                //if ((this_frac != 0.0)&&(this_frac != 1.0))
                //  cout << "XXXXXXXX: " << xp[isp][0] << " " << xp[isp][1] << " " << xp[isp][2] << endl;
              }
            }
            // now compare to other matches...
            if (this_d2 < d2_closest) {
              ise_closest  = ise;
              frac_closest = this_frac;
              d2_closest   = this_d2;
            }
          }
          // we should have got a match...
          if (ise_closest == -1) {
            --ierr;
            assert(sp_bits[isp] != 0);
            sp_flag[isp] = 0;
          }
          else {
            if (frac_closest == 0.0) {
              sp_flag[isp] = spose[ise_closest][0]+1; // add 1 to avoid using zero
            }
            else if (frac_closest == 1.0) {
              sp_flag[isp] = spose[ise_closest][1]+1; // add 1 to avoid using zero
            }
            else {
              splitEdgeDataVec.push_back(SplitEdgeData(ise_closest,frac_closest));
              sp_flag[isp] = -splitEdgeDataVec.size(); // negative indexing convention
            }
            assert(sp_flag[isp] != 0); // meaning has changed, but should still be non-zero
            d2_max = max(d2_max,d2_closest);
          }
        }
        else {
          assert(sp_bits[isp] == 0);
          sp_flag[isp] = 0;
        }
      }

      delete[] se_index;
      delete[] d2_min;
      delete edAdt;

      if (ierr < 0) {
        if (mpi_rank == 0)
        cout << " > Warning: some points have no match: " << -ierr << ". Check SET_PERIODIC details." << endl;
      }
      else {

        if (mpi_rank == 0)
        cout << " > periodic match (should be small): " << sqrt(d2_max) << endl;

        // now make sure all node matches are symmetric...

        ierr = 0;
        FOR_ISP {
          if (sp_flag[isp] > 0) {
            // a positive index is another isp...
            const int isp_nbr = sp_flag[isp]-1;
            ++ierr;
            if (sp_flag[isp_nbr]-1 != isp) {
              // this one is non-symmetric -- make sure it is an edge reference, then set it
              // to reference the node...
              assert(sp_flag[isp_nbr] < 0);
              const int ised = -sp_flag[isp_nbr]-1;
              assert(splitEdgeDataVec[ised].ino == -1);
              sp_flag[isp_nbr] = isp+1;
              // we may have skipped this one, so count it if we have...
              if (isp_nbr < isp)
              ++ierr;
            }
          }
        }

        if (mpi_rank == 0)
        cout << " > nodes that matched other nodes: " << ierr << endl;

        // we need to do this in 2 steps just in case some are changed by the above loop...

        // use the ierr to count
        ierr = 0;
        FOR_ISP {
          if (sp_flag[isp] < 0) {
            // a negative index references a split edge. We are about to sort
            // these so store the node in any that persist...
            const int ised = -sp_flag[isp]-1;
            assert(splitEdgeDataVec[ised].ino == -1);
            splitEdgeDataVec[ised].ino = isp;
            ++ierr;
          }
        }

        if (mpi_rank == 0)
        cout << " > nodes that matched edges only: " << ierr << endl;

        // if the count is greater than 0, then new nodes and tris are required...
        if (ierr > 0) {

          xp_copy = new double[nsp][3];
          memcpy(xp_copy,xp,sizeof(double)*nsp*3);

          spost_copy = new int[nst][3];
          memcpy(spost_copy,spost,sizeof(int)*nst*3);

          znost_copy = new int[nst];
          memcpy(znost_copy,znost,sizeof(int)*nst);

          // clear st_flag, and leave sp_flag -- it is expanded below...
          DELETE(st_flag);

        }

      }

    }

    MPI_Bcast(&ierr,1,MPI_INT,0,mpi_comm_shared);

    if (ierr < 0) {
      // we failed...
      throw(0);
    }

    if (ierr == 0) {

      assert(pbi == NULL);
      assert(wp == NULL);
      //assert(ipart_ist_of_st == NULL);

      MpiStuff::CTI_Mmap(pbi,nsp);

    }
    else {

      assert(ierr > 0);

      // positive ierr means that periodicity required the addition of "ierr" nodes and tris...
      MpiStuff::CTI_Munmap(spost,nst); spost = NULL;
      MpiStuff::CTI_Munmap(znost,nst); znost = NULL;
      MpiStuff::CTI_Munmap(xp,nsp);    xp = NULL;

      assert(wp == NULL);
      assert(ipart_ist_of_st == NULL);
      assert(pbi == NULL);

      nsp += ierr;
      nst += ierr;

      MpiStuff::CTI_Mmap(spost,nst);
      MpiStuff::CTI_Mmap(znost,nst);
      MpiStuff::CTI_Mmap(xp,nsp);
      MpiStuff::CTI_Mmap(pbi,nsp);

      if (mpi_rank_shared == 0) {

        sort(splitEdgeDataVec.begin(),splitEdgeDataVec.end());

        const int nsp_old = nsp-ierr;
        const int nst_old = nst-ierr;

        memcpy(xp,xp_copy,sizeof(double)*nsp_old*3);    delete[] xp_copy;    xp_copy = NULL;
        memcpy(spost,spost_copy,sizeof(int)*nst_old*3); delete[] spost_copy; spost_copy = NULL;
        memcpy(znost,znost_copy,sizeof(int)*nst_old);   delete[] znost_copy; znost_copy = NULL;

        {
          int *sp_flag_new = new int[nsp];
          memcpy(sp_flag_new,sp_flag,sizeof(int)*nsp_old);
          delete[] sp_flag; sp_flag = sp_flag_new;
        }

        {
          unsigned char *sp_bits_new = new unsigned char[nsp];
          memcpy(sp_bits_new,sp_bits,sizeof(unsigned char)*nsp_old);
          delete[] sp_bits; sp_bits = sp_bits_new;
        }

        // note that we do NOT split the periodic tris, we just split the
        // non-periodic ones and leave the periodic as is. This opens
        // gaps in the transition between peroidic and non-periodic zones,
        // but this should not matter...

        // NOTE: for double periodicity, this will not be robust, because
        // we are modifying the underlying tri. I think we can get around this by
        // having the original tri the one that contains the other edge with
        // periodicity set... Later.

        int nsp_new = nsp_old;
        int nst_new = nst_old;
        int ied_current = -1;
        int ino_opposite,stose_index,ist_orig;
        for (uint ised = 0; ised < splitEdgeDataVec.size(); ++ised) {
          // only consider those that have their ino set...
          if (splitEdgeDataVec[ised].ino >= 0) {
            if (splitEdgeDataVec[ised].ied != ied_current) {
              // we are about to switch the edge. Complete the last edge first...
              if (ied_current != -1) {
                //cout << "finish " << ied_current << "..." << endl;
                const int ist_new = nst_new++;
                if (stose_index == 0) {
                  spost[ist_new][0] = nsp_new-1;
                  spost[ist_new][1] = spose[ied_current][1];
                  spost[ist_new][2] = ino_opposite;
                }
                else {
                  assert(stose_index == 1);
                  spost[ist_new][0] = spose[ied_current][1];
                  spost[ist_new][1] = nsp_new-1;
                  spost[ist_new][2] = ino_opposite;
                }
                znost[ist_new] = znost[ist_orig];
              }
              ied_current = splitEdgeDataVec[ised].ied;
              const int isp_new = nsp_new++;
              assert((splitEdgeDataVec[ised].frac > 0.0)&&(splitEdgeDataVec[ised].frac < 1.0));
              FOR_I3 xp[isp_new][i] =
              splitEdgeDataVec[ised].frac*xp[spose[ied_current][1]][i] +
              (1.0-splitEdgeDataVec[ised].frac)*xp[spose[ied_current][0]][i];
              sp_flag[isp_new] = splitEdgeDataVec[ised].ino + 1;
              assert(sp_flag[splitEdgeDataVec[ised].ino] < 0);
              sp_flag[splitEdgeDataVec[ised].ino] = isp_new+1;
              // there should be just 1 common bit set in the original edge's nodes...
              sp_bits[isp_new] = ( sp_bits[spose[ied_current][0]] & sp_bits[spose[ied_current][1]] );
              assert((sp_bits[isp_new] == (1<<0))||
                     (sp_bits[isp_new] == (1<<1))||
                     (sp_bits[isp_new] == (1<<2))||
                     (sp_bits[isp_new] == (1<<3))||
                     (sp_bits[isp_new] == (1<<4))||
                     (sp_bits[isp_new] == (1<<5)));
              // do the startup...
              //cout << "start " << ied_current << "..." << endl;
              if ((stose[ied_current][0] >= 0)&&(znost[stose[ied_current][0]] >= 0)&&(zoneVec[znost[stose[ied_current][0]]].getBi() == -1)) {
                // stose[0] is the one on the boundary...
                stose_index = 0;
                ist_orig = stose[ied_current][0];
                if ((spost[ist_orig][0] == spose[ied_current][0])&&(spost[ist_orig][1] == spose[ied_current][1])) {
                  ino_opposite = spost[ist_orig][2];
                  assert(seost[ist_orig][0] == ied_current);
                  assert(se_flag[seost[ist_orig][0]] >= 0);
                  assert(se_flag[seost[ist_orig][1]] == -1);
                  assert(se_flag[seost[ist_orig][2]] == -1);
                  spost[ist_orig][1] = isp_new;
                }
                else if ((spost[ist_orig][1] == spose[ied_current][0])&&(spost[ist_orig][2] == spose[ied_current][1])) {
                  ino_opposite = spost[ist_orig][0];
                  assert(seost[ist_orig][1] == ied_current);
                  assert(se_flag[seost[ist_orig][0]] == -1);
                  assert(se_flag[seost[ist_orig][1]] >= 0);
                  assert(se_flag[seost[ist_orig][2]] == -1);
                  spost[ist_orig][2] = isp_new;
                }
                else {
                  assert((spost[ist_orig][2] == spose[ied_current][0])&&(spost[ist_orig][0] == spose[ied_current][1]));
                  ino_opposite = spost[ist_orig][1];
                  assert(seost[ist_orig][2] == ied_current);
                  assert(se_flag[seost[ist_orig][0]] == -1);
                  assert(se_flag[seost[ist_orig][1]] == -1);
                  assert(se_flag[seost[ist_orig][2]] >= 0);
                  spost[ist_orig][0] = isp_new;
                }
              }
              else {
                assert((stose[ied_current][1] >= 0)&&(znost[stose[ied_current][1]] >= 0)&&(zoneVec[znost[stose[ied_current][1]]].getBi() == -1));
                // stose[1] is the one on the boundary...
                stose_index = 1;
                ist_orig = stose[ied_current][1];
                if ((spost[ist_orig][0] == spose[ied_current][1])&&(spost[ist_orig][1] == spose[ied_current][0])) {
                  ino_opposite = spost[ist_orig][2];
                  assert(seost[ist_orig][0] == ied_current);
                  assert(se_flag[seost[ist_orig][0]] >= 0);
                  assert(se_flag[seost[ist_orig][1]] == -1);
                  assert(se_flag[seost[ist_orig][2]] == -1);
                  spost[ist_orig][0] = isp_new;
                }
                else if ((spost[ist_orig][1] == spose[ied_current][1])&&(spost[ist_orig][2] == spose[ied_current][0])) {
                  ino_opposite = spost[ist_orig][0];
                  assert(seost[ist_orig][1] == ied_current);
                  assert(se_flag[seost[ist_orig][0]] == -1);
                  assert(se_flag[seost[ist_orig][1]] >= 0);
                  assert(se_flag[seost[ist_orig][2]] == -1);
                  spost[ist_orig][1] = isp_new;
                }
                else {
                  assert((spost[ist_orig][2] == spose[ied_current][1])&&(spost[ist_orig][0] == spose[ied_current][0]));
                  ino_opposite = spost[ist_orig][1];
                  assert(seost[ist_orig][2] == ied_current);
                  assert(se_flag[seost[ist_orig][0]] == -1);
                  assert(se_flag[seost[ist_orig][1]] == -1);
                  assert(se_flag[seost[ist_orig][2]] >= 0);
                  spost[ist_orig][2] = isp_new;
                }
              }
            }
            else {
              const int isp_new = nsp_new++;
              assert((splitEdgeDataVec[ised].frac > 0.0)&&(splitEdgeDataVec[ised].frac < 1.0));
              FOR_I3 xp[isp_new][i] =
              splitEdgeDataVec[ised].frac*xp[spose[ied_current][1]][i] +
              (1.0-splitEdgeDataVec[ised].frac)*xp[spose[ied_current][0]][i];
              sp_flag[isp_new] = splitEdgeDataVec[ised].ino + 1;
              assert(sp_flag[splitEdgeDataVec[ised].ino] < 0);
              sp_flag[splitEdgeDataVec[ised].ino] = isp_new+1;
              sp_bits[isp_new] = ( sp_bits[spose[ied_current][0]] & sp_bits[spose[ied_current][1]] );
              assert((sp_bits[isp_new] == (1<<0))||
                     (sp_bits[isp_new] == (1<<1))||
                     (sp_bits[isp_new] == (1<<2))||
                     (sp_bits[isp_new] == (1<<3))||
                     (sp_bits[isp_new] == (1<<4))||
                     (sp_bits[isp_new] == (1<<5)));
              const int ist_new = nst_new++;
              if (stose_index == 0) {
                spost[ist_new][0] = isp_new-1;
                spost[ist_new][1] = isp_new;
                spost[ist_new][2] = ino_opposite;
              }
              else {
                assert(stose_index == 1);
                spost[ist_new][0] = isp_new;
                spost[ist_new][1] = isp_new-1;
                spost[ist_new][2] = ino_opposite;
              }
              znost[ist_new] = znost[ist_orig];
            }
          }
        }
        if (ied_current != -1) {
          //spost[ist_new][0] =
          //cout << "finish " << ied_current << "..." << endl;
          const int ist_new = nst_new++;
          if (stose_index == 0) {
            spost[ist_new][0] = nsp_new-1;
            spost[ist_new][1] = spose[ied_current][1];
            spost[ist_new][2] = ino_opposite;
          }
          else {
            assert(stose_index == 1);
            spost[ist_new][0] = spose[ied_current][1];
            spost[ist_new][1] = nsp_new-1;
            spost[ist_new][2] = ino_opposite;
          }
          znost[ist_new] = znost[ist_orig];
        }
        assert(nsp_new == nsp);
        assert(nst_new == nst);

        // also, the edge stuff is no longer valid, so clear it...

        clearEdgeStuff();

      }

    }

    // at this point, the sp_bits should contain the bits associated with nodes, and
    // the sp_flag contains a postitive nbr index in nodes that are periodic...

    if (mpi_rank_shared == 0) {

      // check that nodes reference each other in pairs, and set pbi...
      FOR_ISP {
        if (sp_flag[isp] > 0) {
          assert(sp_bits[isp] != 0);
          const int8 isp_nbr = sp_flag[isp]-1;
          assert(sp_flag[isp_nbr] == isp+1);
          assert(sp_bits[isp_nbr] != sp_bits[isp]);
          //cout << "xp[isp]    : " << COUT_VEC(xp[isp])     << " sp_bits[isp]    : " << int(sp_bits[isp]) << endl;
          //cout << "xp[isp_nbr]: " << COUT_VEC(xp[isp_nbr]) << " sp_bits[isp_nbr]: " << int(sp_bits[isp_nbr]) << endl;
          //getchar();
          if (sp_bits[isp] > sp_bits[isp_nbr]) {
            // ensure sp_bits is all even...
            assert((sp_bits[isp_nbr] == (1<<0))||
                   (sp_bits[isp_nbr] == (1<<2))||
                   (sp_bits[isp_nbr] == (1<<4)));
            assert(sp_bits[isp] = BitUtils::flipPeriodicBits(sp_bits[isp_nbr]));
            pbi[isp] = BitUtils::makePbiHash(sp_bits[isp_nbr],isp_nbr);
          }
          else {
            // we should be even...
            assert((sp_bits[isp] == (1<<0))||
                   (sp_bits[isp] == (1<<2))||
                   (sp_bits[isp] == (1<<4)));
            pbi[isp] = uint8(isp); // no bits
          }
        }
        else {
          assert(sp_flag[isp] == 0);
          assert(sp_bits[isp] == 0);
          pbi[isp] = uint8(isp); // no bits
        }
      }

      delete[] sp_bits;

      double d2_max = 0.0;
      int count = 0;
      FOR_ISP {
        if (pbi[isp] != uint8(isp)) {
          int bits;
          int8 index;
          BitUtils::unpackPbiHash(bits,index,pbi[isp]);
          assert(index != isp);
          assert(bits);
          double xp_test[3]; FOR_I3 xp_test[i] = xp[index][i];
          periodicTranslate(&xp_test,1,bits);
          const double this_d2 = DIST2(xp_test,xp[isp]);
          d2_max = max(d2_max,this_d2);
          FOR_I3 xp[isp][i] = xp_test[i];
          ++count;
        }
      }

      if (mpi_rank == 0)
      cout << " > final periodic node count: " << count << ", dist check (should be small): " << sqrt(d2_max) << endl;

    }
    MPI_Barrier(mpi_comm_shared);

    //check();

  }

#ifdef OLD_PERIODIC_FUNCTIONS

  void setPeriodic(const int bi0,const int bi1,const int periodic_type,const double data0,const double data1,const double data2) {

    // ===============================================
    // OLD version that assumes node-matching...
    // this is at the end of the next one, which includes a
    // tolerance in the call...
    // ===============================================

    // here we pass bi0 and bi1, which correspondes to the bit index set
    // in the passed zones...

    assert(status == SHM_SURFACE);
    if (pbi == NULL) initPbi();

    // find the relevant periodic pair...
    // we force the user to have specified bi0 and bi1 to indicate this...

    assert((bi0 == 0)||(bi0 == 2)||(bi0 == 4));
    assert(bi1 == bi0+1);
    assert(periodicData[bi0].getType() == SURFACE_PERIODIC_NULL);
    assert(periodicData[bi1].getType() == SURFACE_PERIODIC_NULL);
    if (bi0 > 0)
    assert(periodicData[bi0-1].getType() != SURFACE_PERIODIC_NULL);

    switch (periodic_type) {
      case SURFACE_PERIODIC_CYL_X:
      {
        // the passed data is the cos and sin of the angle...
        // data0 == cos_t...
        // data1 == sin_t...
        assert(data2 == 0.0);
        periodicData[bi0].setTypeAndData(SURFACE_PERIODIC_CYL_X,data0,data1,0.0);
        periodicData[bi1].setTypeAndData(SURFACE_PERIODIC_CYL_X,data0,-data1,0.0);
      }
        break;
      case SURFACE_PERIODIC_CART:
      {
        // passed data is the vector from 0 to 1...
        periodicData[bi0].setTypeAndData(SURFACE_PERIODIC_CART, data0, data1, data2);
        periodicData[bi1].setTypeAndData(SURFACE_PERIODIC_CART,-data0,-data1,-data2);
      }
        break;
      default:
        assert(0);
    }


    int ierr = 0;
    if (mpi_rank_shared == 0) {

      try {

        // now identify the relevant nodes...

        int * sp_flag = new int[nsp];
        FOR_ISP sp_flag[isp] = 0;
        FOR_IST {
          if ((znost[ist] >= 0)&&(zoneVec[znost[ist]].getBi() == bi0)) {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= 1; //(1<<0)
            }
          }
          else if ((znost[ist] >= 0)&&(zoneVec[znost[ist]].getBi() == bi1)) {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= (1<<1); // i.e. 2
            }
          }
          else {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= (1<<2); // i.e. 4
            }
          }
        }

        int count = 0;
        int count1 = 0;
        FOR_ISP {
          if (sp_flag[isp] == 5) { // i.e. 4+1
            // this is a node that is on the bit0+regular boundary: use negative convention for sp_flag,
            // saving space for -1 and -2
            sp_flag[isp] = -count-3;
            ++count;
          }
          else if (sp_flag[isp] == 6) { // i.e. 4+2
            // this is a node that is on the bit1+regular boundary: use positive convention for sp_flag,
            sp_flag[isp] = count1;
            ++count1;
          }
          else if (sp_flag[isp] == 4) {
            // this is a node that is on the regular boundary: keep...
            sp_flag[isp] = -2; // keep
          }
          else {
            // node should be entirely 1 or entirely 2...
            assert( (sp_flag[isp] == 1) || (sp_flag[isp] == 2) ); // 3 should never happen? no?
            sp_flag[isp] = -1; // discard
          }
        }

        if (mpi_rank == 0)
        cout << " > points on bi0: " << count << ", points on bi1: " << count1 << endl;
        if (count != count1) {
          CERR("Periodic point counts must match. Try adding\nPERIODIC_TOL=<value> to the PART or SRC paramater");
        }

        int * index0 = new int[count];
        int * index1 = new int[count];
        for (int ii = 0; ii < count; ++ii) {
          index0[ii] = -1;
          index1[ii] = -1;
        }

        double *d2_min = new double[count];

        FOR_IST {
          FOR_I3 {
            const int isp = spost[ist][i];
            if (sp_flag[isp] >= 0) {
              const int i1 = sp_flag[isp]; assert((i1 >= 0)&&(i1 < count));
              if (index1[i1] == -1) {
                index1[i1] = isp;
              }
              else {
                assert(index1[i1] == isp);
              }
            }
            else if (sp_flag[isp] <= -3) {
              const int i0 = -sp_flag[isp]-3; assert((i0 >= 0)&&(i0 < count));
              // compute the delta2 from connected edges...
              const int isp_next = spost[ist][(i+1)%3];
              const int isp_next_next = spost[ist][(i+2)%3];
              const double this_d2 = min(DIST2(xp[isp],xp[isp_next]),DIST2(xp[isp],xp[isp_next_next]));
              if (index0[i0] == -1) {
                index0[i0] = isp;
                d2_min[i0] = this_d2;
              }
              else {
                assert(index0[i0] == isp);
                d2_min[i0] = min(d2_min[i0],this_d2);
              }
            }
          }
        }

        // check...
        for (int ii = 0; ii < count; ++ii) {
          assert((index0[ii] >= 0)&&(index0[ii] < nsp));
          assert((index1[ii] >= 0)&&(index1[ii] < nsp));
        }

        // put the points on bit0 into an adt with bbox based on their
        // nearby edges computed above. Also collect the bit1 points
        // in a single array for transformation and comparison...

        double per_tol_factor = 0.4;
        if (checkParam("PERIODIC_TOL_FAC")) {
          FOR_PARAM_MATCHING("PERIODIC_TOL_FAC") {
            per_tol_factor = param->getDouble(0);
          }
        }
        if (mpi_rank == 0)
        cout << " > using periodic tolerance factor of " << per_tol_factor << endl;

        double (*bbmin)[3] = new double[count][3];
        double (*bbmax)[3] = new double[count][3];
        double (*xp_t)[3] = new double[count][3];
        for (int ii = 0; ii < count; ++ii) {
          // bbox for bit0 surface...
          {

            const int isp = index0[ii];
            const double delta = per_tol_factor*sqrt(d2_min[ii]);

            FOR_I3 bbmin[ii][i] = xp[isp][i]-delta;
            FOR_I3 bbmax[ii][i] = xp[isp][i]+delta;
          }
          // points from bit1 surface...
          {
            const int isp = index1[ii];
            FOR_I3 xp_t[ii][i] = xp[isp][i];
          }
        }
        delete[] d2_min; // not needed any more

        Adt<double> * xpAdt = new Adt<double>(count,bbmin,bbmax);
        delete[] bbmin;
        delete[] bbmax;

        // translate the bit1 points to bit0 points...

        periodicTranslate(xp_t,count,(1<<bi1));

        // now link the points...

        double d2_max = 0.0;
        for (int ii = 0; ii < count; ++ii) {
          vector<int> candidateVec;
          xpAdt->buildListForPoint(candidateVec,xp_t[ii]);
          switch(candidateVec.size()) {
            case 0:
              CWARN("no candidate found for translated point at: " << COUT_VEC(xp_t[ii]) );
              CWARN("Try using a larger TOL_FAC value (default is 0.4).");
              ierr = -1;
              break;
            case 1:
              if (index0[candidateVec[0]] < 0) {
                cout << "Error: candidate already found for translated point at: " << COUT_VEC(xp_t[ii]) << endl;
                ierr = -1;
              }
              else {
                const int isp = index0[candidateVec[0]];
                index0[candidateVec[0]] = -isp-1;
                sp_flag[index1[ii]] = isp; // put the connection in sp_flag...
                // record the max distance...
                d2_max = max(d2_max,DIST2(xp[isp],xp_t[ii]));
                // and flip the index...
              }
              break;
            default:
              // more than one candidate...one should be the closest by a significant distance.
              // Otherwise, the reconnection is ambiguous. Look out for -index...
              double d2_min = HUGE_VAL;
              int closest_isp;
              int candidate;
              double factor;
              bool bIspSet = false;
              for (int it=0, limit=candidateVec.size(); it < limit; it++) {
                const int cisp = index0[candidateVec[it]];
                if (cisp < 0) {
                  // candidate already found, ignore this point
                } else {
                  const double d2_min_tmp = DIST2(xp[cisp],xp_t[ii]);
                  if (d2_min_tmp < d2_min) {
                    factor = d2_min/d2_min_tmp;
                    d2_min = d2_min_tmp;
                    closest_isp = cisp;
                    candidate = candidateVec[it];
                    bIspSet = true;
                  }
                }
              }

              if (!bIspSet) {
                COUT1("Error: no unset candidates found for translated point at: " << COUT_VEC(xp_t[ii]));
                ierr = -1;
              } else {
                index0[candidate] = -closest_isp-1;
                sp_flag[index1[ii]] = closest_isp; // put the connection in sp_flag...
                // record the max distance...
                d2_max = max(d2_max,DIST2(xp[closest_isp],xp_t[ii]));
                if (factor < 1.05) {
                  COUT1("Warning: multiple equidistant candidates found for translated point at: "
                        << COUT_VEC(xp_t[ii]) << " (dist factor: " << factor << ")");
                }
              }
          }
        }

        delete xpAdt;
        delete[] xp_t;
        delete[] index0;

        COUT1(" > periodic points matched within dist (should be small): " << sqrt(d2_max));

        // the periodic connections ultimately get stored in the int array pbi (periodic bits-index)...
        // pbi has the following bits...
        // |b5|b4|b3|b2|b1|b0|---integer-index-bits---|

        assert(pbi != NULL);

        for (int ii = 0; ii < count; ++ii) {
          const int isp = index1[ii];
          int isp0 = sp_flag[isp];
          assert(isp != isp0);
          int bits = (1<<bi0);
          while (pbi[isp0] != uint(isp0))
          assert(0);
          pbi[isp] = BitUtils::makePbiHash(bits,isp0);
          // also correct the coordinate to be EXACTLY the tranlated value...
          FOR_I3 xp[isp][i] = xp[isp0][i];
          periodicTranslate(xp+isp,1,bits);
        }

        delete[] index1;
        delete[] sp_flag;

        // finally, check the correspondence of the periodicity...

        d2_max = 0.0;
        count1 = 0;
        FOR_ISP {
          if (pbi[isp] != uint(isp)) {
            int bits,index;
            BitUtils::unpackPbiHash(bits,index,pbi[isp]);
            assert(bits);
            double xp_test[3]; FOR_I3 xp_test[i] = xp[index][i];
            periodicTranslate(&xp_test,1,bits);
            const double this_d2 = DIST2(xp_test,xp[isp]);
            d2_max = max(d2_max,this_d2);
            ++count1;
          }
        }

        if (mpi_rank == 0)
        cout << " > final periodic node count: " << count1 << " dist check (should be small): " << sqrt(d2_max) << endl;

      }
      catch(...) {

        ierr = -1;

      }

    }

    // error...

    MPI_Bcast(&ierr,1,MPI_INT,0,mpi_comm_shared);
    if (ierr != 0)
    throw(0);

  }


  void setPeriodic(const int bi0,const int bi1,const int periodic_type,const double data0,const double data1,const double data2,const double tol) {

    // here we pass bi0 and bi1, which correspondes to the bit index set
    // in the passed zones...

    assert(status == SHM_SURFACE);
    if (pbi == NULL) initPbi();

    // find the relevant periodic pair...
    // we force the user to have specified bi0 and bi1 to indicate this...

    assert((bi0 == 0)||(bi0 == 2)||(bi0 == 4));
    assert(bi1 == bi0+1);
    assert(periodicData[bi0].getType() == SURFACE_PERIODIC_NULL);
    assert(periodicData[bi1].getType() == SURFACE_PERIODIC_NULL);

    // if this is not 0:1, make sure the user has set 0:1 already...

    if (bi0 > 0)
    assert(periodicData[bi0-1].getType() != SURFACE_PERIODIC_NULL);

    switch (periodic_type) {
      case SURFACE_PERIODIC_CYL_X:
        // the passed data is the cos and sin of the angle...
        // data0 == cos_t...
        // data1 == sin_t...
        assert(data2 == 0.0);
        periodicData[bi0].setTypeAndData(SURFACE_PERIODIC_CYL_X,data0,data1,0.0);
        periodicData[bi1].setTypeAndData(SURFACE_PERIODIC_CYL_X,data0,-data1,0.0);
        break;
      case SURFACE_PERIODIC_CART:
        // passed data is the vector from 0 to 1...
        periodicData[bi0].setTypeAndData(SURFACE_PERIODIC_CART, data0, data1, data2);
        periodicData[bi1].setTypeAndData(SURFACE_PERIODIC_CART,-data0,-data1,-data2);
        break;
      default:
        assert(0);
    }

    // ======================================================================
    // in this first part, we locate edges along the periodic boundaries and
    // introduce nodes by splitting triangles if required...
    // ======================================================================

    int ierr = 0;
    if (mpi_rank_shared == 0) {

      buildEdgeStuff(); // recall edge stuff is only rank0...

      FOR_ISE {
        se_flag[ise] = 0;
        const int ist0 = stose[ise][0]; assert((ist0 >= 0)&&(ist0 < nst));
        const int ist1 = stose[ise][1]; assert((ist1 >= 0)&&(ist1 < nst));
        if ((znost[ist0] >= 0)&&(znost[ist1] >= 0)) {
          if ( ((zoneVec[znost[ist0]].getBi() == bi0)&&(zoneVec[znost[ist1]].getBi() != bi0)) ||
              ((zoneVec[znost[ist0]].getBi() != bi0)&&(zoneVec[znost[ist1]].getBi() == bi0)) ) {
            se_flag[ise] |= (1<<0);
          }
          if ( ((zoneVec[znost[ist0]].getBi() == bi1)&&(zoneVec[znost[ist1]].getBi() != bi1)) ||
              ((zoneVec[znost[ist0]].getBi() != bi1)&&(zoneVec[znost[ist1]].getBi() == bi1)) ) {
            se_flag[ise] |= (1<<1);
          }
        }
      }

      int nse0 = 0;
      int nse1 = 0;
      FOR_ISE {
        if (se_flag[ise] == 1)
        ++nse0;
        else if (se_flag[ise] == 2)
        ++nse1;
        else if (se_flag[ise] == 3)
        assert(0);
      }

      // at this point, we have edges marked as...
      // se_flag = 0 -- nothing
      // se_flag = 1 -- edge on bi0
      // se_flag = 2 -- edge on bi1
      // se_flag = 3 -- edge on bi0 AND bi1 -- i.e. axial

      // here we allow the potential introduction of new nodes along edges that
      // connect periodicity within the tolerance...

      int * sp_flag = new int[nsp];
      FOR_ISP sp_flag[isp] = 0;
      double * sp_d2 = new double[nsp]; // stores the max edge length squared
      FOR_ISP sp_d2[isp] = 0.0;
      FOR_IST {
        if (znost[ist] >= 0) {
          if (zoneVec[znost[ist]].getBi() == bi0) {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= 1; //(1<<0)
            }
          }
          else if (zoneVec[znost[ist]].getBi() == bi1) {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= (1<<1); // i.e. 2
            }
          }
          else {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= (1<<2); // i.e. 4
            }
          }
        }
        // and set the sp_d2...
        FOR_I3 {
          const double d2 = DIST2(xp[spost[ist][i]],xp[spost[ist][(i+1)%3]]);
          sp_d2[spost[ist][i]]       = max(sp_d2[spost[ist][i]]      ,d2);
          sp_d2[spost[ist][(i+1)%3]] = max(sp_d2[spost[ist][(i+1)%3]],d2);
        }
      }

      int nsp0 = 0;
      int nsp1 = 0;
      FOR_ISP {
        if (sp_flag[isp] == 5) { // i.e. 4+1
          // this is a node that is on the bit0+regular boundary...
          ++nsp0;
        }
        else if (sp_flag[isp] == 6) { // i.e. 4+2
          // this is a node that is on the bit1+regular boundary...
          ++nsp1;
        }
      }

      //cout << "nsp0: " << nsp0 << " nsp1: " << nsp1 << endl;

      // step 1. Build an edge adt for bi1 and locate points on bi0 transformed to bi1...

      int * sp_index     = new int[max(nsp0,nsp1)];
      double (*xsp_t)[3] = new double[max(nsp0,nsp1)][3];
      {
        int isp0 = 0;
        FOR_ISP {
          if (sp_flag[isp] == 5) { // i.e. 4+1
            sp_index[isp0] = isp;
            FOR_I3 xsp_t[isp0][i] = xp[isp][i];
            ++isp0;
          }
        }
        assert(isp0 == nsp0);
      }

      periodicTranslate(xsp_t,nsp0,(1<<bi0));

      // and build an adt...

      int *se_index      = new int[max(nse0,nse1)];
      double (*bbmin)[3] = new double[max(nse0,nse1)][3];
      double (*bbmax)[3] = new double[max(nse0,nse1)][3];
      {
        int ise1 = 0;
        FOR_ISE {
          if (se_flag[ise] == 2) {
            se_index[ise1] = ise;
            const int isp0 = spose[ise][0];
            FOR_I3 bbmin[ise1][i] = xp[isp0][i];
            FOR_I3 bbmax[ise1][i] = xp[isp0][i];
            const int isp1 = spose[ise][1];
            FOR_I3 bbmin[ise1][i] = min(bbmin[ise1][i],xp[isp1][i]);
            FOR_I3 bbmax[ise1][i] = max(bbmax[ise1][i],xp[isp1][i]);
            ise1++;
          }
        }
        assert(ise1 == nse1);
      }

      int * se_matching = new int[max(nsp0,nsp1)];
      {

        Adt<double> edgeAdt(nse1,bbmin,bbmax);
        vector<int> seVec;

        double d2_max = 0.0;
        for (int isp0 = 0; isp0 < nsp0; ++isp0) {
          const int isp = sp_index[isp0];
          const double delta = 0.5*sqrt(sp_d2[isp]);
          // include the delta here...
          const double xp_bbmin[3] = { xsp_t[isp0][0] - delta, xsp_t[isp0][1] - delta, xsp_t[isp0][2] - delta };
          const double xp_bbmax[3] = { xsp_t[isp0][0] + delta, xsp_t[isp0][1] + delta, xsp_t[isp0][2] + delta };
          edgeAdt.buildListForBBox(seVec,xp_bbmin,xp_bbmax);
          if (seVec.empty()) {
            if (mpi_rank == 0)
            cout << "Error: No match for point: " << xsp_t[isp0][0] << " " << xsp_t[isp0][1] << " " << xsp_t[isp0][2] << endl;
            ierr = -1;
          }
          se_matching[isp0] = -1;
          double d2_closest;
          for (int ie = 0, ie_max=seVec.size(); ie < ie_max; ++ie) {
            const int ise1 = seVec[ie];
            const int ise = se_index[ise1];
            assert(se_flag[ise] == 2); // better be a 2-edge
            const double d2 = getPointToEdgeDist2(xsp_t[isp0],xp[spose[ise][0]],xp[spose[ise][1]]);
            if ((se_matching[isp0] == -1)||(d2 < d2_closest)) {
              se_matching[isp0] = ise1; // use the edge index in the list of edges...
              d2_closest = d2;
            }
          }
          if (se_matching[isp0] != -1)
          d2_max = max(d2_max,d2_closest);
        }

        if (mpi_rank == 0)
        cout << " > transformed bi0 points matched bi1 edges within tol: " << sqrt(d2_max) << endl;

      }

      // we now have se_matching set to an edge for every node...

      int * spose_i = new int[max(nse0,nse1)+1];
      for (int ise1 = 0; ise1 < nse1; ++ise1)
      spose_i[ise1+1] = 0;
      for (int isp0 = 0; isp0 < nsp0; ++isp0) {
        assert((se_matching[isp0] >= 0)&&(se_matching[isp0] < nse1));
        ++spose_i[se_matching[isp0]+1];
      }
      spose_i[0] = 0;
      for (int ise1 = 0; ise1 < nse1; ++ise1)
      spose_i[ise1+1] += spose_i[ise1];
      assert(spose_i[nse1] == nsp0);

      int * spose_v = new int[max(nsp0,nsp1)];
      for (int isp0 = 0; isp0 < nsp0; ++isp0) {
        spose_v[spose_i[se_matching[isp0]]] = isp0;
        ++spose_i[se_matching[isp0]];
      }

      for (int ise1 = nse1-1; ise1 > 0; --ise1)
      spose_i[ise1] = spose_i[ise1-1];
      spose_i[0] = 0;

      checkMem();

      // now do edges...

      for (int ise1 = 0; ise1 < nse1; ++ise1) {
        const int ise = se_index[ise1];
        vector<double> wpVec;
        for (int sos = spose_i[ise1]; sos != spose_i[ise1+1]; ++sos) {
          const int isp0 = spose_v[sos];
          const double dxsp[3] = DIFF(xsp_t[isp0],xp[spose[ise][0]]);
          const double dxp[3] = DIFF(xp[spose[ise][1]],xp[spose[ise][0]]);
          const double dp = DOT_PRODUCT(dxsp,dxp);
          const double dxp2 = dxp[0]*dxp[0] + dxp[1]*dxp[1] + dxp[2]*dxp[2];
          if ((dp > 0.0)&&(dp < dxp2)) {
            const double wp = dp/dxp2;
            if (min(wp,1.0-wp)*dxp2 > tol) {
              wpVec.push_back(wp);
            }
          }
        }
        if (!wpVec.empty()) {
          if (ierr == 0) ierr = 1;
          // note that here we use the "getX()" routines because they allow
          // for a temporary broken-memory model, which we will correct after
          // all mods are made with a call to combineMemCollective()...
          sort(wpVec.begin(),wpVec.end());
          // add the new points by breaking the existing edge...
          const int isp0_orig = spose[ise][0];
          const int isp1_orig = spose[ise][1];
          int ise_prev = ise;
          assert(getSpose(ise_prev,1) == isp1_orig);
          for (int ii = 0, ii_max=wpVec.size(); ii < ii_max; ++ii) {
            const double wp = wpVec[ii];
            const int isp_new = new_sp();
            FOR_I3 getXp(isp_new,i) = wp*xp[isp1_orig][i] + (1.0-wp)*xp[isp0_orig][i];
            getPbi(isp_new) = isp_new;
            assert(getSpose(ise_prev,1) == isp1_orig);
            getSpose(ise_prev,1) = isp_new;
            const int ise_new = new_se();
            getSpose(ise_new,0) = isp_new;
            getSpose(ise_new,1) = isp1_orig;
            // we also need a new edge splitting each of the tris associated with the
            // previous edge...
            {
              const int ist0 = getStose(ise_prev,0);
              if (ist0 == -1)
              getStose(ise_new,0) = -1;
              else {
                assert(ist0 >= 0);
                // look for ise_prev in ist0...
                int eot;
                for (eot = 0; eot < 3; ++eot)
                if (getSeost(ist0,eot) == ise_prev)
                break;
                assert(eot < 3); // make sure we found it...
                // note: the spost numbering convention for nodes of this edge is: eot and (eot+1)%3...
                assert(getSpost(ist0,(eot+1)%3) == isp1_orig);
                const int ist_new = new_st();
                const int ise_split_new = new_se();
                const int ied_orig = getSeost(ist0,(eot+1)%3);
                const int isp_opposite = getSpost(ist0,(eot+2)%3);
                // new edge...
                getStose(ise_new,0) = ist_new;
                // new tri...
                getSpost(ist_new,eot)       = isp_new;
                getSpost(ist_new,(eot+1)%3) = isp1_orig;
                getSpost(ist_new,(eot+2)%3) = isp_opposite;
                getSeost(ist_new,eot)       = ise_new;
                getSeost(ist_new,(eot+1)%3) = ied_orig;
                getSeost(ist_new,(eot+2)%3) = ise_split_new;
                getZnost(ist_new) = getZnost(ist0);
                // old tri...
                getSpost(ist0,(eot+1)%3) = isp_new;
                getSeost(ist0,(eot+1)%3) = ise_split_new;
                // original edge needs to point to the new tri...
                if (getStose(ied_orig,0) == ist0)
                getStose(ied_orig,0) = ist_new;
                else {
                  assert(getStose(ied_orig,1) == ist0);
                  getStose(ied_orig,1) = ist_new;
                }
                // new edge splitting tri...
                getSpose(ise_split_new,0) = isp_opposite;
                getSpose(ise_split_new,1) = isp_new;
                getStose(ise_split_new,0) = ist_new;
                getStose(ise_split_new,1) = ist0;
              }
            }
            {
              const int ist1 = getStose(ise_prev,1);
              if (ist1 == -1)
              getStose(ise_new,1) = -1;
              else {
                assert(ist1 >= 0);
                // look for ise_prev in ist1...
                int eot;
                for (eot = 0; eot < 3; ++eot)
                if (getSeost(ist1,eot) == ise_prev)
                break;
                assert(eot < 3); // make sure we found it...
                // note: the spost numbering convention for nodes of this edge is: eot and (eot+1)%3...
                assert(getSpost(ist1,eot) == isp1_orig);
                const int ist_new = new_st();
                const int ise_split_new = new_se();
                const int ied_orig = getSeost(ist1,(eot+2)%3);
                const int isp_opposite = getSpost(ist1,(eot+2)%3);
                // new edge...
                getStose(ise_new,1) = ist_new;
                // new tri...
                getSpost(ist_new,eot)       = isp1_orig;
                getSpost(ist_new,(eot+1)%3) = isp_new;
                getSpost(ist_new,(eot+2)%3) = isp_opposite;
                getSeost(ist_new,eot)       = ise_new;
                getSeost(ist_new,(eot+1)%3) = ise_split_new;
                getSeost(ist_new,(eot+2)%3) = ied_orig;
                getZnost(ist_new) = getZnost(ist1);
                // old tri...
                getSpost(ist1,eot) = isp_new;
                getSeost(ist1,(eot+2)%3) = ise_split_new;
                // original edge needs to point to the new tri...
                if (getStose(ied_orig,0) == ist1)
                getStose(ied_orig,0) = ist_new;
                else {
                  assert(getStose(ied_orig,1) == ist1);
                  getStose(ied_orig,1) = ist_new;
                }
                // new edge splitting tri...
                getSpose(ise_split_new,0) = isp_opposite;
                getSpose(ise_split_new,1) = isp_new;
                getStose(ise_split_new,1) = ist_new;
                getStose(ise_split_new,0) = ist1;
              }
            }
            ise_prev = ise_new;
          }
        }
      }

      checkMem();

      // now the other side...

      {
        int isp1 = 0;
        FOR_ISP {
          if (sp_flag[isp] == 6) { // i.e. 4+2
            sp_index[isp1] = isp;
            FOR_I3 xsp_t[isp1][i] = xp[isp][i];
            ++isp1;
          }
        }
        assert(isp1 == nsp1);
      }

      periodicTranslate(xsp_t,nsp1,(1<<bi1));

      // and build an adt...

      {
        int ise0 = 0;
        FOR_ISE {
          if (se_flag[ise] == 1) {
            se_index[ise0] = ise;
            const int isp0 = spose[ise][0];
            FOR_I3 bbmin[ise0][i] = xp[isp0][i];
            FOR_I3 bbmax[ise0][i] = xp[isp0][i];
            const int isp1 = spose[ise][1];
            FOR_I3 bbmin[ise0][i] = min(bbmin[ise0][i],xp[isp1][i]);
            FOR_I3 bbmax[ise0][i] = max(bbmax[ise0][i],xp[isp1][i]);
            ise0++;
          }
        }
        assert(ise0 == nse0);
      }

      {

        Adt<double> edgeAdt(nse0,bbmin,bbmax);
        delete[] bbmin;
        delete[] bbmax;

        vector<int> seVec;

        double d2_max = 0.0;
        for (int isp1 = 0; isp1 < nsp1; ++isp1) {
          const int isp = sp_index[isp1];
          const double delta = 0.5*sqrt(sp_d2[isp]);
          // include the delta here...
          const double xp_bbmin[3] = { xsp_t[isp1][0] - delta, xsp_t[isp1][1] - delta, xsp_t[isp1][2] - delta };
          const double xp_bbmax[3] = { xsp_t[isp1][0] + delta, xsp_t[isp1][1] + delta, xsp_t[isp1][2] + delta };
          edgeAdt.buildListForBBox(seVec,xp_bbmin,xp_bbmax);
          if (seVec.empty()) {
            if (mpi_rank == 0)
            cout << "Error: No match for point: " << xsp_t[isp1][0] << " " << xsp_t[isp1][1] << " " << xsp_t[isp1][2] << endl;
            ierr = -1;
          }
          se_matching[isp1] = -1;
          double d2_closest;
          for (int ie = 0, ie_max=seVec.size(); ie < ie_max; ++ie) {
            const int ise0 = seVec[ie];
            const int ise = se_index[ise0];
            assert(se_flag[ise] == 1); // better be a 1-edge
            const double d2 = getPointToEdgeDist2(xsp_t[isp1],xp[spose[ise][0]],xp[spose[ise][1]]);
            if ((se_matching[isp1] == -1)||(d2 < d2_closest)) {
              se_matching[isp1] = ise0; // use the edge index in the list of edges...
              d2_closest = d2;
            }
          }
          if (se_matching[isp1] != -1)
          d2_max = max(d2_max,d2_closest);
        }

        if (mpi_rank == 0)
        cout << " > transformed bi1 points matched bi0 edges within tol: " << sqrt(d2_max) << endl;

      }

      delete[] sp_index;
      delete[] sp_d2;

      // we now have se_matching set to an edge for every node...

      for (int ise0 = 0; ise0 < nse0; ++ise0)
      spose_i[ise0+1] = 0;
      for (int isp1 = 0; isp1 < nsp1; ++isp1) {
        assert((se_matching[isp1] >= 0)&&(se_matching[isp1] < nse0));
        ++spose_i[se_matching[isp1]+1];
      }
      spose_i[0] = 0;
      for (int ise0 = 0; ise0 < nse0; ++ise0)
      spose_i[ise0+1] += spose_i[ise0];
      assert(spose_i[nse0] == nsp1);
      for (int isp1 = 0; isp1 < nsp1; ++isp1) {
        spose_v[spose_i[se_matching[isp1]]] = isp1;
        ++spose_i[se_matching[isp1]];
      }
      for (int ise0 = nse0-1; ise0 > 0; --ise0)
      spose_i[ise0] = spose_i[ise0-1];
      spose_i[0] = 0;

      delete[] se_matching;

      checkMem();

      // now do edges...

      for (int ise0 = 0; ise0 < nse0; ++ise0) {
        const int ise = se_index[ise0];
        vector<double> wpVec;
        for (int sos = spose_i[ise0]; sos != spose_i[ise0+1]; ++sos) {
          const int isp1 = spose_v[sos];
          const double dxsp[3] = DIFF(xsp_t[isp1],xp[spose[ise][0]]);
          const double dxp[3] = DIFF(xp[spose[ise][1]],xp[spose[ise][0]]);
          const double dp = DOT_PRODUCT(dxsp,dxp);
          const double dxp2 = dxp[0]*dxp[0] + dxp[1]*dxp[1] + dxp[2]*dxp[2];
          if ((dp > 0.0)&&(dp < dxp2)) {
            const double wp = dp/dxp2;
            if (min(wp,1.0-wp)*dxp2 > tol) {
              wpVec.push_back(wp);
            }
          }
        }
        if (!wpVec.empty()) {
          if (ierr == 0) ierr = 1;
          // note that here we use the "getX()" routines because they allow
          // for a temporary broken-memory model, which we will correct after
          // all mods are made with a call to combineMemCollective()...
          sort(wpVec.begin(),wpVec.end());
          // add the new points by breaking the existing edge...
          const int isp0_orig = spose[ise][0];
          const int isp1_orig = spose[ise][1];
          int ise_prev = ise;
          assert(getSpose(ise_prev,1) == isp1_orig);
          for (int ii = 0, ii_max=wpVec.size(); ii < ii_max; ++ii) {
            const double wp = wpVec[ii];
            const int isp_new = new_sp();
            FOR_I3 getXp(isp_new,i) = wp*xp[isp1_orig][i] + (1.0-wp)*xp[isp0_orig][i];
            getPbi(isp_new) = isp_new;
            assert(getSpose(ise_prev,1) == isp1_orig);
            getSpose(ise_prev,1) = isp_new;
            const int ise_new = new_se();
            getSpose(ise_new,0) = isp_new;
            getSpose(ise_new,1) = isp1_orig;
            // we also need a new edge splitting each of the tris associated with the
            // previous edge...
            {
              const int ist0 = getStose(ise_prev,0);
              if (ist0 == -1)
              getStose(ise_new,0) = -1;
              else {
                assert(ist0 >= 0);
                // look for ise_prev in ist0...
                int eot;
                for (eot = 0; eot < 3; ++eot)
                if (getSeost(ist0,eot) == ise_prev)
                break;
                assert(eot < 3); // make sure we found it...
                // note: the spost numbering convention for nodes of this edge is: eot and (eot+1)%3...
                assert(getSpost(ist0,(eot+1)%3) == isp1_orig);
                const int ist_new = new_st();
                const int ise_split_new = new_se();
                const int ied_orig = getSeost(ist0,(eot+1)%3);
                const int isp_opposite = getSpost(ist0,(eot+2)%3);
                // new edge...
                getStose(ise_new,0) = ist_new;
                // new tri...
                getSpost(ist_new,eot)       = isp_new;
                getSpost(ist_new,(eot+1)%3) = isp1_orig;
                getSpost(ist_new,(eot+2)%3) = isp_opposite;
                getSeost(ist_new,eot)       = ise_new;
                getSeost(ist_new,(eot+1)%3) = ied_orig;
                getSeost(ist_new,(eot+2)%3) = ise_split_new;
                getZnost(ist_new) = getZnost(ist0);
                // old tri...
                getSpost(ist0,(eot+1)%3) = isp_new;
                getSeost(ist0,(eot+1)%3) = ise_split_new;
                // original edge needs to point to the new tri...
                if (getStose(ied_orig,0) == ist0)
                getStose(ied_orig,0) = ist_new;
                else {
                  assert(getStose(ied_orig,1) == ist0);
                  getStose(ied_orig,1) = ist_new;
                }
                // new edge splitting tri...
                getSpose(ise_split_new,0) = isp_opposite;
                getSpose(ise_split_new,1) = isp_new;
                getStose(ise_split_new,0) = ist_new;
                getStose(ise_split_new,1) = ist0;
              }
            }
            {
              const int ist1 = getStose(ise_prev,1);
              if (ist1 == -1)
              getStose(ise_new,1) = -1;
              else {
                assert(ist1 >= 0);
                // look for ise_prev in ist1...
                int eot;
                for (eot = 0; eot < 3; ++eot)
                if (getSeost(ist1,eot) == ise_prev)
                break;
                assert(eot < 3); // make sure we found it...
                // note: the spost numbering convention for nodes of this edge is: eot and (eot+1)%3...
                assert(getSpost(ist1,eot) == isp1_orig);
                const int ist_new = new_st();
                const int ise_split_new = new_se();
                const int ied_orig = getSeost(ist1,(eot+2)%3);
                const int isp_opposite = getSpost(ist1,(eot+2)%3);
                // new edge...
                getStose(ise_new,1) = ist_new;
                // new tri...
                getSpost(ist_new,eot)       = isp1_orig;
                getSpost(ist_new,(eot+1)%3) = isp_new;
                getSpost(ist_new,(eot+2)%3) = isp_opposite;
                getSeost(ist_new,eot)       = ise_new;
                getSeost(ist_new,(eot+1)%3) = ise_split_new;
                getSeost(ist_new,(eot+2)%3) = ied_orig;
                getZnost(ist_new) = getZnost(ist1);
                // old tri...
                getSpost(ist1,eot) = isp_new;
                getSeost(ist1,(eot+2)%3) = ise_split_new;
                // original edge needs to point to the new tri...
                if (getStose(ied_orig,0) == ist1)
                getStose(ied_orig,0) = ist_new;
                else {
                  assert(getStose(ied_orig,1) == ist1);
                  getStose(ied_orig,1) = ist_new;
                }
                // new edge splitting tri...
                getSpose(ise_split_new,0) = isp_opposite;
                getSpose(ise_split_new,1) = isp_new;
                getStose(ise_split_new,1) = ist_new;
                getStose(ise_split_new,0) = ist1;
              }
            }
            ise_prev = ise_new;
          }
        }
      }

      checkMem();

      delete[] spose_i;
      delete[] spose_v;

      delete[] se_index;
      delete[] xsp_t;
      delete[] sp_flag;

      if (ierr == 1)
      if (mpi_rank == 0)
      cout << " > added points: " << getNsp()-nsp << ", edges: " << getNse()-nse << ", tris: " << getNst()-nst << endl;

    }

    MPI_Bcast(&ierr,1,MPI_INT,0,mpi_comm_shared);

    if (ierr < 0) {
      CERR("setPeriodic problem");
    }
    else if (ierr == 0) {
      assert(getNsp() == nsp);
      assert(getNse() == nse);
      assert(getNst() == nst);
    }
    else {
      combineMemCollective();
    }

    if (mpi_rank_shared == 0) checkMem();

    // ================================================================================
    // ================================================================================
    // ================================================================================
    // now the original matching routine that assumes identical node counts...
    // ================================================================================
    // ================================================================================
    // ================================================================================

    ierr = 0;
    if (mpi_rank_shared == 0) {

      try {

        // now identify the relevant nodes...

        int * sp_flag = new int[nsp];
        FOR_ISP sp_flag[isp] = 0;
        FOR_IST {
          if ((znost[ist] >= 0)&&(zoneVec[znost[ist]].getBi() == bi0)) {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= 1; //(1<<0)
            }
          }
          else if ((znost[ist] >= 0)&&(zoneVec[znost[ist]].getBi() == bi1)) {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= (1<<1); // i.e. 2
            }
          }
          else {
            FOR_I3 {
              const int isp = spost[ist][i];
              sp_flag[isp] |= (1<<2); // i.e. 4
            }
          }
        }

        int count = 0;
        int count1 = 0;
        FOR_ISP {
          if (sp_flag[isp] == 5) { // i.e. 4+1
            // this is a node that is on the bit0+regular boundary: use negative convention for sp_flag,
            // saving space for -1 and -2
            sp_flag[isp] = -count-3;
            ++count;
          }
          else if (sp_flag[isp] == 6) { // i.e. 4+2
            // this is a node that is on the bit1+regular boundary: use positive convention for sp_flag,
            sp_flag[isp] = count1;
            ++count1;
          }
          else if (sp_flag[isp] == 4) {
            // this is a node that is on the regular boundary: keep...
            sp_flag[isp] = -2; // keep
          }
          else {
            // node should be entirely 1 or entirely 2...
            assert( (sp_flag[isp] == 1) || (sp_flag[isp] == 2) ); // 3 should never happen? no?
            sp_flag[isp] = -1; // discard
          }
        }

        if (mpi_rank == 0)
        cout << " > points on bi0: " << count << ", points on bi1: " << count1 << endl;
        assert(count == count1);

        int * index0 = new int[count];
        int * index1 = new int[count];
        for (int ii = 0; ii < count; ++ii) {
          index0[ii] = -1;
          index1[ii] = -1;
        }

        double *d2_min = new double[count];

        FOR_IST {
          FOR_I3 {
            const int isp = spost[ist][i];
            if (sp_flag[isp] >= 0) {
              const int i1 = sp_flag[isp]; assert((i1 >= 0)&&(i1 < count));
              if (index1[i1] == -1) {
                index1[i1] = isp;
              }
              else {
                assert(index1[i1] == isp);
              }
            }
            else if (sp_flag[isp] <= -3) {
              const int i0 = -sp_flag[isp]-3; assert((i0 >= 0)&&(i0 < count));
              // compute the delta2 from connected edges...
              const int isp_next = spost[ist][(i+1)%3];
              const int isp_next_next = spost[ist][(i+2)%3];
              const double this_d2 = min(DIST2(xp[isp],xp[isp_next]),DIST2(xp[isp],xp[isp_next_next]));
              if (index0[i0] == -1) {
                index0[i0] = isp;
                d2_min[i0] = this_d2;
              }
              else {
                assert(index0[i0] == isp);
                d2_min[i0] = min(d2_min[i0],this_d2);
              }
            }
          }
        }

        // check...
        for (int ii = 0; ii < count; ++ii) {
          assert((index0[ii] >= 0)&&(index0[ii] < nsp));
          assert((index1[ii] >= 0)&&(index1[ii] < nsp));
        }

        // put the points on bit0 into an adt with bbox based on their
        // nearby edges computed above. Also collect the bit1 points
        // in a single array for transformation and comparison...

        double per_tol_factor = 0.4;
        if (checkParam("PERIODIC_TOL_FAC")) {
          FOR_PARAM_MATCHING("PERIODIC_TOL_FAC") {
            per_tol_factor = param->getDouble(0);
          }
        }
        if (mpi_rank == 0)
        cout << " > using periodic tolerance factor of " << per_tol_factor << endl;

        double (*bbmin)[3] = new double[count][3];
        double (*bbmax)[3] = new double[count][3];
        double (*xp_t)[3] = new double[count][3];
        for (int ii = 0; ii < count; ++ii) {
          // bbox for bit0 surface...
          {

            const int isp = index0[ii];
            const double delta = per_tol_factor*sqrt(d2_min[ii]);

            FOR_I3 bbmin[ii][i] = xp[isp][i]-delta;
            FOR_I3 bbmax[ii][i] = xp[isp][i]+delta;
          }
          // points from bit1 surface...
          {
            const int isp = index1[ii];
            FOR_I3 xp_t[ii][i] = xp[isp][i];
          }
        }
        delete[] d2_min; // not needed any more

        Adt<double> * xpAdt = new Adt<double>(count,bbmin,bbmax);
        delete[] bbmin;
        delete[] bbmax;

        // translate the bit1 points to bit0 points...

        periodicTranslate(xp_t,count,(1<<bi1));

        // now link the points...

        double d2_max = 0.0;
        for (int ii = 0; ii < count; ++ii) {
          vector<int> candidateVec;
          xpAdt->buildListForPoint(candidateVec,xp_t[ii]);
          switch(candidateVec.size()) {
            case 0:
              CWARN("no candidate found for translated point at: " << COUT_VEC(xp_t[ii]) );
              CWARN("Try using a larger TOL_FAC value (default is 0.4).");
              ierr = -1;
              break;
            case 1:
              if (index0[candidateVec[0]] < 0) {
                cout << "Error: candidate already found for translated point at: " << COUT_VEC(xp_t[ii]) << endl;
                ierr = -1;
              }
              else {
                const int isp = index0[candidateVec[0]];
                index0[candidateVec[0]] = -isp-1;
                sp_flag[index1[ii]] = isp; // put the connection in sp_flag...
                // record the max distance...
                d2_max = max(d2_max,DIST2(xp[isp],xp_t[ii]));
                // and flip the index...
              }
              break;
            default:
              // more than one candidate...one should be the closest by a significant distance.
              // Otherwise, the reconnection is ambiguous. Look out for -index...
              double d2_min = HUGE_VAL;
              int closest_isp;
              int candidate;
              double factor;
              bool bIspSet = false;
              for (int it=0, limit=candidateVec.size(); it < limit; it++) {
                const int cisp = index0[candidateVec[it]];
                if (cisp < 0) {
                  // candidate already found, ignore this point
                } else {
                  const double d2_min_tmp = DIST2(xp[cisp],xp_t[ii]);
                  if (d2_min_tmp < d2_min) {
                    factor = d2_min/d2_min_tmp;
                    d2_min = d2_min_tmp;
                    closest_isp = cisp;
                    candidate = candidateVec[it];
                    bIspSet = true;
                  }
                }
              }

              if (!bIspSet) {
                COUT1("Error: no unset candidates found for translated point at: " << COUT_VEC(xp_t[ii]));
                ierr = -1;
              } else {
                index0[candidate] = -closest_isp-1;
                sp_flag[index1[ii]] = closest_isp; // put the connection in sp_flag...
                // record the max distance...
                d2_max = max(d2_max,DIST2(xp[closest_isp],xp_t[ii]));
                if (factor < 1.05) {
                  COUT1("Warning: multiple equidistant candidates found for translated point at: "
                        << COUT_VEC(xp_t[ii]) << " (dist factor: " << factor << ")");
                }
              }
          }
        }

        delete xpAdt;
        delete[] xp_t;
        delete[] index0;

        COUT1(" > periodic points matched within dist (should be small): " << sqrt(d2_max));

        // the periodic connections ultimately get stored in the int array pbi (periodic bits-index)...
        // pbi has the following bits...
        // |b5|b4|b3|b2|b1|b0|---integer-index-bits---|

        assert(pbi != NULL);

        for (int ii = 0; ii < count; ++ii) {
          const int isp = index1[ii];
          int isp0 = sp_flag[isp];
          assert(isp != isp0);
          int bits = (1<<bi0);
          while (pbi[isp0] != uint(isp0))
          assert(0);
          pbi[isp] = BitUtils::makePbiHash(bits,isp0);
          // also correct the coordinate to be EXACTLY the tranlated value...
          FOR_I3 xp[isp][i] = xp[isp0][i];
          periodicTranslate(xp+isp,1,bits);
        }

        delete[] index1;
        delete[] sp_flag;

        // finally, check the correspondence of the periodicity...

        d2_max = 0.0;
        count1 = 0;
        FOR_ISP {
          if (pbi[isp] != uint(isp)) {
            int bits,index;
            BitUtils::unpackPbiHash(bits,index,pbi[isp]);
            assert(bits);
            double xp_test[3]; FOR_I3 xp_test[i] = xp[index][i];
            periodicTranslate(&xp_test,1,bits);
            const double this_d2 = DIST2(xp_test,xp[isp]);
            d2_max = max(d2_max,this_d2);
            ++count1;
          }
        }

        if (mpi_rank == 0)
        cout << " > final periodic node count: " << count1 << " dist check (should be small): " << sqrt(d2_max) << endl;

      }
      catch(...) {

        ierr = -1;

      }

    }

    // error...

    MPI_Bcast(&ierr,1,MPI_INT,0,mpi_comm_shared);
    if (ierr != 0)
    CERR("setPeriodic problem");

  }

#endif














// extended face stuff pruned from VoronoiPart.cpp

  class ExtendedFace {
  public:
    int8 cvofa_global[2];
    double n[3];
    double c[3];
    int group;
    ExtendedFace() {
      n[0] = n[1] = n[2] = 0.0;
      c[0] = c[1] = c[2] = 0.0;
      cvofa_global[0] = cvofa_global[1] = -1;
      group = -1;
    }
  };
  
  void buildExtendedFaces2(ExtendedFace*& fa_e,int& nfa_e, 
			   double * vol_cv,double (*x_cv_local)[3],int8 * cvora,
			   const vector<BfData>& bf_data_vec,int * bfocv_i,vector<FaData>& fa_dup_data_vec,int * faocv_dup_i) const;
  
private:
  
  void setFaceVectorsPlus(double e0[3],double e1[3],double e2[3],const double n_fa[3],const double inv_L) const;
  void setFaceVectorsMinus(double e0[3],double e1[3],double e2[3],const double n_fa[3],const double inv_L) const;
  void groupCompactFaces(int* group_fa, const double (*n_fa)[3],const double * c_fa_mag2,const int nfa) const;
  void groupExtendedFaces(ExtendedFace * fa_e,const int nfa_e) const;
  

  void calcAllQuadratureTerms(double * coeff,const double scale_factor,const int ip) const;
  void calcQuadratureTerms(double * coeff,const int ip,const double x0[3],const double e0[3],const double e1[3],const double e2[3]) const;
private:

  void mapCvQuadratureTerms(double * coeff,const int ip,const double x0[3],const double L_cv,const double inv_L_fa,const double e0_inv_L_fa[3],const double e1_inv_L_fa[3],const double e2_inv_L_fa[3],const double coeff_cv[35]) const;
  
  void addAllTetQuadratureTerms(double * coeff,const double xp[4][3]) const;
  void addTetQuadratureTerms(double * coeff,const double xp[4][3]) const;
  



// from io
    
      // n_ef 
    
      if ( mpi_rank == 0 ) { 
	cout << " > n_ef ... " << endl;
	Header header; 
	sprintf(header.name,"n_ef"); 
	header.id       = UGP_IO_EF_D2; 
	header.skip     = header_size + nfa_e_global*double_size*3;
	ByteSwap::setLswMswPairForInt8(header.idata+0,nfa_e_global); 
	header.idata[2] = 3;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      } 
    
      double (*d3_ef)[3] = new double[nfa_e][3];
    
      for (int ifa_e = 0; ifa_e < nfa_e; ++ifa_e)
	FOR_I3 d3_ef[ifa_e][i] = fa_e[ifa_e].n[i];
    
      writeChunkedData<double>(fh,offset+header_size+nfa_e_offset*double_size*3,(double*)d3_ef,nfa_e*3,n_chunk);
    
      offset += header_size + nfa_e_global*double_size*3;
    
      MPI_Sync("done n_ef");
    
      // c_fa_e 
    
      if ( mpi_rank == 0 ) { 
	cout << " > c_ef ... " << endl;
	Header header; 
	sprintf(header.name,"c_ef"); 
	header.id       = UGP_IO_EF_D2; 
	header.skip     = header_size + nfa_e_global*double_size*3;
	ByteSwap::setLswMswPairForInt8(header.idata+0,nfa_e_global); 
	header.idata[2] = 3;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      } 

      for (int ifa_e = 0; ifa_e < nfa_e; ++ifa_e)
	FOR_I3 d3_ef[ifa_e][i] = fa_e[ifa_e].c[i];
    
      writeChunkedData<double>(fh,offset+header_size+nfa_e_offset*double_size*3,(double*)d3_ef,nfa_e*3,n_chunk);
    
      offset += header_size + nfa_e_global*double_size*3;
    
      MPI_Sync("done c_ef");
    
      delete[] d3_ef;

      // cvofa_e_global...
    
      if ( mpi_rank == 0 ) { 
	cout << " > cvofa_e_global ... " << endl;
	Header header; 
	sprintf(header.name,"cvoef_global"); 
	header.id       = UGP_IO_CVOEF; 
	header.skip     = header_size + nfa_e_global*int8_size*2;
	ByteSwap::setLswMswPairForInt8(header.idata+0,nfa_e_global); 
	header.idata[2] = 2;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      } 

      int8 (*cvofa_e_global)[2] = new int8[nfa_e][2];
      for (int ifa_e = 0; ifa_e < nfa_e; ++ifa_e)
	FOR_I2 cvofa_e_global[ifa_e][i] = fa_e[ifa_e].cvofa_global[i];
    
      writeChunkedData<int8>(fh,offset+header_size+nfa_e_offset*int8_size*2,(int8*)cvofa_e_global,nfa_e*2,n_chunk);
    
      offset += header_size + nfa_e_global*int8_size*2;
    
      delete[] cvofa_e_global;
    
      MPI_Sync("done cvofa_e_global");
    
      // fa_e_group...
    
      if ( mpi_rank == 0 ) { 
	cout << " > group_ef ... " << endl;
	Header header; 
	sprintf(header.name,"group_ef"); 
	header.id       = UGP_IO_EF_I1; 
	header.skip     = header_size + nfa_e_global*int_size;
	ByteSwap::setLswMswPairForInt8(header.idata+0,nfa_e_global); 
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      } 
    
      int *group_ef = new int[nfa_e];
      for (int ifa_e = 0; ifa_e < nfa_e; ++ifa_e)
	group_ef[ifa_e] = fa_e[ifa_e].group;
    
      writeChunkedData<int>(fh,offset+header_size+nfa_e_offset*int_size,group_ef,nfa_e,n_chunk);
    
      offset += header_size + nfa_e_global*int_size;
    
      delete[] group_ef;
    
      MPI_Sync("done group_ef");
    
    }



      // group_fa...
      if ( mpi_rank == 0 ) { 
	cout << " > group_fa (int+periodic) " << endl;
	Header header; 
	sprintf(header.name,"group_fa"); 
	header.id       = UGP_IO_FA_I1; 
	header.skip     = header_size + nfa_global*int_size;
	ByteSwap::setLswMswPairForInt8(header.idata+0,nfa_global); 
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      } 
    
      offset += header_size;
    
      my_disp_local = 0;
      for (int izone = 0; izone < 27; ++izone) {
	if (nfa_zone[izone] > 0) {
	  writeChunkedData<int>( fh,offset+my_nfa_disp[izone]*sizeof(int),(int*)(group_fa+my_disp_local),my_nfa_zone[izone],n_chunk);
	  offset += nfa_zone[izone]*sizeof(int);
	  my_disp_local += my_nfa_zone[izone];
	}
      }
    
      delete[] group_fa;
      MPI_Sync("done group_fa");







    int nfa_e = 0;
  ExtendedFace * fa_e = NULL;
  int8 nfa_e_offset = 0,nfa_e_global = 0;
  
  if (io_version >= 5) {
    
    buildExtendedFaces2(fa_e,nfa_e,
			vol_cv,x_cv,cvora,bf_data_vec,bfocv_i,fa_dup_data_vec,faocv_dup_i);

    // extended face offsets and global counts...
  
    int8 nfa_e_int8 = nfa_e;
    MPI_Scan(&nfa_e_int8,&nfa_e_offset,1,MPI_INT8,MPI_SUM,mpi_comm);
    // the offset on the last rank will be the total -- bcast back to everyone...
    nfa_e_global = nfa_e_offset;
    MPI_Bcast(&nfa_e_global,1,MPI_INT8,mpi_size-1,mpi_comm);
    if (mpi_rank == 0) cout << " > nfa_e_global: " << nfa_e_global << endl;
    nfa_e_offset -= nfa_e_int8;
    
  }
  




void VoronoiPart::groupCompactFaces(int * group_fa, const double (*n_fa)[3], const double * c_fa_mag2, const int nfa) const {
  
  const double c2_over_n2_ratio_zero = 1.0E-24; 
  const double matched_face_tol = 1.0E-11;
  
  int8 my_count[6] = { nfa, 0, 0, 0, 0, 0 };
  
  vector<pair<double,int> > magAndIndexVec;
  for (int ifa = 0; ifa < nfa; ++ifa) {
    // check magnitudes...
    const double n_mag2 = DOT_PRODUCT(n_fa[ifa],n_fa[ifa]);
    // only consider faces where c is zero wrt n_mag. Use the same factor
    // as used when determining zero faces in the vd tightened by an additional 
    // few orders of magnitude...
    if (c_fa_mag2[ifa] <= c2_over_n2_ratio_zero*n_mag2) {
      magAndIndexVec.push_back(pair<double,int>(sqrt(n_mag2),ifa));
      ++my_count[1];
    }
    else if (c_fa_mag2[ifa] < 10.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[2];
    }
    else if (c_fa_mag2[ifa] < 100.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[3];
    }
    else if (c_fa_mag2[ifa] < 1000.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[4];
    }
    else if (c_fa_mag2[ifa] < 10000.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[5];
    }
  }

  int8 count[6];
  MPI_Reduce(my_count,count,6,MPI_INT8,MPI_SUM,0,mpi_comm);
  if (mpi_rank == 0) {
    cout << " compact faces flagged for potential grouping: " << count[1] << " out of " << count[0] << " (" << double(count[1])/double(count[0])*100.0 << "%)" << endl;
    cout << " sensitivity check: additional compact faces flagged if c2_over_n2_ratio_zero reduced: " << count[2] << " " << count[3] << " " << count[4] << " " << count[5] << endl;
  }
    
  sort(magAndIndexVec.begin(),magAndIndexVec.end());

  vector<pair<double,int> > myNormalKindVec;
  for (int ii = 0,nii = magAndIndexVec.size(); ii < nii; ++ii) {
    if ( myNormalKindVec.empty() || ( magAndIndexVec[ii].first - myNormalKindVec.back().first > matched_face_tol*myNormalKindVec.back().first ) ) {
      myNormalKindVec.push_back(pair<double,int>(magAndIndexVec[ii].first,1));
    }
    else {
      myNormalKindVec.back().second += 1; // the count
    }
  }
    
  // let rank 0 gather everyone's groups and build a common version...
    
  int my_ngr = myNormalKindVec.size();
  int * ngora = NULL;
  if (mpi_rank == 0) ngora = new int[mpi_size];
  MPI_Gather(&my_ngr,1,MPI_INT,ngora,1,MPI_INT,0,mpi_comm);

  double * my_double_buf = new double[my_ngr];
  int * my_int_buf = new int[my_ngr];
  for (int igr = 0; igr < my_ngr; ++igr) {
    my_double_buf[igr] = myNormalKindVec[igr].first;
    my_int_buf[igr] = myNormalKindVec[igr].second;
  }
    
  int * disp_full = NULL;
  double * double_buf_full = NULL;
  int * int_buf_full = NULL;
  int full_size;
  if (mpi_rank == 0) {
    // check for overflow...
    int8 full_size_check = 0;
    FOR_RANK full_size_check += ngora[rank];
    assert(full_size_check < TWO_BILLION);
    disp_full = new int[mpi_size];
    disp_full[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      disp_full[rank] = disp_full[rank-1] + ngora[rank-1];
    full_size = disp_full[mpi_size-1] + ngora[mpi_size-1];
    double_buf_full = new double[full_size];
    int_buf_full = new int[full_size];
  }
    
  MPI_Gatherv(my_double_buf,my_ngr,MPI_DOUBLE,double_buf_full,ngora,disp_full,MPI_DOUBLE,0,mpi_comm);
  delete[] my_double_buf;
 
  MPI_Gatherv(my_int_buf,my_ngr,MPI_INT,int_buf_full,ngora,disp_full,MPI_INT,0,mpi_comm);
  delete[] my_int_buf; my_int_buf = NULL;
    
  // now build the final groups and counts on the rank0...
    
  vector<double> magVec;

  if (mpi_rank == 0) {

    vector<pair<double,int> > sortVec(full_size);
    int8 count_check = 0;
    for (int jj = 0; jj < full_size; ++jj) {
      sortVec[jj].first = double_buf_full[jj];
      sortVec[jj].second = jj;
      count_check += int_buf_full[jj];
    }
    assert(count_check == count[1]);
      
    sort(sortVec.begin(),sortVec.end());
      
    vector<pair<double,int8> > normalKindVec;
    for (int ii = 0; ii < full_size; ++ii) {
      const int jj = sortVec[ii].second;
      assert(sortVec[ii].first == double_buf_full[jj]);
      // increase the matched_face_tol here by an order of magnitude to combine groups
      if ( normalKindVec.empty() || ( sortVec[ii].first - normalKindVec.back().first > 10.0*matched_face_tol*normalKindVec.back().first ) ) {
	normalKindVec.push_back(pair<double,int>(double_buf_full[jj],int8(int_buf_full[jj])));
      }
      else {
	normalKindVec.back().second += int8(int_buf_full[jj]);
      }
    }
    delete[] double_buf_full; double_buf_full = NULL;
    delete[] int_buf_full; int_buf_full = NULL;
      
    cout << "Reduced groups: " << normalKindVec.size() << endl;
      
    for (int ii = 0,nii = normalKindVec.size(); ii < nii; ++ii) {
      if (ii == 0) {
	cout << " > group: " << ii << " area: " << normalKindVec[ii].first << " count: " << normalKindVec[ii].second << endl;
      }
      else {
	cout << " > group: " << ii << " area: " << normalKindVec[ii].first << " count: " << normalKindVec[ii].second << 
	  " diff with prev: " << (normalKindVec[ii].first-normalKindVec[ii-1].first)/normalKindVec[ii-1].first << endl;
      }
    }

    // and reduce...
    
    int8 final_count = 0;
    const int ngr_threshold = getIntParam("GROUP_MEMBER_THRESHOLD", 100);
    for (int ii = 0,nii = normalKindVec.size(); ii < nii; ++ii) {
      // save groups with counts above 100. Note that at this point we
      // only have the areas grouped. In each area, there could be 
      // 12 or 14 directions. So assuming we need atleast a few faces
      // in each area, we threshold at 100...
      if (normalKindVec[ii].second > ngr_threshold) {
	cout << " > FINAL compact face group: " << magVec.size() << " " << normalKindVec[ii].first << " count: " << normalKindVec[ii].second << endl;
	magVec.push_back(normalKindVec[ii].first);
	final_count += normalKindVec[ii].second;
      }
    }
    
    cout << "final count of grouped compact faces: " << final_count << endl;
    
    my_ngr = magVec.size();
    
  }
  
  // everybody needs the full list of potential groups...
  
  MPI_Bcast(&my_ngr,1,MPI_INT,0,mpi_comm);

  if (my_ngr > 0) {
    
    if (mpi_rank != 0) magVec.resize(my_ngr);
    MPI_Bcast(&magVec[0],my_ngr,MPI_DOUBLE,0,mpi_comm);
    
    // accuracy that a unit-normal dot product must be aligned to be considered the same face...
    
    const double dp_eps = 1.0E-12;

    vector<double> doubleVec;
    int idx_offset = 0;
    int igr = 0;
    double my_max_dp = 0.0;
    for (int ii = 0,nii = magAndIndexVec.size(); ii < nii; ++ii) {
      while ((igr < magVec.size()-1)&&(magVec[igr+1] <= magAndIndexVec[ii].first)) {
	++igr;
	doubleVec.push_back(0.0); doubleVec.push_back(0.0); doubleVec.push_back(0.0);
	idx_offset = doubleVec.size();
      }
      // it is possible that a group included in the magVec just fit, so its min value was (1+10*matched_face_tol)*magVec[igr]. Members
      // in that group may have been up to a full matched_face_tol away, so here we use 11x to include these candidates...
      if ( (magAndIndexVec[ii].first - magVec[igr] >= 0.0) && (magAndIndexVec[ii].first - magVec[igr] <= 11.0*matched_face_tol*magVec[igr]) ) {
	// get the unit normal...
	const int ifa = magAndIndexVec[ii].second;
	assert(group_fa[ifa] == -1);
	const double unit_n[3] = { 
	  n_fa[ifa][0]/magAndIndexVec[ii].first, 
	  n_fa[ifa][1]/magAndIndexVec[ii].first, 
	  n_fa[ifa][2]/magAndIndexVec[ii].first
	};
	// check the dot product against existing vectors in this group...
	int idx;
	for (idx = idx_offset; idx < doubleVec.size(); idx += 3) {
	  const double dp = unit_n[0]*doubleVec[idx] + unit_n[1]*doubleVec[idx+1] + unit_n[2]*doubleVec[idx+2];
	  if (dp > 1.0-dp_eps) {
	    my_max_dp = max(my_max_dp,1.0-dp);
	    // this is aligned with this vector...
	    assert(idx%3 == 0);
	    group_fa[ifa] = idx/3;
	    break;
	  }
	  else if (dp < -1.0+dp_eps) {
	    my_max_dp = max(my_max_dp,1.0+dp);
	    // this is exactly misaligned with this vector...
	    assert(idx%3 == 0);
	    group_fa[ifa] = -idx/3-2; // temporarily use -2 indexing
	    break;
	  }
	}
	if (idx == doubleVec.size()) {
	  assert(idx%3 == 0);
	  assert((idx-idx_offset)/3 < (1<<4));
	  group_fa[ifa] = idx/3;
	  doubleVec.push_back(unit_n[0]);
	  doubleVec.push_back(unit_n[1]);
	  doubleVec.push_back(unit_n[2]);
	}
      }
    }
    // complete any unfinished groups, and terminate with 0,0,0
    while (igr < magVec.size()) {
      ++igr;
      doubleVec.push_back(0.0); doubleVec.push_back(0.0); doubleVec.push_back(0.0);
    }

    double max_dp;
    MPI_Reduce(&my_max_dp,&max_dp,1,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
    
    // now switch the meaning of my_ngr...
    
    my_ngr = doubleVec.size();
    MPI_Gather(&my_ngr,1,MPI_INT,ngora,1,MPI_INT,0,mpi_comm);

    if (mpi_rank == 0) {
      // check for overflow...
      int8 full_size_check = 0;
      FOR_RANK full_size_check += ngora[rank];
      assert(full_size_check < TWO_BILLION);
      assert(disp_full != NULL);
      disp_full[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	disp_full[rank] = disp_full[rank-1] + ngora[rank-1];
      full_size = disp_full[mpi_size-1] + ngora[mpi_size-1];
      assert(double_buf_full == NULL); double_buf_full = new double[full_size];
      assert(full_size%3 == 0);
      assert(int_buf_full == NULL); int_buf_full = new int[full_size/3];
      for (int ii = 0; ii < full_size/3; ++ii)
	int_buf_full[ii] = -1;
    }
    
    MPI_Gatherv(&doubleVec[0],my_ngr,MPI_DOUBLE,double_buf_full,ngora,disp_full,MPI_DOUBLE,0,mpi_comm);
    
    if (mpi_rank == 0) {
      double max_dp_rank0 = 0.0;
      for (int igr = 0; igr < magVec.size(); ++igr) {
	doubleVec.clear();
	FOR_RANK {
	  assert(disp_full[rank]%3 == 0);
	  int idx_i = disp_full[rank]/3;
	  double unit_n[3];
	  FOR_I3 unit_n[i] = double_buf_full[disp_full[rank]++];
	  while (!((unit_n[0] == 0.0)&&(unit_n[1] == 0.0)&&(unit_n[2] == 0.0))) {
	    int idx;
	    for (idx = 0; idx < doubleVec.size(); idx += 3) {
	      const double dp = unit_n[0]*doubleVec[idx] + unit_n[1]*doubleVec[idx+1] + unit_n[2]*doubleVec[idx+2];
	      if (dp > 1.0-dp_eps) {
		// this is aligned with this vector...
		// the bit rules for the group are:
		// msb: group, then member in group, finally bit0 = sign...
		int_buf_full[idx_i] = (igr<<5)|((idx/3)<<1);
		max_dp_rank0 = max(max_dp_rank0,1.0-dp);
		break;
	      }
	      else if (dp < -1.0+dp_eps) {
		// this is exactly misaligned with this vector...
		int_buf_full[idx_i] = (igr<<5)|((idx/3)<<1)|1; // 0-bit is the sign bit
		max_dp_rank0 = max(max_dp_rank0,1.0+dp);
		break;
	      }
	    }
	    if (idx == doubleVec.size()) {
	      assert(idx/3 < (1<<4));
	      int_buf_full[idx_i] = (igr<<5)|((idx/3)<<1);
	      doubleVec.push_back(unit_n[0]);
	      doubleVec.push_back(unit_n[1]);
	      doubleVec.push_back(unit_n[2]);
	    }
	    // grab the next unit normal...
	    assert(disp_full[rank]%3 == 0);
	    idx_i = disp_full[rank]/3;
	    FOR_I3 unit_n[i] = double_buf_full[disp_full[rank]++];
	  }
	}
	cout << "group: " << igr << " doubleVec.size()/3: " << doubleVec.size()/3 << endl;
      }
      
      cout << "actual tol for dp matching: " << max_dp << " " << max_dp_rank0 << endl;
      
      // check and reset disp for return int...
      int disp_check = 0;
      FOR_RANK {
	disp_check += ngora[rank];
	assert(disp_full[rank] == disp_check);
	assert(ngora[rank]%3 == 0);
	ngora[rank] /= 3;
	if (rank == 0) {
	  disp_full[rank] = 0;
	}
	else {
	  disp_full[rank] = disp_full[rank-1] + ngora[rank-1];
	}
      }
      
      // now disp_full and ngora are set to scatterv the int...
      
    }

    assert(my_ngr%3 == 0);
    my_ngr /= 3;
    
    assert(my_int_buf == NULL);
    my_int_buf = new int[my_ngr];

    MPI_Scatterv(int_buf_full,ngora,disp_full,MPI_INT,my_int_buf,my_ngr,MPI_INT,0,mpi_comm);

    // now on each processor, modify the index...
    
    for (int ii = 0,nii = magAndIndexVec.size(); ii < nii; ++ii) {
      const int ifa = magAndIndexVec[ii].second;
      if (group_fa[ifa] >= 0) {
	const int idx = group_fa[ifa];
	assert((idx >= 0)&&(idx < my_ngr));
	assert(my_int_buf[idx] >= 0);
	group_fa[ifa] = my_int_buf[idx];
      }
      else if (group_fa[ifa] <= -2) {
	const int idx = -group_fa[ifa]-2;
	assert((idx >= 0)&&(idx < my_ngr));
	assert(my_int_buf[idx] >= 0);
	if (my_int_buf[idx] & 1)
	  group_fa[ifa] = (my_int_buf[idx] & (~1));
	else
	  group_fa[ifa] = (my_int_buf[idx] | 1);
      }
    }

    delete[] my_int_buf;

    /*
      int8 * gr_count = NULL;
      if (mpi_rank == 0) gr_count = new int8[my_ngr];
      MPI_Reduce(my_gr_count,gr_count,my_ngr,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
      int8 count_check = 0;
      for (int igr = 0; igr < my_ngr; ++igr) {
      count_check += gr_count[igr];
      cout << "igr: " << igr << " count: " << gr_count[igr] << endl;
      }
      cout << " should match final count of grouped faces: " << count_check << endl;
      delete[] gr_count; 
      }
      delete[] my_gr_count;
    */
    
  }

  if (mpi_rank == 0) {
    delete[] ngora;
    delete[] disp_full;
    delete[] double_buf_full;
    delete[] int_buf_full;
  }
    
}

void VoronoiPart::groupExtendedFaces(ExtendedFace * fa_e,const int nfa_e) const {
  
  const double c2_over_n2_ratio_zero = 1.0E-24; 
  const double matched_face_tol = 1.0E-11;
  
  int8 my_count[6] = { nfa_e, 0, 0, 0, 0, 0 };
  
  vector<pair<double,int> > magAndIndexVec;
  for (int ifa2 = 0; ifa2 < nfa_e; ++ifa2) {
    // check magnitudes...
    const double n_mag2 = DOT_PRODUCT(fa_e[ifa2].n,fa_e[ifa2].n);
    const double c_mag2 = DOT_PRODUCT(fa_e[ifa2].c,fa_e[ifa2].c);
    // only consider faces where c is zero wrt n_mag. Use the same factor
    // as used when determining zero faces in the vd tightened by an additional 
    // few orders of magnitude...
    if (c_mag2 <= c2_over_n2_ratio_zero*n_mag2) {
      magAndIndexVec.push_back(pair<double,int>(sqrt(n_mag2),ifa2));
      ++my_count[1];
    }
    else if (c_mag2 < 10.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[2];
    }
    else if (c_mag2 < 100.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[3];
    }
    else if (c_mag2 < 1000.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[4];
    }
    else if (c_mag2 < 10000.0*c2_over_n2_ratio_zero*n_mag2) {
      ++my_count[5];
    }
  }

  int8 count[6];
  MPI_Reduce(my_count,count,6,MPI_INT8,MPI_SUM,0,mpi_comm);
  if (mpi_rank == 0) {
    cout << " faces flagged for potential grouping: " << count[1] << " out of " << count[0] << " (" << double(count[1])/double(count[0])*100.0 << "%)" << endl;
    cout << " sensitivity check: additional faces flagged if c2_over_n2_ratio_zero reduced: " << count[2] << " " << count[3] << " " << count[4] << " " << count[5] << endl;
  }
    
  sort(magAndIndexVec.begin(),magAndIndexVec.end());

  vector<pair<double,int> > myNormalKindVec;
  for (int ii = 0,nii = magAndIndexVec.size(); ii < nii; ++ii) {
    if ( myNormalKindVec.empty() || ( magAndIndexVec[ii].first - myNormalKindVec.back().first > matched_face_tol*myNormalKindVec.back().first ) ) {
      myNormalKindVec.push_back(pair<double,int>(magAndIndexVec[ii].first,1));
    }
    else {
      myNormalKindVec.back().second += 1; // the count
    }
  }
    
  // let rank 0 gather everyone's groups and build a common version...
    
  int my_ngr = myNormalKindVec.size();
  int * ngora = NULL;
  if (mpi_rank == 0) ngora = new int[mpi_size];
  MPI_Gather(&my_ngr,1,MPI_INT,ngora,1,MPI_INT,0,mpi_comm);

  double * my_double_buf = new double[my_ngr];
  int * my_int_buf = new int[my_ngr];
  for (int igr = 0; igr < my_ngr; ++igr) {
    my_double_buf[igr] = myNormalKindVec[igr].first;
    my_int_buf[igr] = myNormalKindVec[igr].second;
  }
    
  int * disp_full = NULL;
  double * double_buf_full = NULL;
  int * int_buf_full = NULL;
  int full_size;
  if (mpi_rank == 0) {
    // check for overflow...
    int8 full_size_check = 0;
    FOR_RANK full_size_check += ngora[rank];
    assert(full_size_check < TWO_BILLION);
    disp_full = new int[mpi_size];
    disp_full[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      disp_full[rank] = disp_full[rank-1] + ngora[rank-1];
    full_size = disp_full[mpi_size-1] + ngora[mpi_size-1];
    double_buf_full = new double[full_size];
    int_buf_full = new int[full_size];
  }
    
  MPI_Gatherv(my_double_buf,my_ngr,MPI_DOUBLE,double_buf_full,ngora,disp_full,MPI_DOUBLE,0,mpi_comm);
  delete[] my_double_buf;
 
  MPI_Gatherv(my_int_buf,my_ngr,MPI_INT,int_buf_full,ngora,disp_full,MPI_INT,0,mpi_comm);
  delete[] my_int_buf; my_int_buf = NULL;
    
  // now build the final groups and counts on the rank0...
    
  vector<double> magVec;

  if (mpi_rank == 0) {

    vector<pair<double,int> > sortVec(full_size);
    int8 count_check = 0;
    for (int jj = 0; jj < full_size; ++jj) {
      sortVec[jj].first = double_buf_full[jj];
      sortVec[jj].second = jj;
      count_check += int_buf_full[jj];
    }
    assert(count_check == count[1]);
      
    sort(sortVec.begin(),sortVec.end());
      
    vector<pair<double,int8> > normalKindVec;
    for (int ii = 0; ii < full_size; ++ii) {
      const int jj = sortVec[ii].second;
      assert(sortVec[ii].first == double_buf_full[jj]);
      // increase the matched_face_tol here by an order of magnitude to combine groups
      if ( normalKindVec.empty() || ( sortVec[ii].first - normalKindVec.back().first > 10.0*matched_face_tol*normalKindVec.back().first ) ) {
	normalKindVec.push_back(pair<double,int>(double_buf_full[jj],int8(int_buf_full[jj])));
      }
      else {
	normalKindVec.back().second += int8(int_buf_full[jj]);
      }
    }
    delete[] double_buf_full; double_buf_full = NULL;
    delete[] int_buf_full; int_buf_full = NULL;
      
    cout << "Reduced groups: " << normalKindVec.size() << endl;
      
    for (int ii = 0,nii = normalKindVec.size(); ii < nii; ++ii) {
      if (ii == 0) {
	cout << " > group: " << ii << " area: " << normalKindVec[ii].first << " count: " << normalKindVec[ii].second << endl;
      }
      else {
	cout << " > group: " << ii << " area: " << normalKindVec[ii].first << " count: " << normalKindVec[ii].second << 
	  " diff with prev: " << (normalKindVec[ii].first-normalKindVec[ii-1].first)/normalKindVec[ii-1].first << endl;
      }
    }

    // and reduce...
    
    int8 final_count = 0;
    const int ngr_threshold = getIntParam("GROUP_MEMBER_THRESHOLD", 100);
    for (int ii = 0,nii = normalKindVec.size(); ii < nii; ++ii) {
      // save groups with counts above 100. Note that at this point we
      // only have the areas grouped. In each area, there could be 
      // 12 or 14 directions. So assuming we need atleast a few faces
      // in each area, we threshold at 100...
      if (normalKindVec[ii].second > ngr_threshold) {
	cout << " > FINAL extended face group: " << magVec.size() << " " << normalKindVec[ii].first << " count: " << normalKindVec[ii].second << endl;
	magVec.push_back(normalKindVec[ii].first);
	final_count += normalKindVec[ii].second;
      }
    }
    
    cout << "final count of grouped extended faces: " << final_count << endl;
    
    my_ngr = magVec.size();
    
  }
  
  // everybody needs the full list of potential groups...
  
  MPI_Bcast(&my_ngr,1,MPI_INT,0,mpi_comm);

  if (my_ngr > 0) {
    
    if (mpi_rank != 0) magVec.resize(my_ngr);
    MPI_Bcast(&magVec[0],my_ngr,MPI_DOUBLE,0,mpi_comm);
    
    // accuracy that a unit-normal dot product must be aligned to be considered the same face...
    
    const double dp_eps = 1.0E-12;

    vector<double> doubleVec;
    int idx_offset = 0;
    int igr = 0;
    double my_max_dp = 0.0;
    for (int ii = 0,nii = magAndIndexVec.size(); ii < nii; ++ii) {
      while ((igr < magVec.size()-1)&&(magVec[igr+1] <= magAndIndexVec[ii].first)) {
	++igr;
	doubleVec.push_back(0.0); doubleVec.push_back(0.0); doubleVec.push_back(0.0);
	idx_offset = doubleVec.size();
      }
      // it is possible that a group included in the magVec just fit, so its min value was (1+10*matched_face_tol)*magVec[igr]. Members
      // in that group may have been up to a full matched_face_tol away, so here we use 11x to include these candidates...
      if ( (magAndIndexVec[ii].first - magVec[igr] >= 0.0) && (magAndIndexVec[ii].first - magVec[igr] <= 11.0*matched_face_tol*magVec[igr]) ) {
	// get the unit normal...
	const int ifa_e = magAndIndexVec[ii].second;
	assert(fa_e[ifa_e].group == -1);
	const double unit_n[3] = { 
	  fa_e[ifa_e].n[0]/magAndIndexVec[ii].first, 
	  fa_e[ifa_e].n[1]/magAndIndexVec[ii].first, 
	  fa_e[ifa_e].n[2]/magAndIndexVec[ii].first
	};
	// check the dot product against existing vectors in this group...
	int idx;
	for (idx = idx_offset; idx < doubleVec.size(); idx += 3) {
	  const double dp = unit_n[0]*doubleVec[idx] + unit_n[1]*doubleVec[idx+1] + unit_n[2]*doubleVec[idx+2];
	  if (dp > 1.0-dp_eps) {
	    my_max_dp = max(my_max_dp,1.0-dp);
	    // this is aligned with this vector...
	    assert(idx%3 == 0);
	    fa_e[ifa_e].group = idx/3;
	    break;
	  }
	  else if (dp < -1.0+dp_eps) {
	    my_max_dp = max(my_max_dp,1.0+dp);
	    // this is exactly misaligned with this vector...
	    assert(idx%3 == 0);
	    fa_e[ifa_e].group = -idx/3-2; // temporarily use -2 indexing
	    break;
	  }
	}
	if (idx == doubleVec.size()) {
	  assert(idx%3 == 0);
	  assert((idx-idx_offset)/3 < (1<<4));
	  fa_e[ifa_e].group = idx/3;
	  doubleVec.push_back(unit_n[0]);
	  doubleVec.push_back(unit_n[1]);
	  doubleVec.push_back(unit_n[2]);
	}
      }
    }
    // complete any unfinished groups, and terminate with 0,0,0
    while (igr < magVec.size()) {
      ++igr;
      doubleVec.push_back(0.0); doubleVec.push_back(0.0); doubleVec.push_back(0.0);
    }

    double max_dp;
    MPI_Reduce(&my_max_dp,&max_dp,1,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
    
    // now switch the meaning of my_ngr...
    
    my_ngr = doubleVec.size();
    MPI_Gather(&my_ngr,1,MPI_INT,ngora,1,MPI_INT,0,mpi_comm);

    if (mpi_rank == 0) {
      // check for overflow...
      int8 full_size_check = 0;
      FOR_RANK full_size_check += ngora[rank];
      assert(full_size_check < TWO_BILLION);
      assert(disp_full != NULL);
      disp_full[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	disp_full[rank] = disp_full[rank-1] + ngora[rank-1];
      full_size = disp_full[mpi_size-1] + ngora[mpi_size-1];
      assert(double_buf_full == NULL); double_buf_full = new double[full_size];
      assert(full_size%3 == 0);
      assert(int_buf_full == NULL); int_buf_full = new int[full_size/3];
      for (int ii = 0; ii < full_size/3; ++ii)
	int_buf_full[ii] = -1;
    }
    
    MPI_Gatherv(&doubleVec[0],my_ngr,MPI_DOUBLE,double_buf_full,ngora,disp_full,MPI_DOUBLE,0,mpi_comm);
    
    if (mpi_rank == 0) {
      double max_dp_rank0 = 0.0;
      for (int igr = 0; igr < magVec.size(); ++igr) {
	doubleVec.clear();
	FOR_RANK {
	  assert(disp_full[rank]%3 == 0);
	  int idx_i = disp_full[rank]/3;
	  double unit_n[3];
	  FOR_I3 unit_n[i] = double_buf_full[disp_full[rank]++];
	  while (!((unit_n[0] == 0.0)&&(unit_n[1] == 0.0)&&(unit_n[2] == 0.0))) {
	    int idx;
	    for (idx = 0; idx < doubleVec.size(); idx += 3) {
	      const double dp = unit_n[0]*doubleVec[idx] + unit_n[1]*doubleVec[idx+1] + unit_n[2]*doubleVec[idx+2];
	      if (dp > 1.0-dp_eps) {
		// this is aligned with this vector...
		// the bit rules for the group are:
		// msb: group, then member in group, finally bit0 = sign...
		int_buf_full[idx_i] = (igr<<5)|((idx/3)<<1);
		max_dp_rank0 = max(max_dp_rank0,1.0-dp);
		break;
	      }
	      else if (dp < -1.0+dp_eps) {
		// this is exactly misaligned with this vector...
		int_buf_full[idx_i] = (igr<<5)|((idx/3)<<1)|1; // 0-bit is the sign bit
		max_dp_rank0 = max(max_dp_rank0,1.0+dp);
		break;
	      }
	    }
	    if (idx == doubleVec.size()) {
	      assert(idx/3 < (1<<4));
	      int_buf_full[idx_i] = (igr<<5)|((idx/3)<<1);
	      doubleVec.push_back(unit_n[0]);
	      doubleVec.push_back(unit_n[1]);
	      doubleVec.push_back(unit_n[2]);
	    }
	    // grab the next unit normal...
	    assert(disp_full[rank]%3 == 0);
	    idx_i = disp_full[rank]/3;
	    FOR_I3 unit_n[i] = double_buf_full[disp_full[rank]++];
	  }
	}
	cout << "group: " << igr << " doubleVec.size()/3: " << doubleVec.size()/3 << endl;
      }
      
      cout << "actual tol for dp matching: " << max_dp << " " << max_dp_rank0 << endl;
      
      // check and reset disp for return int...
      int disp_check = 0;
      FOR_RANK {
	disp_check += ngora[rank];
	assert(disp_full[rank] == disp_check);
	assert(ngora[rank]%3 == 0);
	ngora[rank] /= 3;
	if (rank == 0) {
	  disp_full[rank] = 0;
	}
	else {
	  disp_full[rank] = disp_full[rank-1] + ngora[rank-1];
	}
      }
      
      // now disp_full and ngora are set to scatterv the int...
      
    }

    assert(my_ngr%3 == 0);
    my_ngr /= 3;
    
    assert(my_int_buf == NULL);
    my_int_buf = new int[my_ngr];

    MPI_Scatterv(int_buf_full,ngora,disp_full,MPI_INT,my_int_buf,my_ngr,MPI_INT,0,mpi_comm);

    // now on each processor, modify the index...
    
    for (int ii = 0,nii = magAndIndexVec.size(); ii < nii; ++ii) {
      const int ifa_e = magAndIndexVec[ii].second;
      if (fa_e[ifa_e].group >= 0) {
	const int idx = fa_e[ifa_e].group;
	assert((idx >= 0)&&(idx < my_ngr));
	assert(my_int_buf[idx] >= 0);
	fa_e[ifa_e].group = my_int_buf[idx];
      }
      else if (fa_e[ifa_e].group <= -2) {
	const int idx = -fa_e[ifa_e].group-2;
	assert((idx >= 0)&&(idx < my_ngr));
	assert(my_int_buf[idx] >= 0);
	if (my_int_buf[idx] & 1)
	  fa_e[ifa_e].group = (my_int_buf[idx] & (~1));
	else
	  fa_e[ifa_e].group = (my_int_buf[idx] | 1);
      }
    }

    delete[] my_int_buf;

    /*
      int8 * gr_count = NULL;
      if (mpi_rank == 0) gr_count = new int8[my_ngr];
      MPI_Reduce(my_gr_count,gr_count,my_ngr,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
      int8 count_check = 0;
      for (int igr = 0; igr < my_ngr; ++igr) {
      count_check += gr_count[igr];
      cout << "igr: " << igr << " count: " << gr_count[igr] << endl;
      }
      cout << " should match final count of grouped faces: " << count_check << endl;
      delete[] gr_count; 
      }
      delete[] my_gr_count;
    */
    
  }

  if (mpi_rank == 0) {
    delete[] ngora;
    delete[] disp_full;
    delete[] double_buf_full;
    delete[] int_buf_full;
  }
    
}




#include "define_coeff.hpp"

void VoronoiPart::buildExtendedFaces2(ExtendedFace*& fa_e,int& nfa_e,
				      double * vol_cv,double (*x_cv_local)[3],int8 * cvora,
				      const vector<BfData>& bf_data_vec,int * bfocv_i,vector<FaData>& fa_dup_data_vec,int * faocv_dup_i) const {

  int icv_debug = -1;

  // pass this stuff in eventually...
  
  // build the reduced faces, including inter-processor duplicates...
  
  const int ncv = points->np;
  int * send_count = new int[mpi_size];
  FOR_RANK send_count[rank] = 0;
  
  int nfa_i = 0;
  int nfa_ip = 0;
  for (int icv = 0; icv < ncv; ++icv) {
    for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      int rank,bits,icv_nbr;
      BitUtils::unpackRankBitsIndex(rank,bits,icv_nbr,fa_dup_data_vec[ifa_dup].rbi_nbr);
      assert(bits == 0); // no periodicity for now
      if (rank == mpi_rank) {
	// only count this face once...
	if (icv < icv_nbr) nfa_i++;
      }
      else {
	// count every interprocessor face...
	nfa_ip++;
	// every inter-processor face needs to send its normal and centroid...
	++send_count[rank]; // 6 doubles
      }
    }
  }
  
  int * send_disp = new int[mpi_size];
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
  
  int * send_int_buf = new int[send_count_sum*4];
  double * send_double_buf = new double[send_count_sum*10];
  
  const int faocv_s = faocv_dup_i[ncv];
  assert(faocv_s == nfa_i*2 + nfa_ip);
  const int nfa = nfa_i + nfa_ip;
  
  double (*n_fa)[3] = new double[nfa][3];
  double (*x_fa)[3] = new double[nfa][3];
  double (*c_fa)[3] = new double[nfa][3];
  double *area_delta_fa = new double[nfa];
  int (*cvofa)[2] = new int[nfa][2];
  int * faocv_i = faocv_dup_i; // amazingly, this is the same!
  int * faocv_v = new int[faocv_s];

  map<const uint8,int> rbiMap;

  int * cvocv_i = new int[ncv+1];
  const int cvocv_s = ncv + faocv_s; // include diagonal 
  int * cvocv_v = new int[cvocv_s];

  int ncv_g = ncv;
  double dn2_max = 0.0;
  double dx2_max = 0.0;
  nfa_ip = nfa_i;
  nfa_i = 0;
  int coc = 0;
  for (int icv = 0; icv < ncv; ++icv) {
    // add the diagonal...
    cvocv_i[icv] = coc;
    cvocv_v[coc++] = icv;
    for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      const uint8 rbi_nbr = fa_dup_data_vec[ifa_dup].rbi_nbr;
      int rank,bits,icv_nbr;
      BitUtils::unpackRankBitsIndex(rank,bits,icv_nbr,rbi_nbr);
      assert(bits == 0); // no periodicity for now
      if (rank == mpi_rank) {
	// nbr is local...
	assert(icv_nbr < ncv);
	cvocv_v[coc++] = icv_nbr;
	// only count this face once...
	if (icv < icv_nbr) {
	  const int ifa = nfa_i++;
	  faocv_v[ifa_dup] = ifa;
	  cvofa[ifa][0] = icv;
	  cvofa[ifa][1] = icv_nbr;
	  FOR_I3 n_fa[ifa][i] = fa_dup_data_vec[ifa_dup].n[i];
	  FOR_I3 x_fa[ifa][i] = fa_dup_data_vec[ifa_dup].x[i] + points->xp[icv][i];
	  FOR_I3 c_fa[ifa][i] = fa_dup_data_vec[ifa_dup].x[i];
	  area_delta_fa[ifa] = DOT_PRODUCT(fa_dup_data_vec[ifa_dup].x,fa_dup_data_vec[ifa_dup].n);
	}
	else {
	  // our complete faocv_v should be constructed...
	  int foc,ifa; 
          for (foc = faocv_i[icv_nbr]; foc != faocv_i[icv_nbr+1]; ++foc) {
	    ifa = faocv_v[foc];
            if (cvofa[ifa][1] == icv) break;
          }
	  assert(foc != faocv_i[icv_nbr+1]);
	  faocv_v[ifa_dup] = ifa;
	  assert(cvofa[ifa][1] == icv);
	  assert(cvofa[ifa][0] == icv_nbr);
	  double dn[3]; FOR_I3 dn[i] = n_fa[ifa][i] + fa_dup_data_vec[ifa_dup].n[i];
	  dn2_max = max(dn2_max,DOT_PRODUCT(dn,dn));
	  double x[3]; FOR_I3 x[i] = fa_dup_data_vec[ifa_dup].x[i] + points->xp[icv][i];
	  const double dx2 = DIST2( x_fa[ifa],x);
	  dx2_max = max(dx2_max,dx2);
	  // complete internal geometry...
	  FOR_I3 n_fa[ifa][i] = 0.5*n_fa[ifa][i] - 0.5*fa_dup_data_vec[ifa_dup].n[i];
	  FOR_I3 x_fa[ifa][i] = 0.5*(x_fa[ifa][i] + x[i]);
	  FOR_I3 c_fa[ifa][i] = 0.5*(c_fa[ifa][i] + fa_dup_data_vec[ifa_dup].x[i]);
	  area_delta_fa[ifa] += DOT_PRODUCT(fa_dup_data_vec[ifa_dup].x,fa_dup_data_vec[ifa_dup].n);
	}
      }
      else {
	// count every interprocessor face...
	const int ifa = nfa_ip++;
	faocv_v[ifa_dup] = ifa;
	cvofa[ifa][0] = icv;
	// to get our neighbor, look for rbi_nbr in the map...
	map<const uint8,int>::iterator iter = rbiMap.find(rbi_nbr);
	if (iter == rbiMap.end()) {
	  cvofa[ifa][1] = ncv_g;
	  rbiMap[rbi_nbr] = ncv_g++;
	}
	else {
	  cvofa[ifa][1] = iter->second;
	}
	cvocv_v[coc++] = cvofa[ifa][1];
	FOR_I3 n_fa[ifa][i] = fa_dup_data_vec[ifa_dup].n[i];
	FOR_I3 x_fa[ifa][i] = fa_dup_data_vec[ifa_dup].x[i] + points->xp[icv][i];
	FOR_I3 c_fa[ifa][i] = fa_dup_data_vec[ifa_dup].x[i];
	area_delta_fa[ifa] = DOT_PRODUCT(fa_dup_data_vec[ifa_dup].x,fa_dup_data_vec[ifa_dup].n); 
	send_int_buf[send_disp[rank]*4  ] = icv_nbr; // icv on rank
	send_int_buf[send_disp[rank]*4+1] = mpi_rank;
	send_int_buf[send_disp[rank]*4+2] = 0;
	send_int_buf[send_disp[rank]*4+3] = icv;
	// and the doubles...
	FOR_I3 send_double_buf[send_disp[rank]*10+i]   = n_fa[ifa][i];
	FOR_I3 send_double_buf[send_disp[rank]*10+3+i] = x_fa[ifa][i]; assert(bits == 0);
	FOR_I3 send_double_buf[send_disp[rank]*10+6+i] = c_fa[ifa][i]; 
	send_double_buf[send_disp[rank]*10+9]          = area_delta_fa[ifa];
        send_disp[rank]++;
      }
    }
  }
  assert(nfa_ip == nfa);
  assert(coc == cvocv_s);
  cvocv_i[ncv] = cvocv_s;

  // reorder ghost data in rank/bits/index order...
  
  assert(rbiMap.size() == ncv_g-ncv);
  uint8* rbi_g = new uint8[ncv_g-ncv];
  for (map<const uint8,int>::const_iterator iter = rbiMap.begin(); iter != rbiMap.end(); ++iter) {
    rbi_g[iter->second-ncv] = iter->first;
  }
  rbiMap.clear();

  // rewind and exchange....
  
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

  int * recv_count = new int[mpi_size];
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
  
  int * recv_disp = new int[mpi_size];
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];

  FOR_RANK {
    send_count[rank] *= 4;
    send_disp[rank] *= 4;
    recv_count[rank] *= 4;
    recv_disp[rank] *= 4;
  }
  
  int * recv_int_buf = new int[recv_count_sum*4];
  MPI_Alltoallv(send_int_buf,send_count,send_disp,MPI_INT,
		recv_int_buf,recv_count,recv_disp,MPI_INT,mpi_comm);
  delete[] send_int_buf;   
  
  FOR_RANK {
    send_count[rank] = (send_count[rank]/4)*10;
    send_disp[rank] = (send_disp[rank]/4)*10;
    recv_count[rank] = (recv_count[rank]/4)*10;
    recv_disp[rank] = (recv_disp[rank]/4)*10;
  }
  
  double * recv_double_buf = new double[recv_count_sum*10];
  MPI_Alltoallv(send_double_buf,send_count,send_disp,MPI_DOUBLE,
		recv_double_buf,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  delete[] send_double_buf;   
  
  for (int irecv = 0; irecv < recv_count_sum; irecv++) {
    const int icv = recv_int_buf[irecv*4];
    assert((icv >= 0)&&(icv < ncv));
    int rank_nbr = recv_int_buf[irecv*4+1];
    int bits = recv_int_buf[irecv*4+2]; 
    assert(bits == 0);
    int icv_on_nbr = recv_int_buf[irecv*4+3];
    const uint8 rbi_nbr = BitUtils::packRankBitsIndex(rank_nbr,bits,icv_on_nbr);
    double n_nbr[3]; FOR_I3 n_nbr[i] = recv_double_buf[irecv*10+i];
    double x_nbr[3]; FOR_I3 x_nbr[i] = recv_double_buf[irecv*10+3+i];
    double c_nbr[3]; FOR_I3 c_nbr[i] = recv_double_buf[irecv*10+6+i];
    const double area_delta_nbr      = recv_double_buf[irecv*10+9];
    
    // our complete faocv_v should be constructed...
    int foc, ifa, icv_nbr; 
    for (foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
      ifa = faocv_v[foc];
      icv_nbr = cvofa[ifa][1];
      if ( (icv_nbr >= ncv) && (rbi_g[icv_nbr-ncv] == rbi_nbr) )
        break;
    }
    assert(foc != faocv_i[icv+1]);
    assert(cvofa[ifa][0] == icv); 
    assert(cvofa[ifa][1] == icv_nbr); 

    /*
      int ifa_dup;
      for (ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      if (fa_dup_data_vec[ifa_dup].rbi_nbr == rbi_nbr)
      break;
      }
      assert(ifa_dup == foc);
    */
    
    double dn[3]; FOR_I3 dn[i] = n_fa[ifa][i] + n_nbr[i];
    dn2_max = max(dn2_max,DOT_PRODUCT(dn,dn));
    const double dx2 = DIST2( x_fa[ifa],x_nbr);
    dx2_max = max(dx2_max,dx2); 
    // complete geometry...
    FOR_I3 n_fa[ifa][i] = 0.5*n_fa[ifa][i] - 0.5*n_nbr[i];
    FOR_I3 x_fa[ifa][i] = 0.5*(x_fa[ifa][i] + x_nbr[i]);
    FOR_I3 c_fa[ifa][i] = 0.5*(c_fa[ifa][i] + c_nbr[i]);
    area_delta_fa[ifa] += area_delta_nbr;
  }
  
  delete[] recv_int_buf;
  delete[] recv_double_buf;

  double my_errs[2] = {dn2_max,dx2_max};
  double errs[2];
  MPI_Allreduce(my_errs,errs,2,MPI_DOUBLE,MPI_MAX,mpi_comm);
  if (mpi_rank == 0) 
    cout << " dn2_max: " << errs[0] << " dx2_max: " << errs[1] << endl;
  
  // ==================================================================
  // complete the fa_dup_data_vec geometry by setting the average 
  // values...
  // ==================================================================
  
  for (int icv = 0; icv < ncv; ++icv) {
    for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      const int ifa = faocv_v[ifa_dup];
      if (cvofa[ifa][0] == icv) {
	// this fa_dup matches the alignment of n_fa...
	FOR_I3 fa_dup_data_vec[ifa_dup].n[i] = n_fa[ifa][i];
      }
      else {
	assert(cvofa[ifa][1] == icv);
	FOR_I3 fa_dup_data_vec[ifa_dup].n[i] = -n_fa[ifa][i];
      }
      FOR_I3 fa_dup_data_vec[ifa_dup].x[i] = x_fa[ifa][i];
      fa_dup_data_vec[ifa_dup].cmag2 = DOT_PRODUCT(c_fa[ifa],c_fa[ifa]);
      assert(fa_dup_data_vec[ifa_dup].area_over_delta == 0.0);
      fa_dup_data_vec[ifa_dup].area_over_delta = DOT_PRODUCT(n_fa[ifa],n_fa[ifa])/area_delta_fa[ifa];
      
      // serial check hack...
      /*
	{
	const int icv0 = cvofa[ifa][0]; assert((icv0 >= 0)&&(icv0 < ncv));
	const int icv1 = cvofa[ifa][1]; assert((icv1 >= 0)&&(icv1 < ncv));
	const double delta = DIST(points->xp[icv0],points->xp[icv1]);
	const double area = MAG(n_fa[ifa]);
	cout << "area: " << area << " delta: " << delta << " area/delta: " << area/delta << " error: " << fa_dup_data_vec[ifa_dup].area_over_delta - area/delta << endl;
	getchar();
	}
      */

    }
  }
  
  // checks...
  
  {
    
    double exact_grad[3] = { 1.123, 2.134, -1.3423 };
    
    double (*grad_phi)[3] = new double[ncv][3];
    FOR_ICV {
      
      FOR_I3 grad_phi[icv][i] = 0.0;
      for (int foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
	const int ifa = faocv_v[foc];
	const double phi = DOT_PRODUCT(exact_grad,x_fa[ifa]);
	if (cvofa[ifa][0] == icv) {
	  FOR_I3 grad_phi[icv][i] += phi*n_fa[ifa][i];
	}
	else {
	  assert(cvofa[ifa][1] == icv);
	  FOR_I3 grad_phi[icv][i] -= phi*n_fa[ifa][i];
	}
      }
      for (int ibf = bfocv_i[icv]; ibf != bfocv_i[icv+1]; ++ibf) {
	double x_bf[3]; FOR_I3 x_bf[i] = points->xp[icv][i] + bf_data_vec[ibf].x[i];
	const double phi = DOT_PRODUCT(exact_grad,x_bf);
	FOR_I3 grad_phi[icv][i] += phi*bf_data_vec[ibf].n[i];
      }
      FOR_I3 grad_phi[icv][i] = grad_phi[icv][i]/(vol_cv[icv]*exact_grad[i]) - 1.0;
    
      //if (grad_phi[icv][0] > 1.0E-7)
      //writeFullCvTecplot(icv,points->xp[icv]);
      
    }
    
    dumpRange(grad_phi,ncv,"GRAD_PHI ERROR -- including boundary cvs");

    FOR_ICV {
      for (int ibf = bfocv_i[icv]; ibf != bfocv_i[icv+1]; ++ibf) {
	FOR_I3 grad_phi[icv][i] = 0.0;
      }
    }

    dumpRange(grad_phi,ncv,"GRAD_PHI ERROR -- internal cvs only");
    
    delete[] grad_phi;

  }

  // calc cmag2 for compact face grouping...
  

  // we want to do this...
  delete[] x_fa; x_fa = NULL;
  delete[] c_fa; c_fa = NULL;
  delete[] n_fa; n_fa = NULL;
  delete[] area_delta_fa; area_delta_fa = NULL;
  delete[] cvofa; cvofa = NULL;
  faocv_i = NULL; // was just pointing into faocv_dup_i
  delete[] faocv_v; faocv_v = NULL;

  // ===================================================================
  // we now have all local geometry to proceed with the operator build...
  // ===================================================================

  MPI_Sync("about to calc ALL quadrature terms");

  double (*coeff_cv)[35] = new double[ncv][35];
  for (int icv = 0; icv < ncv; ++icv) {
    calcAllQuadratureTerms(coeff_cv[icv],2.0/points->delta[icv],icv);
  }

  MPI_Sync("back from calc of ALL quadrature terms");

  // step 1: we need the 14 quadrature coeff's in the ghost cvs of our
  // interprocessor faces where we don't have local voronoi data...
  
  FOR_RANK send_count[rank] = 0;
  
  // at the same time that we count how much data we need to send/recv, also
  // figure out the maximum local side of the cvocv_i/v CSR structure: i.e.
  // what is the maximum local nbr count...
  
  int coc_max = 0;
  for (int icv = 0; icv < ncv; ++icv) {
    coc_max = max(coc_max,cvocv_i[icv+1]-cvocv_i[icv]);
    // loop on faces first -- we are going to build the one-sided reconstruction operator...
    // CI use faocv_dup_i...
    for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      // for each face, we are going to build a linear system to compute the reconstruction coefficients...
      for (int coc = cvocv_i[icv]; coc != cvocv_i[icv+1]; ++coc) {
	const int icv_nbr = cvocv_v[coc];
	if (icv_nbr >= ncv) {
	  //const int ifa_dup_nbr = coc-cvocv_i[icv]-1+faocv_dup_i[icv];
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_nbr-ncv]);
	  //BitUtils::unpackRankBitsIndex(rank,bits,index,fa_dup_data_vec[ifa_dup].rbi_nbr);
	  assert(rank != mpi_rank);
	  assert(bits == 0);
	  ++send_count[rank];
	}
      }
    }
  }
    
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
    
  int * send_buf_int = new int[send_count_sum*4]; // for the icv, r,b,i nbr (for the face)...
  double * send_buf_double = new double[send_count_sum*14]; // 13 for the 3 components of e0,e1,e2, plus dx, inv_L_fa and 14 for the returned coeff, so use 14...

  double e0[3],e1[3],e2[3];
  
  for (int icv = 0; icv < ncv; ++icv) {
    // loop on faces first -- we are going to build the one-sided reconstruction operator...
    for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {

      // CI ifa_dup == foc, single function call here... 
      setFaceVectorsPlus(e0,e1,e2,fa_dup_data_vec[ifa_dup].n,1.0/points->delta[icv]);
      //FOR_I3 assert( fa_dup_data_vec[foc].x[i] == x_fa[ifa][i] );

      /*     
	     const int ifa = faocv_v[foc];
	     if (cvofa[ifa][0] == icv) {
	     // the face is outward-pointing already...
	     setFaceVectorsPlus(e0,e1,e2,n_fa[ifa],1.0/points->delta[icv]);
	     }
	     else {
	     assert(cvofa[ifa][1] == icv);
	     // the face is outward-pointing already...
	     setFaceVectorsMinus(e0,e1,e2,n_fa[ifa],1.0/points->delta[icv]);
	     }
      */
      // for each face, we are going to build a linear system to compute the reconstruction coefficients...
      for (int coc = cvocv_i[icv]; coc != cvocv_i[icv+1]; ++coc) {
	const int icv_nbr = cvocv_v[coc];
	if (icv_nbr >= ncv) {
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_nbr-ncv]);
	  assert(rank != mpi_rank);
	  assert(bits == 0);
	  int inverse_bits = 0;
	  send_buf_int[send_disp[rank]*4  ] = index; // icv on rank
	  send_buf_int[send_disp[rank]*4+1] = mpi_rank; // our rank
	  send_buf_int[send_disp[rank]*4+2] = inverse_bits;
	  send_buf_int[send_disp[rank]*4+3] = icv;
	  // the basis vectors...
	  FOR_I3 send_buf_double[send_disp[rank]*13+i] = e0[i];
	  FOR_I3 send_buf_double[send_disp[rank]*13+3+i] = e1[i];
	  FOR_I3 send_buf_double[send_disp[rank]*13+6+i] = e2[i];
	  // the face associated with this icv->icv_nbr connection is not 
	  // necessarily ifa (although it can be)...
	  //const int ifa_nbr = faocv_v[coc-cvocv_i[icv]-1+faocv_i[icv]];

	  // CI...
	  const int ifa_dup_nbr = coc-cvocv_i[icv]-1+faocv_dup_i[icv];
	  //FOR_I3 assert( fa_dup_data_vec[ifa_dup_nbr].x[i] == x_fa[ifa_nbr][i] );
          
	  //assert((cvofa[ifa_nbr][0] == icv)&&(cvofa[ifa_nbr][1] == icv_nbr)); // outward pointing by definition
	  // when computing the coefficients locally, we use a dx vector relative to
	  // the reconstruction face "ifa", so put the first part of this vector in
	  // dx. We add the rest on the processor that knows about the voronoi diagram.
	  //FOR_I3 send_buf_double[send_disp[rank]*13+9+i] = x_fa[ifa_nbr][i] - x_fa[ifa][i];
	  FOR_I3 send_buf_double[send_disp[rank]*13+9+i] = fa_dup_data_vec[ifa_dup_nbr].x[i] - fa_dup_data_vec[ifa_dup].x[i];
	  // transform the vectors if periodic?...
	  assert(bits == 0);
          // include inv_L_fa
          send_buf_double[send_disp[rank]*13+12] = 1.0/points->delta[icv];
	  ++send_disp[rank];
	}
      }
    }
  }

  // rewind send_disp...
  
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
    
  // and share with recv side...
  
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
  
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
  
  FOR_RANK {
    send_count[rank] *= 4;
    send_disp[rank]  *= 4;
    recv_count[rank] *= 4;
    recv_disp[rank]  *= 4;
  }
  
  int * recv_buf_int = new int[recv_count_sum*4];
  MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
    
  delete[] send_buf_int; 
  
  FOR_RANK {
    // 13 doubles
    send_count[rank] = (send_count[rank]/4)*13;
    send_disp[rank] = (send_disp[rank]/4)*13;
    recv_count[rank] = (recv_count[rank]/4)*13;
    recv_disp[rank] = (recv_disp[rank]/4)*13;
  }
  
  double * recv_buf_double = new double[recv_count_sum*14]; // same argument for sizing as above
  MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  
  // cycle backwards on the recv side to allow repacking of the recv_buf_double
  // from 13 to 14 without overwriting...

  MPI_Sync("before irecv stuff");
    
  for (int irecv = recv_count_sum-1; irecv >= 0; --irecv) {
    
    const int icv = recv_buf_int[irecv*4]; assert((icv >= 0)&&(icv < ncv));
    const uint8 rbi = BitUtils::packRankBitsIndex(recv_buf_int[irecv*4+1],recv_buf_int[irecv*4+2],recv_buf_int[irecv*4+3]);
    // given icv and rbi, find the corresponding nbr including the common face...
    /*
      int ifa = -1,foc;
      for (foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
      ifa = faocv_v[foc];
      const int icv_nbr = cvofa[ifa][1]; // the inter-processor faces will always be outward pointing
      if ((icv_nbr >= ncv)&&(rbi == rbi_g[icv_nbr-ncv])) {
      break;
      }
      }
      assert(foc != faocv_i[icv+1]); // ensure found
      assert(ifa != -1);
    */

    // CI
    int ifa_dup;
    for (ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      if (rbi == fa_dup_data_vec[ifa_dup].rbi_nbr) {
        const int coc = ifa_dup-faocv_dup_i[icv]+1+cvocv_i[icv]; 
        const int icv_nbr = cvocv_v[coc];
        assert((icv_nbr >= ncv)&&(rbi_g[icv_nbr-ncv] == rbi));
        break;
      }
    }
    assert(ifa_dup != faocv_dup_i[icv+1]); // ensure found
    //FOR_I3 assert( fa_dup_data_vec[foc].x[i] == x_fa[ifa][i] );
    
    double e0[3]; FOR_I3 e0[i] = recv_buf_double[irecv*13+i];
    double e1[3]; FOR_I3 e1[i] = recv_buf_double[irecv*13+3+i];
    double e2[3]; FOR_I3 e2[i] = recv_buf_double[irecv*13+6+i];
    // for the dx vector, the recv_buf already has the vector from the reconstruction face 
    // to the common face ifa: we need to add the vector from the common
    // face to the Voronoi point...
    //double dx[3]; FOR_I3 dx[i] = recv_buf_double[irecv*13+9+i] + points->xp[icv][i] - x_fa[ifa][i];
    double dx[3]; FOR_I3 dx[i] = recv_buf_double[irecv*13+9+i] + points->xp[icv][i] - fa_dup_data_vec[ifa_dup].x[i];
    double inv_L_fa = recv_buf_double[irecv*13+12];
    // now we can compute the coeffs directly into the recv_buf...
    //calcQuadratureTerms(recv_buf_double+irecv*14,icv,dx,e0,e1,e2);
    mapCvQuadratureTerms(recv_buf_double+irecv*14,icv,dx,0.5*points->delta[icv],inv_L_fa,e0,e1,e2,coeff_cv[icv]);
  }

  /*
    cout << "rank: " << mpi_rank << " done: " << recv_count_sum << endl;
    cout.flush();
  */
    
  MPI_Sync("after irecv stuff");
    
  delete[] recv_buf_int;
  
  FOR_RANK {
    // 14 doubles  
    send_count[rank] = (send_count[rank]/13)*14;
    send_disp[rank]  = (send_disp[rank]/13)*14;
    recv_count[rank] = (recv_count[rank]/13)*14;
    recv_disp[rank]  = (recv_disp[rank]/13)*14;
  }

  MPI_Alltoallv(recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,
		send_buf_double,send_count,send_disp,MPI_DOUBLE,
		mpi_comm);
    
  delete[] recv_buf_double; recv_buf_double = NULL;
    
  // =================================================
  // data required for the local matrix math...
  // =================================================
    
  double A[5][5],C[3][5];
  double LU[8][8];
  double (*rhs)[8] = new double[coc_max][8];
  double coeff[14];
  const double coeff_zero = getDoubleParam("COEFF_ZERO",1.0E-6); // at what point do we zero the reconstruction coefficients

  vector<Coeff> coeffVec;
  coeffVec.reserve(ncv*28); // can be 5x this or more, but even this helps timing
  
  //
  // the polynomial is centered about the face, and in local face-normal 
  // cordinates with form
  //
  // P(x,y,z) = c5 + c4*x + c3*x*x + c2*y + c1*z
  //
  // and cP,cQ (and cNbr in some cases) are the constraints associated with the 
  // lagrange multipliers
  //
  // the coefficients are reversed to minimize the work required to compute
  // the desired value of c5 during back-substitution in the LU decomposition.
  //
  // we are going to set up the (KKT?) matrix problem:
  //
  // [ A C^T ] [c1,c2,c3,c4,c5,cP,cQ]^T  =  [g] [PP,PQ,Pnbr,...]
  // [ C  0  ]                              [h]
  //

  double (*x_cv)[3] = NULL;
  
  {

    // need a global cv index...
      
    //int8 * cvora = NULL;
    //buildXora(cvora,ncv);
      
    int8 * icv_global_g = new int8[ncv_g-ncv];
    for (int icv_g = 0; icv_g < ncv_g-ncv; ++icv_g) {
      int rank,bits,index;
      BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_g]);
      assert(rank != mpi_rank);
      assert(bits == 0);
      icv_global_g[icv_g] = cvora[rank]+index;
    }
      
    DistributedDataExchanger dde(icv_global_g,ncv_g-ncv,cvora);
    
    x_cv = new double[ncv_g][3];
    for (int icv = 0; icv < ncv; ++icv)
      FOR_I3 x_cv[icv][i] = x_cv_local[icv][i];
    
    dde.pull(x_cv+ncv,x_cv_local);
    
    delete[] icv_global_g;
    //delete[] cvora;
    
  }

  MPI_Sync("about to start loop");
  
  double my_d2_max = 0.0;

  double wtime0 = MPI_Wtime();
  
  for (int icv = 0; icv < ncv; ++icv) {

    // HACK - debug all...
    
    double wtime = MPI_Wtime();
    if (wtime-wtime0 > 10.0) {
      double my_frac = double(icv)/double(ncv);
      double frac_avg;
      MPI_Reduce(&my_frac,&frac_avg,1,MPI_DOUBLE,MPI_SUM,0,mpi_comm);
      double frac_min;
      MPI_Allreduce(&my_frac,&frac_min,1,MPI_DOUBLE,MPI_MIN,mpi_comm);
      if (mpi_rank == 0) {
	cout << " > frac_avg: " << frac_avg/double(mpi_size) << " frac_min: " << frac_min << endl;
      }
      wtime0 = wtime;
    }
    
    //icv_debug = icv;
    
    /*
      if ((mpi_rank == 0)&&(icv%max(ncv/10,1) == 0)) {
      cout << " > " << icv/max(ncv/10,1)*10 << "%" << endl;
      }
    */
    
    // we are building coefficients for this row in the global matrix... 

    const uint8 rbi = BitUtils::packRankBitsIndex(mpi_rank,0,icv);
      
    // just internal faces for now...
      
    for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
      //const int ifa = faocv_v[foc];

      // the nbr cv associated with the face...
      const int icv_fa_nbr = cvocv_v[ifa_dup-faocv_dup_i[icv]+cvocv_i[icv]+1];

      // compute the polynomial basis vectors in the face coodinate system...
      setFaceVectorsPlus(e0,e1,e2,fa_dup_data_vec[ifa_dup].n,1.0/points->delta[icv]);
      /*
	double fa_sign;
	if (cvofa[ifa][0] == icv) {
	fa_sign = 1.0;
	assert(cvofa[ifa][1] == icv_fa_nbr);
	setFaceVectorsPlus(e0,e1,e2,n_fa[ifa],1.0/points->delta[icv]);
	}
	else {
	assert(cvofa[ifa][1] == icv);
	assert(cvofa[ifa][0] == icv_fa_nbr);
	fa_sign = -1.0;
	setFaceVectorsMinus(e0,e1,e2,n_fa[ifa],1.0/points->delta[icv]);
	}
      */
	
      uint8 rbi_fa_nbr;
      if (icv_fa_nbr < ncv) {
	rbi_fa_nbr = BitUtils::packRankBitsIndex(mpi_rank,0,icv_fa_nbr);
      }
      else {
	rbi_fa_nbr = rbi_g[icv_fa_nbr-ncv];
      }

      assert(fa_dup_data_vec[ifa_dup].rbi_nbr == rbi_fa_nbr);
      
      //if (icv == icv_debug) cout << "\n\nworking on icv_debug,ifa: " << ifa << endl;

      // zero A...
      for (int i = 0; i < 5; ++i)
	for (int j = 0; j < 5; ++j)
	  A[i][j] = 0.0;
      
      double wgt0=0.0,wgt1=0.0;
      
      int nc = 2; // number of constraints...
      const int ncoc = cvocv_i[icv+1]-cvocv_i[icv];
      
      // for each face, we are going to build a linear system to compute the reconstruction coefficients...
      for (int coc = 0; coc < ncoc; ++coc) {
	
	const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	if (icv_nbr < ncv) {
	  // this is a local nbr. compute the coeff matrix here...
	  //const double dx[3] = DIFF(points->xp[icv_nbr],x_fa[ifa]);
	  const double dx[3] = DIFF(points->xp[icv_nbr],fa_dup_data_vec[ifa_dup].x);
	  //calcQuadratureTerms(coeff,icv_nbr,dx,e0,e1,e2);
	  mapCvQuadratureTerms(coeff,icv_nbr,dx,0.5*points->delta[icv_nbr],1.0/points->delta[icv],e0,e1,e2,coeff_cv[icv_nbr]);
	}
	else {
	  // this is an inter-processor nbr where the coeff's have been pre-computed and reduced above...
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_nbr-ncv]);
	  assert(rank != mpi_rank);
	  for (int i = 0; i < 14; ++i)
	    coeff[i] = send_buf_double[send_disp[rank]+i]; // send_disp already 14-stride
	  send_disp[rank] += 14;
	  
	  if (icv == icv_debug) cout << "XXXXXX icv_debug has a ghost nbr" << endl;
	  
	}
	
	// top left matrix is A[][]...
	
	const double factor = 2.0E-7*coeff[SW]; // note we include coeff[SW] here to get correct scaling
	
	A[0][0] += factor*coeff[SWZZ];
	A[0][1] += factor*coeff[SWYZ];
	A[0][2] += factor*coeff[SWXXZ];
	A[0][3] += factor*coeff[SWXZ];
	A[0][4] += factor*coeff[SWZ];
	
	A[1][0] += factor*coeff[SWYZ];
	A[1][1] += factor*coeff[SWYY];
	A[1][2] += factor*coeff[SWXXY];
	A[1][3] += factor*coeff[SWXY];
	A[1][4] += factor*coeff[SWY];
	
	A[2][0] += factor*coeff[SWXXZ];
	A[2][1] += factor*coeff[SWXXY];
	A[2][2] += factor*coeff[SWXXXX];
	A[2][3] += factor*coeff[SWXXX];
	A[2][4] += factor*coeff[SWXX];
	  
	A[3][0] += factor*coeff[SWXZ];
	A[3][1] += factor*coeff[SWXY];
	A[3][2] += factor*coeff[SWXXX];
	A[3][3] += factor*coeff[SWXX];
	A[3][4] += factor*coeff[SWX];
	  
	A[4][0] += factor*coeff[SWZ];
	A[4][1] += factor*coeff[SWY];
	A[4][2] += factor*coeff[SWXX];
	A[4][3] += factor*coeff[SWX];
	A[4][4] += factor*coeff[SW];
	  
	// rhs...
	  
	rhs[coc][0] = factor*coeff[SWZ];
	rhs[coc][1] = factor*coeff[SWY];
	rhs[coc][2] = factor*coeff[SWXX];
	rhs[coc][3] = factor*coeff[SWX];
	rhs[coc][4] = factor*coeff[SW];

	// least-squares formulation...
	// different formulation...

	const double factor2 = 2.0; // was 2.0

	A[0][0] += factor2*coeff[SWZ]*coeff[SWZ];
	A[1][0] += factor2*coeff[SWZ]*coeff[SWY];
	A[2][0] += factor2*coeff[SWZ]*coeff[SWXX];
	A[3][0] += factor2*coeff[SWZ]*coeff[SWX];
	A[4][0] += factor2*coeff[SWZ]*coeff[SW];

	A[0][1] += factor2*coeff[SWY]*coeff[SWZ];
	A[1][1] += factor2*coeff[SWY]*coeff[SWY];
	A[2][1] += factor2*coeff[SWY]*coeff[SWXX];
	A[3][1] += factor2*coeff[SWY]*coeff[SWX];
	A[4][1] += factor2*coeff[SWY]*coeff[SW];
	  
	A[0][2] += factor2*coeff[SWXX]*coeff[SWZ];
	A[1][2] += factor2*coeff[SWXX]*coeff[SWY];
	A[2][2] += factor2*coeff[SWXX]*coeff[SWXX];
	A[3][2] += factor2*coeff[SWXX]*coeff[SWX];
	A[4][2] += factor2*coeff[SWXX]*coeff[SW];
	  
	A[0][3] += factor2*coeff[SWX]*coeff[SWZ];
	A[1][3] += factor2*coeff[SWX]*coeff[SWY];
	A[2][3] += factor2*coeff[SWX]*coeff[SWXX];
	A[3][3] += factor2*coeff[SWX]*coeff[SWX];
	A[4][3] += factor2*coeff[SWX]*coeff[SW];
	  
	A[0][4] += factor2*coeff[SW]*coeff[SWZ];
	A[1][4] += factor2*coeff[SW]*coeff[SWY];
	A[2][4] += factor2*coeff[SW]*coeff[SWXX];
	A[3][4] += factor2*coeff[SW]*coeff[SWX];
	A[4][4] += factor2*coeff[SW]*coeff[SW];
	  
	rhs[coc][0] += factor2*coeff[SW]*coeff[SWZ];
	rhs[coc][1] += factor2*coeff[SW]*coeff[SWY];
	rhs[coc][2] += factor2*coeff[SW]*coeff[SWXX];
	rhs[coc][3] += factor2*coeff[SW]*coeff[SWX];
	rhs[coc][4] += factor2*coeff[SW]*coeff[SW];

	if (icv_nbr == icv) {
	    
	  // this is the first constraint -- it is always present...
	    
	  C[0][0] = coeff[SWZ];
	  C[0][1] = coeff[SWY];
	  C[0][2] = coeff[SWXX];
	  C[0][3] = coeff[SWX];
	  C[0][4] = coeff[SW];
	
	  rhs[coc][5] = coeff[SW];
	  rhs[coc][6] = 0.0;
	  rhs[coc][7] = 0.0;

	  // use the projection along e0 to determine one of the
	  // wgt coefficients used to build the face reconstruction...

	  assert(coeff[SWX] < 0.0);
	  assert(wgt0 == 0.0);
	  wgt0 = -coeff[SWX]/coeff[SW];
	
	}
	else if (icv_nbr == icv_fa_nbr) {
	    
	  // this is the second constraint -- it is also always present on 
	  // internal faces...

	  C[1][0] = coeff[SWZ];
	  C[1][1] = coeff[SWY];
	  C[1][2] = coeff[SWXX];
	  C[1][3] = coeff[SWX];
	  C[1][4] = coeff[SW];
	    
	  rhs[coc][5] = 0.0;
	  rhs[coc][6] = coeff[SW];
	  rhs[coc][7] = 0.0;

	  assert(coeff[SWX] > 0.0);
	  assert(wgt1 == 0.0);
	  wgt1 = coeff[SWX]/coeff[SW];
	    
	}
	else {

	  // this is not one of the two automatically constrained nbrs, but 
	  // we should still constrain it if it's centroid is sufficiently along the 
	  // e0 vector...
	    
	  const double dp = -coeff[SWX]/sqrt(coeff[SWX]*coeff[SWX] + coeff[SWY]*coeff[SWY] + coeff[SWZ]*coeff[SWZ]);
	    
	  if (icv == icv_debug) {
	    cout << "other nbr dp: " << dp << endl;
	  }

	  //cout << "HACKHACK hacking additional contrainst" << endl;
	  if (dp > 0.8) { // 0.78? 0.8?
	    //if (true) {
	    //if (false) {
	    
	    const double wgt = 1.0; // use a bump function here in the future....
	      
	    if (nc == 2) {
	      C[2][0] = wgt*coeff[SWZ];
	      C[2][1] = wgt*coeff[SWY];
	      C[2][2] = wgt*coeff[SWXX];
	      C[2][3] = wgt*coeff[SWX];
	      C[2][4] = wgt*coeff[SW];
	      nc = 3;
	    }
	    else {
	      assert(nc == 3);
	      C[2][0] += wgt*coeff[SWZ];
	      C[2][1] += wgt*coeff[SWY];
	      C[2][2] += wgt*coeff[SWXX];
	      C[2][3] += wgt*coeff[SWX];
	      C[2][4] += wgt*coeff[SW];
	    }
	      
	    rhs[coc][5] = 0.0;
	    rhs[coc][6] = 0.0;
	    rhs[coc][7] = wgt*coeff[SW];
	      
	  }
	  else {

	    rhs[coc][5] = 0.0;
	    rhs[coc][6] = 0.0;
	    rhs[coc][7] = 0.0;

	  }
	    
	}

      }
	  
      if (icv == icv_debug) {
	cout << "done coeff build. nc = " << nc << endl;
      }
	
      // matricies are all complete. Now solve the equality-constrained minimization problem...

      // ==============================================================
      // build LU using doolittle's method?...
      // must be a better way that uses Schur Complement... later
      // ==============================================================

      double nonzero_sum = 0.0;
      if (nc == 2) {

	// use linear...

	// remove the quadratic term from the reconstruction polynomial by 
	// eliminating row and col 2 from A and C...
	
	LU[0][0] = A[0][0];
	LU[0][1] = A[0][1];
	LU[0][2] = A[0][3];
	LU[0][3] = A[0][4];
	LU[0][4] = C[0][0];
	LU[0][5] = C[1][0];
	
	assert(LU[0][0] != 0.0);
	LU[1][0] = A[1][0]/LU[0][0];
	LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
	LU[1][2] = A[1][3] - LU[0][2]*LU[1][0];
	LU[1][3] = A[1][4] - LU[0][3]*LU[1][0];
	LU[1][4] = C[0][1] - LU[0][4]*LU[1][0];
	LU[1][5] = C[1][1] - LU[0][5]*LU[1][0];
	
	LU[2][0] = A[3][0]/LU[0][0];
	assert(LU[1][1] != 0.0);
	LU[2][1] = (A[3][1] - LU[0][1]*LU[2][0])/LU[1][1];
	LU[2][2] = A[3][3] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
	LU[2][3] = A[3][4] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
	LU[2][4] = C[0][3] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
	LU[2][5] = C[1][3] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
	
	LU[3][0] = A[4][0]/LU[0][0];
	LU[3][1] = (A[4][1] - LU[0][1]*LU[3][0])/LU[1][1];
	assert(LU[2][2] != 0.0);
	LU[3][2] = (A[4][3] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
	LU[3][3] = A[4][4] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
	LU[3][4] = C[0][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
	LU[3][5] = C[1][4] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];
	
	LU[4][0] = C[0][0]/LU[0][0];
	LU[4][1] = (C[0][1] - LU[0][1]*LU[4][0])/LU[1][1];
	LU[4][2] = (C[0][3] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
	assert(LU[3][3] != 0.0);
	LU[4][3] = (C[0][4] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
	LU[4][4] = - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
	LU[4][5] = - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
	
	LU[5][0] = C[1][0]/LU[0][0];
	LU[5][1] = (C[1][1] - LU[0][1]*LU[5][0])/LU[1][1];
	LU[5][2] = (C[1][3] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
	LU[5][3] = (C[1][4] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
	assert(LU[4][4] != 0.0);
	LU[5][4] = (- LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
	LU[5][5] = - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];
	
	// adjust rhs...
	for (int coc = 0; coc < ncoc; ++coc) {
	  for (int i = 3; i < 5+nc; ++i) {
	    rhs[coc][i-1] = rhs[coc][i];
	  }
	}
	
	double sum = 0.0;
	for (int coc = 0; coc < ncoc; ++coc) {
	  const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	  // overwrite rhs...
	  for (int i = 1; i < 4+nc; ++i) 
	    for (int j = 0; j < i; ++j)
	      rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	  // and back substitute to solve...
	  rhs[coc][4+nc-1] /= LU[4+nc-1][4+nc-1];
	  for (int i = 4+nc-2; i >= 3; --i) {
	    for (int j = i+1; j < 4+nc; ++j)
	      rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	    rhs[coc][i] /= LU[i][i];
	  }
	  // the coeff is in rhs[coc][3]...
	  sum += rhs[coc][3]; 
	  if (fabs(rhs[coc][3]) < coeff_zero) {
	    rhs[coc][3] = 0.0;
	  }
	  else {
	    nonzero_sum += rhs[coc][3];
	  }
	  /*
	    if (icv == icv_debug) {
	    cout << "coc: " << coc << " rhs: " << rhs[coc][3] << " at dx: " << 
	    x_cv[icv_nbr][0]-x_cv[icv][0] << " " << 
	    x_cv[icv_nbr][1]-x_cv[icv][1] << " " << 
	    x_cv[icv_nbr][2]-x_cv[icv][2] << endl;
	    }
	  */
	}
	if (fabs(sum-1.0) > 1.0E-8) {
	  cout << "WARNING: non-zero sum in coeffs (nc == 2): " << sum-1.0 << endl;
	}
	assert(nonzero_sum != 0.0);
	
      }
      else if (nc == 3) {

	LU[0][0] = A[0][0];
	LU[0][1] = A[0][1];
	LU[0][2] = A[0][2];
	LU[0][3] = A[0][3];
	LU[0][4] = A[0][4];
	LU[0][5] = C[0][0];
	LU[0][6] = C[1][0];
	LU[0][7] = C[2][0];
    
	assert(LU[0][0] != 0.0);
	LU[1][0] = A[1][0]/LU[0][0];
	LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
	LU[1][2] = A[1][2] - LU[0][2]*LU[1][0];
	LU[1][3] = A[1][3] - LU[0][3]*LU[1][0];
	LU[1][4] = A[1][4] - LU[0][4]*LU[1][0];
	LU[1][5] = C[0][1] - LU[0][5]*LU[1][0];
	LU[1][6] = C[1][1] - LU[0][6]*LU[1][0];
	LU[1][7] = C[2][1] - LU[0][7]*LU[1][0];
	
	LU[2][0] =  A[2][0]/LU[0][0];
	assert(LU[1][1] != 0.0);
	LU[2][1] = (A[2][1] - LU[0][1]*LU[2][0])/LU[1][1];
	LU[2][2] =  A[2][2] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
	LU[2][3] =  A[2][3] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
	LU[2][4] =  A[2][4] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
	LU[2][5] =  C[0][2] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
	LU[2][6] =  C[1][2] - LU[0][6]*LU[2][0] - LU[1][6]*LU[2][1];
	LU[2][7] =  C[2][2] - LU[0][7]*LU[2][0] - LU[1][7]*LU[2][1];
	
	LU[3][0] =  A[3][0]/LU[0][0];
	LU[3][1] = (A[3][1] - LU[0][1]*LU[3][0])/LU[1][1];
	assert(LU[2][2] != 0.0);
	LU[3][2] = (A[3][2] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
	LU[3][3] =  A[3][3] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
	LU[3][4] =  A[3][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
	LU[3][5] =  C[0][3] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];
	LU[3][6] =  C[1][3] - LU[0][6]*LU[3][0] - LU[1][6]*LU[3][1] - LU[2][6]*LU[3][2];
	LU[3][7] =  C[2][3] - LU[0][7]*LU[3][0] - LU[1][7]*LU[3][1] - LU[2][7]*LU[3][2];
	
	LU[4][0] =  A[4][0]/LU[0][0];
	LU[4][1] = (A[4][1] - LU[0][1]*LU[4][0])/LU[1][1];
	LU[4][2] = (A[4][2] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
	assert(LU[3][3] != 0.0);
	LU[4][3] = (A[4][3] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
	LU[4][4] =  A[4][4] - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
	LU[4][5] =  C[0][4] - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
	LU[4][6] =  C[1][4] - LU[0][6]*LU[4][0] - LU[1][6]*LU[4][1] - LU[2][6]*LU[4][2] - LU[3][6]*LU[4][3];
	LU[4][7] =  C[2][4] - LU[0][7]*LU[4][0] - LU[1][7]*LU[4][1] - LU[2][7]*LU[4][2] - LU[3][7]*LU[4][3];
	
	LU[5][0] =  C[0][0]/LU[0][0];
	LU[5][1] = (C[0][1] - LU[0][1]*LU[5][0])/LU[1][1];
	LU[5][2] = (C[0][2] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
	LU[5][3] = (C[0][3] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
	assert(LU[4][4] != 0.0);
	LU[5][4] = (C[0][4] - LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
	LU[5][5] =          - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];
	LU[5][6] =          - LU[0][6]*LU[5][0] - LU[1][6]*LU[5][1] - LU[2][6]*LU[5][2] - LU[3][6]*LU[5][3] - LU[4][6]*LU[5][4];
	LU[5][7] =          - LU[0][7]*LU[5][0] - LU[1][7]*LU[5][1] - LU[2][7]*LU[5][2] - LU[3][7]*LU[5][3] - LU[4][7]*LU[5][4];
	
	LU[6][0] =  C[1][0]/LU[0][0];
	LU[6][1] = (C[1][1] - LU[0][1]*LU[6][0])/LU[1][1];
	LU[6][2] = (C[1][2] - LU[0][2]*LU[6][0] - LU[1][2]*LU[6][1])/LU[2][2];
	LU[6][3] = (C[1][3] - LU[0][3]*LU[6][0] - LU[1][3]*LU[6][1] - LU[2][3]*LU[6][2])/LU[3][3];
	LU[6][4] = (C[1][4] - LU[0][4]*LU[6][0] - LU[1][4]*LU[6][1] - LU[2][4]*LU[6][2] - LU[3][4]*LU[6][3])/LU[4][4];
	assert(LU[5][5] != 0.0);
	LU[6][5] = (        - LU[0][5]*LU[6][0] - LU[1][5]*LU[6][1] - LU[2][5]*LU[6][2] - LU[3][5]*LU[6][3] - LU[4][5]*LU[6][4])/LU[5][5];
	LU[6][6] =          - LU[0][6]*LU[6][0] - LU[1][6]*LU[6][1] - LU[2][6]*LU[6][2] - LU[3][6]*LU[6][3] - LU[4][6]*LU[6][4] - LU[5][6]*LU[6][5];
	LU[6][7] =          - LU[0][7]*LU[6][0] - LU[1][7]*LU[6][1] - LU[2][7]*LU[6][2] - LU[3][7]*LU[6][3] - LU[4][7]*LU[6][4] - LU[5][7]*LU[6][5];
	  
	LU[7][0] =  C[2][0]/LU[0][0];
	LU[7][1] = (C[2][1] - LU[0][1]*LU[7][0])/LU[1][1];
	LU[7][2] = (C[2][2] - LU[0][2]*LU[7][0] - LU[1][2]*LU[7][1])/LU[2][2];
	LU[7][3] = (C[2][3] - LU[0][3]*LU[7][0] - LU[1][3]*LU[7][1] - LU[2][3]*LU[7][2])/LU[3][3];
	LU[7][4] = (C[2][4] - LU[0][4]*LU[7][0] - LU[1][4]*LU[7][1] - LU[2][4]*LU[7][2] - LU[3][4]*LU[7][3])/LU[4][4];
	LU[7][5] = (        - LU[0][5]*LU[7][0] - LU[1][5]*LU[7][1] - LU[2][5]*LU[7][2] - LU[3][5]*LU[7][3] - LU[4][5]*LU[7][4])/LU[5][5];
	assert(LU[6][6] != 0.0);
	LU[7][6] = (        - LU[0][6]*LU[7][0] - LU[1][6]*LU[7][1] - LU[2][6]*LU[7][2] - LU[3][6]*LU[7][3] - LU[4][6]*LU[7][4] - LU[5][6]*LU[7][5])/LU[6][6];
	LU[7][7] =          - LU[0][7]*LU[7][0] - LU[1][7]*LU[7][1] - LU[2][7]*LU[7][2] - LU[3][7]*LU[7][3] - LU[4][7]*LU[7][4] - LU[5][7]*LU[7][5] - LU[6][7]*LU[7][6];
	assert(LU[7][7] != 0.0);
	  	
	// check...

	for (int i = 0; i < 8; ++i) {
	  for (int j = 0; j < 8; ++j) {
	    double coeff;
	    if (i < 5) {
	      if (j < 5) {
		coeff = A[i][j];
	      }
	      else {
		coeff = C[j-5][i];
	      }
	    }
	    else if (j < 5) {
	      coeff = C[i-5][j];
	    }
	    else {
	      coeff = 0.0;
	    }
	    // now compute the L*U...
	    {
	      double l[8];
	      for (int k = 0; k < i; ++k) l[k] = LU[i][k];
	      l[i] = 1.0;
	      for (int k = i+1; k < 8; ++k) l[k] = 0.0;
	      double u[8];
	      for (int k = 0; k <= j; ++k) u[k] = LU[k][j];
	      for (int k = j+1; k < 8; ++k) u[k] = 0.0;
	      double sum = 0.0;
	      for (int k = 0; k < 8; ++k) sum += l[k]*u[k];
	      //cout << coeff-sum << " ";
	      if (!(fabs(coeff-sum) < 1.0E-12)) {
		cout << "WARNING: LU problem: " << coeff-sum << endl;
	      }
	      //assert(fabs(coeff-sum) < 1.0E-12);
	    }
	  }
	  //cout << endl;
	}
	//cout << "was this matrix zero?" << endl;
	//getchar();

	double sum = 0.0;
	for (int coc = 0; coc < ncoc; ++coc) {
	  const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	  // overwrite rhs...
	  for (int i = 1; i < 5+nc; ++i) 
	    for (int j = 0; j < i; ++j)
	      rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	  // and back substitute to solve...
	  rhs[coc][5+nc-1] /= LU[5+nc-1][5+nc-1];
	  for (int i = 5+nc-2; i >= 4; --i) {
	    for (int j = i+1; j < 5+nc; ++j)
	      rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	    rhs[coc][i] /= LU[i][i];
	  }
	  // the coeff is in rhs[coc][4]...
	  sum += rhs[coc][4]; 
	  if (fabs(rhs[coc][4]) < coeff_zero) {
	    rhs[coc][4] = 0.0;
	  }
	  else {
	    nonzero_sum += rhs[coc][4];
	  }
	  /*
	    if (icv == icv_debug) {
	    cout << "coc: " << coc << " rhs: " << rhs[coc][4] << " at dx: " << 
	    x_cv[icv_nbr][0]-x_cv[icv][0] << " " << 
	    x_cv[icv_nbr][1]-x_cv[icv][1] << " " << 
	    x_cv[icv_nbr][2]-x_cv[icv][2] << endl;
	    }
	  */
	}
	if (fabs(sum-1.0) > 1.0E-8) {
	  cout << "WARNING: non-zero sum in coeffs (nc == 3): " << sum-1.0 << endl;
	}
	assert(nonzero_sum != 0.0);
	
      }
      else {
	// nc == 2 or nc == 3 only
	assert(0);
      }

      // =========================================
      // now build the coeff's...
      // =========================================

      if (icv == icv_debug) {
	cout << "got nc: " << nc << endl;
      }

      assert(wgt0 > 0.0);
      assert(wgt1 > 0.0);

      //assert(mpi_size == 1);

      double x_check[3] = { 0.0, 0.0, 0.0 };
	
      for (int coc = 0; coc < ncoc; ++coc) {
	if (rhs[coc][nc+1] != 0.0) { // 3 or 4
	  const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	  assert(icv_nbr < ncv_g);
	  FOR_I3 x_check[i] += rhs[coc][nc+1]/nonzero_sum*x_cv[icv_nbr][i];
	}
      }
      
      // compare x_check and fa[ifa].x...
      //my_d2_max = max(my_d2_max,DIST2(x_check,x_fa[ifa]));
      my_d2_max = max(my_d2_max,DIST2(x_check,fa_dup_data_vec[ifa_dup].x));
      
      // the weighting associated with this face is motivated by the
      // optimal higher-order weight from the 1-d problem of:
      // (dxR+dxRR)/(dxLL+dxL+dxR+dxRR)
      // note that we clip it to the range 0.25..0.75. In the future
      // we may want to do something with this wgt to minimize symmetry.

      //const double wgt = max(0.25,min(0.75,wgt1/(wgt0+wgt1)));
      const double wgt = max(0.25,min(0.75,wgt0/(wgt0+wgt1))); // SB/FH HACK
      //const double wgt = 0.5;

      for (int coc = 0; coc < ncoc; ++coc) {
	if (rhs[coc][nc+1] != 0.0) {
	  const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];

	  uint8 rbi_nbr;
	  if (icv_nbr < ncv) {
	    rbi_nbr = BitUtils::packRankBitsIndex(mpi_rank,0,icv_nbr);
	  }
	  else {
	    rbi_nbr = rbi_g[icv_nbr-ncv];
	  }

	  if (coc == 0) {
	    assert( icv_nbr == icv );
	    //rbi_nbr = BitUtils::packRankBitsIndex(mpi_rank,0,icv);
	  }
	  else {
	    const int ifa_dup_nbr = faocv_dup_i[icv]+coc-1;
	    assert(fa_dup_data_vec[ifa_dup_nbr].rbi_nbr == rbi_nbr);
	  }
	  
	  double coeff[3];
	  //FOR_I3 coeff[i] = rhs[coc][nc+1]/nonzero_sum*wgt*fa_sign*n_fa[ifa][i];
	  FOR_I3 coeff[i] = rhs[coc][nc+1]/nonzero_sum*wgt*fa_dup_data_vec[ifa_dup].n[i];
	  coeffVec.push_back(Coeff(rbi,rbi_nbr,coeff));
	  FOR_I3 coeff[i] = -coeff[i];
	  coeffVec.push_back(Coeff(rbi_fa_nbr,rbi_nbr,coeff));
	  
	}
      }

    } // face loop
  } // icv loop

  // cleanup...
  delete[] rbi_g;
  delete[] coeff_cv;
  delete[] cvocv_i;
  delete[] cvocv_v;
  
  {
    double my_frac = 1.0;
    double frac_min = 0.0;
    while (frac_min != 1.0) {
      double frac_avg;
      MPI_Reduce(&my_frac,&frac_avg,1,MPI_DOUBLE,MPI_SUM,0,mpi_comm);
      MPI_Allreduce(&my_frac,&frac_min,1,MPI_DOUBLE,MPI_MIN,mpi_comm);
      if (mpi_rank == 0) {
	cout << " > frac_avg: " << frac_avg/double(mpi_size) << " frac_min: " << frac_min << endl;
      }
    }
  }
  
  /*
    cout << "rank: " << mpi_rank << " done. coeffVec.size(): " << coeffVec.size() << endl;
    cout.flush();
  */

  double d2_max;
  MPI_Reduce(&my_d2_max,&d2_max,1,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
  if (mpi_rank == 0) cout << " max dist of reconstructed face centroid to actual face centriod (should be small): " << sqrt(d2_max) << endl;
  
  delete[] rhs;
  delete[] send_buf_double; send_buf_double = NULL;

  MPI_Sync("about to sort");

  sort(coeffVec.begin(),coeffVec.end());

  // compress...
  // TODO: eliminate diagonal elements...
    
  int nii_new = 0;
  for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
    assert(!coeffVec[ii].transpose);
    if ((nii_new == 0)||(coeffVec[ii].rbi != coeffVec[nii_new-1].rbi)||(coeffVec[ii].rbi_nbr != coeffVec[nii_new-1].rbi_nbr)) {
      coeffVec[nii_new].rbi     = coeffVec[ii].rbi;
      coeffVec[nii_new].rbi_nbr = coeffVec[ii].rbi_nbr;
      FOR_I3 coeffVec[nii_new].coeff[i] = coeffVec[ii].coeff[i];
      ++nii_new;
    }
    else {
      FOR_I3 coeffVec[nii_new-1].coeff[i] += coeffVec[ii].coeff[i];
    }
  }

  MPI_Sync("done sort and compress");
  
  //cout << "compare coeffVec.size(): " << coeffVec.size() << " to compressed size: " << nii_new << endl;
  
  // ==============================================
  // hack -- check serial gradient...
  // ==============================================
    
  if (mpi_size == 1) {

    assert(mpi_size == 1);
    assert(ncv_g == ncv);
    //assert(ncv_g2 == ncv);

    const double exact_grad[3] = { 1.123, 2.134, -1.3423 };
    //const double exact_grad[3] = { 1.1234, -1.3243, 1.5321 }; // some order-1 gradient
    //const double exact_grad[3] = { 1.0, 1.0, 1.0 }; 
    
    double * phi = new double[ncv];
    for (int icv = 0; icv < ncv; ++icv) 
      phi[icv] = DOT_PRODUCT(x_cv[icv],exact_grad);
    
    double (*grad_phi)[3] = new double[ncv][3];
    FOR_ICV FOR_I3 grad_phi[icv][i] = 0.0;

    for (int ii = 0; ii < nii_new; ++ii) {
      int rank,bits,index;
      BitUtils::unpackRankBitsIndex(rank,bits,index,coeffVec[ii].rbi);
      assert(bits == 0);
      assert(rank == mpi_rank);
      int rank_nbr,bits_nbr,index_nbr;
      BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,index_nbr,coeffVec[ii].rbi_nbr);
      assert(bits_nbr == 0);
      assert(rank_nbr == mpi_rank);
      FOR_I3 grad_phi[index][i] += coeffVec[ii].coeff[i]*phi[index_nbr];
    }

    FOR_ICV {
      for (int ibf = bfocv_i[icv]; ibf != bfocv_i[icv+1]; ++ibf) {
	double x_bf[3]; FOR_I3 x_bf[i] = points->xp[icv][i] + bf_data_vec[ibf].x[i];
	const double phi = DOT_PRODUCT(exact_grad,x_bf);
	FOR_I3 grad_phi[icv][i] += phi*bf_data_vec[ibf].n[i];
      }
    }

    for (int icv = 0; icv < ncv; ++icv) {
      FOR_I3 grad_phi[icv][i] = grad_phi[icv][i]/(vol_cv[icv]*exact_grad[i]) - 1.0; // to produce 0
    }
    
    dumpRange(grad_phi,ncv,"extended grad");
    
    delete[] grad_phi;
    delete[] phi;
      
    //MPI_Pause("OKOK");
    
  }
  
  // transpose elements in the lower-triagular part of D...

  for (int ii=0; ii < nii_new;  ++ii) {
    if (coeffVec[ii].rbi > coeffVec[ii].rbi_nbr) {
      uint8 rbi = coeffVec[ii].rbi;
      coeffVec[ii].rbi = coeffVec[ii].rbi_nbr;
      coeffVec[ii].rbi_nbr = rbi;
      coeffVec[ii].transpose = true;
    } 
  }
    
  // now exchange parallel parts...

  FOR_RANK send_count[rank] = 0;
  
  for (int ii=0; ii < nii_new;  ++ii) {
    int rank,bits,icv;
    BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
    if (rank != mpi_rank)
      ++send_count[rank];
  }
    
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_disp[rank-1] + send_count[rank-1];
  send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
    
  uint8 * send_buf_uint8 = new uint8[send_count_sum*2];
  assert(send_buf_double == NULL); send_buf_double = new double[send_count_sum*3];
    
  int ii_new = 0;
  for (int ii=0; ii < nii_new;  ++ii) {
    int rank,bits,icv;
    BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
    assert(bits == 0);
    if (rank != mpi_rank) {
      // since the row's bits are ALWAYS zero, use them to store the transpose bool... 
      if (coeffVec[ii].transpose) 
	send_buf_uint8[send_disp[rank]*2  ] = BitUtils::packRankBitsIndex(rank,1,icv);
      else
	send_buf_uint8[send_disp[rank]*2  ] = coeffVec[ii].rbi;
      // and the column...
      send_buf_uint8[send_disp[rank]*2+1] = coeffVec[ii].rbi_nbr;
      // and the coeff...
      FOR_I3 send_buf_double[send_disp[rank]*3+i] = coeffVec[ii].coeff[i];
      ++send_disp[rank];
    }
    else {
      // already on the right rank...
      if (ii_new != ii) coeffVec[ii_new].copy(coeffVec[ii]);
      ++ii_new;
    }
  }
  
  // rewind send_disp...
  
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_disp[rank-1] + send_count[rank-1];
    
  // setup recv side...
  
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
    
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
    
  coeffVec.resize(ii_new+recv_count_sum);
    
  FOR_RANK {
    send_count[rank] *= 2;
    send_disp[rank] *= 2;
    recv_count[rank] *= 2;
    recv_disp[rank] *= 2;
  }
    
  uint8 * recv_buf_uint8 = new uint8[recv_count_sum*2];
  MPI_Alltoallv(send_buf_uint8,send_count,send_disp,MPI_UINT8,
		recv_buf_uint8,recv_count,recv_disp,MPI_UINT8,mpi_comm);
  delete[] send_buf_uint8; 
  
  FOR_RANK {
    send_count[rank] = (send_count[rank]/2)*3;
    send_disp[rank]  = (send_disp[rank]/2)*3;
    recv_count[rank] = (recv_count[rank]/2)*3;
    recv_disp[rank]  = (recv_disp[rank]/2)*3;
  }
  
  assert(recv_buf_double == NULL); recv_buf_double = new double[recv_count_sum*3];
  MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  delete[] send_buf_double;
  
  // unpack...
    
  for (int irecv = 0; irecv < recv_count_sum; ++irecv) {
    int rank,bits,icv;
    BitUtils::unpackRankBitsIndex(rank,bits,icv,recv_buf_uint8[irecv*2]);
    assert(rank == mpi_rank);
    if (bits == 1) {
      coeffVec[ii_new].rbi = BitUtils::packRankBitsIndex(rank,0,icv); 
      coeffVec[ii_new].transpose = true;
    }
    else {
      assert(bits == 0);
      coeffVec[ii_new].rbi = recv_buf_uint8[irecv*2];
      coeffVec[ii_new].transpose = false;
    }
    // and the nbr...
    coeffVec[ii_new].rbi_nbr = recv_buf_uint8[irecv*2+1];
    // and the coeff...
    FOR_I3 coeffVec[ii_new].coeff[i] = recv_buf_double[irecv*3+i];
    ++ii_new;
  }

  assert(ii_new == coeffVec.size());
  delete[] recv_buf_double;
  delete[] recv_buf_uint8;
  
  delete[] recv_disp;
  delete[] recv_count;
  delete[] send_disp;
  delete[] send_count;
  
  // final sort...
  
  sort(coeffVec.begin(),coeffVec.end());
  
  // now build HO faces [0:nfa_e)...
  // first count...
  
  int nfa_i2 = 0;
  int nfa_ip2 = 0;    
  uint8 rbi_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv); // does not exist
  uint8 rbi_nbr_current = rbi_current;
  int ncv_check = 0;
  int icv;
  for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
    if (coeffVec[ii].rbi != rbi_current) {
      rbi_current = coeffVec[ii].rbi;
      int rank,bits;
      BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
      assert(rank == mpi_rank);
      assert(bits == 0);
      assert(icv == ncv_check); // because of sort, should be monotonic in icv
      ++ncv_check;
      rbi_nbr_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv); // does not exist
    }
    if (coeffVec[ii].rbi != coeffVec[ii].rbi_nbr) {
      if (coeffVec[ii].rbi_nbr != rbi_nbr_current) {
	rbi_nbr_current = coeffVec[ii].rbi_nbr;
	int rank_nbr,bits_nbr,icv_nbr;
	BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,icv_nbr,coeffVec[ii].rbi_nbr);
	assert(bits_nbr == 0);
	if (rank_nbr == mpi_rank) {
	  // local...
	  // only count a new internal face when its index is larger than ours...
	  assert(icv_nbr != icv);
	  if (icv_nbr > icv)
	    ++nfa_i2;
	}
	else if (mpi_rank < rank_nbr) {
	  ++nfa_ip2;
	}
      }
    }
  }
  assert(ncv_check == ncv);
  
  assert(nfa_e == 0);
  nfa_e = nfa_i2+nfa_ip2;
    
  assert(fa_e == NULL); fa_e = new ExtendedFace[nfa_e];

  nfa_ip2 = nfa_i2;
  nfa_i2 = 0;
  int ifa2;
  rbi_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv); // does not exist
  rbi_nbr_current = rbi_current;
  ncv_check = 0;
  for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
    if (coeffVec[ii].rbi != rbi_current) {
      rbi_current = coeffVec[ii].rbi;
      int rank,bits;
      BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
      assert(rank == mpi_rank);
      assert(bits == 0);
      assert(icv == ncv_check); // because of sort, should be monotonic in icv
      ++ncv_check;
      rbi_nbr_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv); // does not exist
    }
    if (coeffVec[ii].rbi != coeffVec[ii].rbi_nbr) {
      // off-diagonal coeff...
      if (coeffVec[ii].rbi_nbr != rbi_nbr_current) {
	rbi_nbr_current = coeffVec[ii].rbi_nbr;
	int rank_nbr,bits_nbr,icv_nbr;
	BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,icv_nbr,coeffVec[ii].rbi_nbr);
	assert(bits_nbr == 0);
	if (rank_nbr == mpi_rank) {
	  // only count a new internal face when its index is larger than ours...
	  assert(icv_nbr != icv);
	  if (icv_nbr > icv) {
	    // this is a new face...
	    ifa2 = nfa_i2++;
	    assert(fa_e[ifa2].cvofa_global[0] == -1);
	    assert(fa_e[ifa2].cvofa_global[1] == -1);
	    fa_e[ifa2].cvofa_global[0] = cvora[mpi_rank] + icv;
	    fa_e[ifa2].cvofa_global[1] = cvora[mpi_rank] + icv_nbr;
	  }
	  else {
	    ifa2 = -1;
	  }
	}
	else if (mpi_rank < rank_nbr) {
	  // this is always a new outward-pointing face...
	  ifa2 = nfa_ip2++;
	  fa_e[ifa2].cvofa_global[0] = cvora[mpi_rank] + icv;
	  fa_e[ifa2].cvofa_global[1] = cvora[rank_nbr] + icv_nbr;
	}
	else {
	  assert(mpi_rank > rank_nbr);
	  ifa2 = -1;
	}
      }
      
      // ---------------------------------------------------------------
      // we should have ifa2 and fa2_sign set...
      // 0.5*(D-DT) goes in unit_n (area-weighted normal for now)...
      // ---------------------------------------------------------------
      if (ifa2 >= 0) {
        if (coeffVec[ii].transpose) {
    	  FOR_I3 fa_e[ifa2].n[i] -= coeffVec[ii].coeff[i];
        }
        else {
 	  FOR_I3 fa_e[ifa2].n[i] += coeffVec[ii].coeff[i];
        }
        // 0.5*(D+DT) goes in c[i] 
        FOR_I3 fa_e[ifa2].c[i] += coeffVec[ii].coeff[i];
      }
      
    }
    
  }

  assert(ncv_check == ncv);
  assert(nfa_ip2 == nfa_e);
  
  // ==================================================================
  // now group identical faces...
  // ==================================================================

  groupExtendedFaces(fa_e,nfa_e);

  // serial sanity check...
 
  if (mpi_size == 1) {
    
    const double exact_grad[3] = { 1.123, 2.134, -1.3423 };
    
    double * phi = new double[ncv];
    for (int icv = 0; icv < ncv; ++icv) 
      phi[icv] = DOT_PRODUCT(x_cv[icv],exact_grad);
    
    double (*grad_phi)[3] = new double[ncv][3];
    FOR_ICV FOR_I3 grad_phi[icv][i] = 0.0;
    
    for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
      const int icv0 = fa_e[ifa2].cvofa_global[0]; assert((icv0 >= 0)&&(icv0 < ncv));
      const int icv1 = fa_e[ifa2].cvofa_global[1]; assert((icv1 >= 0)&&(icv1 < ncv));
      double flux[3];	FOR_I3 flux[i] = 0.5*fa_e[ifa2].n[i]*(phi[icv0]+phi[icv1]) + 0.5*fa_e[ifa2].c[i]*(phi[icv1]-phi[icv0]);
      FOR_I3 grad_phi[icv0][i] += flux[i];
      FOR_I3 grad_phi[icv1][i] -= flux[i];
    }
    
    for (int ifa2 = nfa_i2; ifa2 < nfa_e; ++ifa2) {
      assert(0);
      /*
	const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
	const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
	double flux[3];	FOR_I3 flux[i] = 0.5*fa2[ifa2].area*fa2[ifa2].unit_n[i]*(phi[icv0]+phi[icv1]) + 0.5*fa2[ifa2].c[i]*(phi[icv1]-phi[icv0]);
	FOR_I3 grad_phi[icv0][i] += flux[i];
      */
    }
    
    // and close the gradient at the boundary...
    
    FOR_ICV {
      for (int ibf = bfocv_i[icv]; ibf != bfocv_i[icv+1]; ++ibf) {
	double x_bf[3]; FOR_I3 x_bf[i] = points->xp[icv][i] + bf_data_vec[ibf].x[i];
	const double phi = DOT_PRODUCT(exact_grad,x_bf);
	FOR_I3 grad_phi[icv][i] += phi*bf_data_vec[ibf].n[i];
      }
    }
    
    for (int icv = 0; icv < ncv; ++icv) {
      FOR_I3 grad_phi[icv][i] = grad_phi[icv][i]/(vol_cv[icv]*exact_grad[i]) - 1.0; // to produce 0
    }
    
    dumpRange(grad_phi,ncv,"extended grad - n and c");

    /*
      FILE * fp = fopen("grad.dat","w");
      FOR_ICV {
      fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
      x_cv[icv][0],x_cv[icv][1],x_cv[icv][2],
      grad_phi[icv][0],grad_phi[icv][1],grad_phi[icv][2]);
      }
      fclose(fp);
    */

    delete[] grad_phi;
    delete[] phi;
    
  }

  delete[] x_cv;

  // compute the normal magnitude

  {

    int8 my_count[4] = { nfa_e, 0, 0, 0 };
    
    for (int ifa2 = 0; ifa2 < nfa_e; ++ifa2) {
      const int icv0 = fa_e[ifa2].cvofa_global[0]-cvora[mpi_rank]; assert((icv0 >= 0)&&(icv0 < ncv));
      const double delta = points->delta[icv];
      const double n_mag2 = DOT_PRODUCT(fa_e[ifa2].n,fa_e[ifa2].n);
      const double c_mag2 = DOT_PRODUCT(fa_e[ifa2].c,fa_e[ifa2].c);
      bool n_mag2_zero = false;
      if (n_mag2 < 1.0E-10*delta*delta*delta*delta) {
	my_count[1] += 1;
	n_mag2_zero = true;
      }
      if (c_mag2 < 1.0E-10*delta*delta*delta*delta) {
	my_count[2] += 1;
	if (n_mag2_zero)
	  my_count[3] += 1;
      }
    }
    int8 count[4];
    MPI_Reduce(my_count,count,4,MPI_INT8,MPI_SUM,0,mpi_comm);
    if (mpi_rank == 0) {
      cout << " total ext faces: " << count[0] << " zero n: " << count[1] << " zero c: " << count[2] << " both: " << count[3] << endl;
    }
    
  }

  // HACK to look at faces of a particular cv...
  
  if (checkParam("WRITE_MIDDLE_VD")) {

    const double hcp_delta = getDoubleParam("HCP_DELTA");
    
    double xp[3] = { 0.00001, 0.000001, 0.000001 };
    const int icv = getClosestPoint(xp,points->xp,points->np);
    int8 my_icv_global = -1;
    if (icv >= 0) {
      cout << "XXXXXXX: found requested icv on rank: " << mpi_rank << " vol_cv[icv]: " << vol_cv[icv] << endl;
      
      for (int ifa_dup = faocv_dup_i[icv]; ifa_dup != faocv_dup_i[icv+1]; ++ifa_dup) {
	double dist = 2.0*MAG(fa_dup_data_vec[ifa_dup].x);
	cout << "got nbr dist: " << dist << " dist/hcp_delta: " << dist/hcp_delta << endl;
      }

      writeFullCvTecplot(icv,points->xp[icv]);
      my_icv_global = cvora[mpi_rank] + icv;
    }
    int8 icv_global;
    MPI_Allreduce(&my_icv_global,&icv_global,1,MPI_INT8,MPI_MAX,mpi_comm);
    
    // now loop on faces and look for match...
    
    double my_min_max[2] = { 1.0E+20, 1.0E+20 };
    int my_count = 0;
    FILE * fp;

    if (mpi_rank == 0) {
      fp = fopen("nbr.dat","w");
    }
    else {
      int dummy;
      MPI_Status status;
      MPI_Recv(&dummy,1,MPI_INT,mpi_rank-1,1234,mpi_comm,&status);
      fp = fopen("nbr.dat","a");
    }

    const double hcp_delta2 = hcp_delta*hcp_delta;
    
    for (int ifa2 = 0; ifa2 < nfa_e; ++ifa2) {
      if (fa_e[ifa2].cvofa_global[0] == icv_global) {
	fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
		fa_e[ifa2].n[0]/hcp_delta2,fa_e[ifa2].n[1]/hcp_delta2,fa_e[ifa2].n[2]/hcp_delta2,
		fa_e[ifa2].c[0]/hcp_delta2,fa_e[ifa2].c[1]/hcp_delta2,fa_e[ifa2].c[2]/hcp_delta2);
	
	//const double n_mag2 = DOT_PRODUCT(fa_e[ifa2].n,fa_e[ifa2].n);
	//const double c_mag2 = DOT_PRODUCT(fa_e[ifa2].c,fa_e[ifa2].c);
	//cout << " c_mag2/n_mag2: " << c_mag2/n_mag2 << endl;
	
	const double nmag = MAG(fa_e[ifa2].n);
	my_min_max[0] = min(my_min_max[0],nmag);
	my_min_max[1] = min(my_min_max[1],-nmag);
	++my_count;
      }
      else if (fa_e[ifa2].cvofa_global[1] == icv_global) {
	double n_minus[3]; FOR_I3 n_minus[i] = -fa_e[ifa2].n[i];
	double c_minus[3]; FOR_I3 c_minus[i] = -fa_e[ifa2].c[i];
	fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
		n_minus[0]/hcp_delta2,n_minus[1]/hcp_delta2,n_minus[2]/hcp_delta2,
		c_minus[0]/hcp_delta2,c_minus[1]/hcp_delta2,c_minus[2]/hcp_delta2);


	//const double n_mag2 = DOT_PRODUCT(fa_e[ifa2].n,fa_e[ifa2].n);
	//const double c_mag2 = DOT_PRODUCT(fa_e[ifa2].c,fa_e[ifa2].c);
	//cout << " c_mag2/n_mag2: " << c_mag2/n_mag2 << endl;

	const double nmag = MAG(fa_e[ifa2].n);
	my_min_max[0] = min(my_min_max[0],nmag);
	my_min_max[1] = min(my_min_max[1],-nmag);
	++my_count;
      }
    }
    
    fclose(fp);
    
    if ( mpi_rank < mpi_size-1 ) {
      int dummy = 1;
      MPI_Send(&dummy,1,MPI_INT,mpi_rank+1,1234,mpi_comm);
    }
    
    int count;
    MPI_Reduce(&my_count,&count,1,MPI_INT,MPI_SUM,0,mpi_comm);

    double min_max[2];
    MPI_Reduce(my_min_max,min_max,2,MPI_DOUBLE,MPI_MIN,0,mpi_comm);
    if (mpi_rank == 0) cout << " > XXXXXXXXXX wrote nbr.dat file for n and c, face nbr count: " << count << " min/max area ratio: " << -min_max[0]/min_max[1] << endl;
    
  }

    
  {
    // recall compact faces were build on both sides of 
    // an interprocessor boundary to support operators. Extended faces are 
    // unique...
    int8 my_count[3] = { ncv, nfa_i*2+nfa-nfa_i, nfa_e };
    int8 count[3];
    MPI_Reduce(my_count,count,3,MPI_INT8,MPI_SUM,0,mpi_comm);
    if (mpi_rank == 0) {
      assert(count[1]%2 == 0);
      cout << " > global ncv: " << count[0] << 
	" nfa: " << count[1]/2 << 
	" nfa/ncv: " << double(count[1]/2)/double(count[0]) << 
	" nfa_e: " << count[2] << 
	" nfa_e/ncv: " << double(count[2])/double(count[0]) << 
	" nfa_e/nfa: " << double(count[2])/double(count[1]/2) << endl; 
    }
  }
  
}

/*
void VoronoiPart::buildExtendedFaces2(ExtendedFace*& fa_e,int& nfa_e,
				      double * vol_cv,double (*x_cv_local)[3],int8 * cvora,
				      const vector<BfData>& bf_data_vec,int * bfocv_i,vector<FaData>& fa_dup_data_vec,int * faocv_dup_i) const {
*/

#include "undef_coeff.hpp"

void VoronoiPart::setFaceVectorsPlus(double e0[3],double e1[3],double e2[3],const double n_fa[3],const double inv_L) const {

  // we want to produce a normalization that leads to O(1) values for
  // the coordinate points used in integrations/quadrature, so divide the unit normal
  // by a characteristic length scale. Here we use the points->delta, 
  
  double mag = MAG(n_fa);
  assert(mag > 0.0);
  
  FOR_I3 e0[i] = n_fa[i]*inv_L/mag;
  
  if (fabs(e0[0]) <= min(fabs(e0[1]),fabs(e0[2]))) {
    // the x-direction of the normal is the smallest, so use [1,0,0] to cross the 
    // normal and produce e1...
    e1[0] = 0.0;
    e1[1] = e0[2];
    e1[2] = -e0[1];
  }
  else if (fabs(e0[1]) <= fabs(e0[2])) {
    // the y-direction of the normal is the smallest, so use [0,1,0] to cross the 
    // normal and produce e1...
    e1[0] = -e0[2];
    e1[1] = 0.0;
    e1[2] = e0[0];
  }
  else {
    // the z-direction of the normal is the smallest, so use [0,0,1] to cross the 
    // normal and produce e1...
    e1[0] = e0[1];
    e1[1] = -e0[0];
    e1[2] = 0.0;
  }
  mag = MAG(e1);
  FOR_I3 e1[i] *= inv_L/mag;
  
  // note e0 and e1 are already orthogonal and of mag inv_L, so the
  // cross will have mag inv_L**2, so just divide out inv_L once...
  
  const double e2_[3] = CROSS_PRODUCT(e0,e1);
  FOR_I3 e2[i] = e2_[i]/inv_L;
  
}

void VoronoiPart::setFaceVectorsMinus(double e0[3],double e1[3],double e2[3],const double n_fa[3],const double inv_L) const {
  
  // we want to produce a normalization that leads to O(1) values for
  // the coordinate points used in integrations/quadrature, so divide the unit normal
  // by a characteristic length scale. Here we use the points->delta, 
  
  double mag = MAG(n_fa);
  assert(mag > 0.0);
  
  FOR_I3 e0[i] = -n_fa[i]*inv_L/mag;
  
  if (fabs(e0[0]) <= min(fabs(e0[1]),fabs(e0[2]))) {
    // the x-direction of the normal is the smallest, so use [1,0,0] to cross the 
    // normal and produce e1...
    e1[0] = 0.0;
    e1[1] = e0[2];
    e1[2] = -e0[1];
  }
  else if (fabs(e0[1]) <= fabs(e0[2])) {
    // the y-direction of the normal is the smallest, so use [0,1,0] to cross the 
    // normal and produce e1...
    e1[0] = -e0[2];
    e1[1] = 0.0;
    e1[2] = e0[0];
  }
  else {
    // the z-direction of the normal is the smallest, so use [0,0,1] to cross the 
    // normal and produce e1...
    e1[0] = e0[1];
    e1[1] = -e0[0];
    e1[2] = 0.0;
  }
  mag = MAG(e1);
  FOR_I3 e1[i] *= inv_L/mag;
  
  // note e0 and e1 are already orthogonal and of mag inv_L, so the
  // cross will have mag inv_L**2, so just divide out inv_L once...
  
  const double e2_[3] = CROSS_PRODUCT(e0,e1);
  FOR_I3 e2[i] = e2_[i]/inv_L;
  
}




class Coeff {
public:
  uint8 rbi,rbi_nbr;
  double coeff[3];
  bool transpose;
  Coeff() {
    transpose = false;
  }
  Coeff(const uint8 rbi,const uint8 rbi_nbr,const double coeff[3]) {
    this->rbi = rbi;
    this->rbi_nbr = rbi_nbr;
    this->coeff[0] = coeff[0];
    this->coeff[1] = coeff[1];
    this->coeff[2] = coeff[2];
    transpose = false;
  }
  void copy(const Coeff& other) {
    rbi       = other.rbi;
    rbi_nbr   = other.rbi_nbr;
    coeff[0]  = other.coeff[0];
    coeff[1]  = other.coeff[1];
    coeff[2]  = other.coeff[2];
    transpose = other.transpose;
  }
  bool operator<(const Coeff& other) const { 
    return (rbi < other.rbi)||((rbi == other.rbi)&&(rbi_nbr < other.rbi_nbr)); 
  }
};



#define SW 0

#define SWX 1
#define SWY 2
#define SWZ 3

#define SWXX 4
#define SWXY 5
#define SWXZ 6
#define SWYY 7
#define SWYZ 8
#define SWZZ 9

#define SWXXX 10
#define SWXXY 11
#define SWXXZ 12

#define SWXXXX 13

// these terms are part of the "full" coeff's... 

#define SWXYY 14
#define SWXYZ 15
#define SWXZZ 16
#define SWYYY 17
#define SWYYZ 18
#define SWYZZ 19
#define SWZZZ 20

#define SWXXXY 21
#define SWXXXZ 22
#define SWXXYY 23
#define SWXXYZ 24
#define SWXXZZ 25
#define SWXYYY 26
#define SWXYYZ 27
#define SWXYZZ 28
#define SWXZZZ 29
#define SWYYYY 30
#define SWYYYZ 31
#define SWYYZZ 32
#define SWYZZZ 33
#define SWZZZZ 34




void VoronoiPart::calcAllQuadratureTerms(double * coeff,const double scale_factor,const int ip) const {
  
  assert((ip >= 0)&&(ip < points->np));
  
  for (int i = 0; i < 35; ++i) coeff[i] = 0.0;
  
  vector<double*> xVec;
  map<const pair<int,int>,int> internalFaceMap;
  map<const int,int> boundaryFaceMap;
  
  // the common coordinate for all tets involved in the integration is the passed dx,
  // which should be the vector FROM the face where the reconstruction is desired TO
  // the voronoi forming point, which is (0,0,0) in the local coords...
  double xp[4][3];
  xp[0][0] = 0.0;
  xp[0][1] = 0.0;
  xp[0][2] = 0.0;
  
  for (int ied = 0; ied < vdArray[ip].getNedMain(); ++ied) {
    FOR_I2 {
      const int ifa = vdArray[ip].getFaoed(ied,i);
      if (ifa < 0) {
	// this is an internal face (recall vdArray[ip] uses -1 indexing for faces)...
	assert((-ifa-1 >= 0)&&(-ifa-1 < vdArray[ip].getNfa()));
	// confirm that this is a group0 face. It has to be because
	// we are looping on group0 edges...
	// recall that faces have been paired in Step2, and active faces are paired faces where 
	// neither face is a "zero" face (i.e. its area is below a certain tolerance)...
	if (vdArray[ip].faceIsActive(-ifa-1)) {
	  // an active face can still be connected to a non-zero group -- this would be an
	  // open face, and should not be included in the normal...
	  int group_nbr,ifa_nbr; 
	  vdArray[ip].setGiForFaceNbr(group_nbr,ifa_nbr,-ifa-1);
	  if (group_nbr == 0) {
	    // we have an active face connected to another main group, i.e. NOT open, so include this...
	    int group,rank,bits,index;
	    vdArray[ip].setGrbiForFace(group,rank,bits,index,-ifa-1);
	    assert(bits == 0); // can be periodic in the future
	    assert(group == 0); // must be group 0 -- this is a check.
	    const pair<int,int> rbiHash = pair<int,int>(BitUtils::packRankBitsNew(rank,bits),index);
	    map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
	    if (iter == internalFaceMap.end()) {
	      internalFaceMap[rbiHash] = xVec.size();
	      xVec.push_back(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i)));
	    }
	    else {
	      const double * const x1 = xVec[iter->second];
	      const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	      const double * const x3 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
	      if ((x1 != x2)&&(x1 != x3)) {
		// tet corners, scaled by the passed scale_factor...
		xp[1][0] = x1[0]*scale_factor;
		xp[1][1] = x1[1]*scale_factor;
		xp[1][2] = x1[2]*scale_factor;
		xp[2][0] = x2[0]*scale_factor;
		xp[2][1] = x2[1]*scale_factor;
		xp[2][2] = x2[2]*scale_factor;
		xp[3][0] = x3[0]*scale_factor;
		xp[3][1] = x3[1]*scale_factor;
		xp[3][2] = x3[2]*scale_factor;
		addAllTetQuadratureTerms(coeff,xp);
	      }
	      else {
		// face loop should be 1-directional...
		assert(x1 == x3);
	      }
	    }
	  }
	}
      }
      else {
	map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	if (iter == boundaryFaceMap.end()) {
	  boundaryFaceMap[ifa] = xVec.size();
	  xVec.push_back(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i)));
	}
	else {
	  const double * const x1 = xVec[iter->second];
	  const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	  const double * const x3 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
	  if ((x1 != x2)&&(x1 != x3)) {
	    // tet corners in primed coords...
	    xp[1][0] = x1[0]*scale_factor;
	    xp[1][1] = x1[1]*scale_factor;
	    xp[1][2] = x1[2]*scale_factor;
	    xp[2][0] = x2[0]*scale_factor;
	    xp[2][1] = x2[1]*scale_factor;
	    xp[2][2] = x2[2]*scale_factor;
	    xp[3][0] = x3[0]*scale_factor;
	    xp[3][1] = x3[1]*scale_factor;
	    xp[3][2] = x3[2]*scale_factor;
	    addAllTetQuadratureTerms(coeff,xp);
	  }
	  else {
	    // face loop should be 1-directional...
	    assert(x1 == x3);
	  }
	}
      }
    }
  }
  
  // =============================================================
  // any orphan chunks?...
  // =============================================================
    
  int next = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
  while (next != -1) {
    // edge loop on ocdVec[next]...
    for (int ied = 0; ied < ocdVec[next].getNed(); ++ied) {
      // then other geometry...
      FOR_I2 {
	const int ifa = ocdVec[next].getFaoed(ied,i);
	if (ifa <= -ORPHAN_FACE_OFFSET) {
	  // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	  // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	  // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	  // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	  assert((-ifa-ORPHAN_FACE_OFFSET >= 0)&&(-ifa-ORPHAN_FACE_OFFSET < ocdVec[next].getNfa()));
	  const pair<int,int> rbiHash = pair<int,int>(ocdVec[next].getRankBitsForFace(-ifa-ORPHAN_FACE_OFFSET),ocdVec[next].getIndexForFace(-ifa-ORPHAN_FACE_OFFSET));
	  map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
	  if (iter == internalFaceMap.end()) {
	    internalFaceMap[rbiHash] = xVec.size();
	    xVec.push_back(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i)));
	  }
	  else {
	    const double * const x1 = xVec[iter->second];
	    const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
	    const double * const x3 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
	    if ((x1 != x2)&&(x1 != x3)) {
	      // tet corners in primed coords...
	      xp[1][0] = x1[0]*scale_factor;
	      xp[1][1] = x1[1]*scale_factor;
	      xp[1][2] = x1[2]*scale_factor;
	      xp[2][0] = x2[0]*scale_factor;
	      xp[2][1] = x2[1]*scale_factor;
	      xp[2][2] = x2[2]*scale_factor;
	      xp[3][0] = x3[0]*scale_factor;
	      xp[3][1] = x3[1]*scale_factor;
	      xp[3][2] = x3[2]*scale_factor;
	      addAllTetQuadratureTerms(coeff,xp);
	    }
	    else {
	      // face loop should be 1-directional...
	      assert(x1 == x3);
	    }
	  }
	}
	else if (ifa >= 0) {
	  // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	  // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	  // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	  // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	  map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	  if (iter == boundaryFaceMap.end()) {
	    boundaryFaceMap[ifa] = xVec.size();
	    xVec.push_back(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i)));
	  }
	  else {
	    const double * const x1 = xVec[iter->second];
	    const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
	    const double * const x3 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
	    if ((x1 != x2)&&(x1 != x3)) {
	      // tet corners in primed coords...
	      xp[1][0] = x1[0]*scale_factor;
	      xp[1][1] = x1[1]*scale_factor;
	      xp[1][2] = x1[2]*scale_factor;
	      xp[2][0] = x2[0]*scale_factor;
	      xp[2][1] = x2[1]*scale_factor;
	      xp[2][2] = x2[2]*scale_factor;
	      xp[3][0] = x3[0]*scale_factor;
	      xp[3][1] = x3[1]*scale_factor;
	      xp[3][2] = x3[2]*scale_factor;
	      addAllTetQuadratureTerms(coeff,xp);
	    }
	    else {
	      // face loop should be 1-directional...
	      assert(x1 == x3);
	    }
	  }
	}
      }
    }
    next = ocdVec[next].next; 
  }
  
}

void VoronoiPart::calcQuadratureTerms(double * coeff,const int ip,const double dx[3],const double e0[3],const double e1[3],const double e2[3]) const {
  
  assert((ip >= 0)&&(ip < points->np));
  
  for (int i = 0; i < 14; ++i) coeff[i] = 0.0;
  
  vector<double*> xVec;
  map<const pair<int,int>,int> internalFaceMap;
  map<const int,int> boundaryFaceMap;

  // the common coordinate for all tets involved in the integration is the passed dx,
  // which should be the vector FROM the face where the reconstruction is desired TO
  // the voronoi forming point, which is (0,0,0) in the local coords...
  double xp[4][3];
  xp[0][0] = DOT_PRODUCT(dx,e0);
  xp[0][1] = DOT_PRODUCT(dx,e1);
  xp[0][2] = DOT_PRODUCT(dx,e2);
  
  for (int ied = 0; ied < vdArray[ip].getNedMain(); ++ied) {
    FOR_I2 {
      const int ifa = vdArray[ip].getFaoed(ied,i);
      if (ifa < 0) {
	// this is an internal face (recall vdArray[ip] uses -1 indexing for faces)...
	assert((-ifa-1 >= 0)&&(-ifa-1 < vdArray[ip].getNfa()));
	// confirm that this is a group0 face. It has to be because
	// we are looping on group0 edges...
	// recall that faces have been paired in Step2, and active faces are paired faces where 
	// neither face is a "zero" face (i.e. its area is below a certain tolerance)...
	if (vdArray[ip].faceIsActive(-ifa-1)) {
	  // an active face can still be connected to a non-zero group -- this would be an
	  // open face, and should not be included in the normal...
	  int group_nbr,ifa_nbr; 
	  vdArray[ip].setGiForFaceNbr(group_nbr,ifa_nbr,-ifa-1);
	  if (group_nbr == 0) {
	    // we have an active face connected to another main group, i.e. NOT open, so include this...
	    int group,rank,bits,index;
	    vdArray[ip].setGrbiForFace(group,rank,bits,index,-ifa-1);
	    assert(bits == 0); // can be periodic in the future
	    assert(group == 0); // must be group 0 -- this is a check.
	    const pair<int,int> rbiHash = pair<int,int>(BitUtils::packRankBitsNew(rank,bits),index);
	    map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
	    if (iter == internalFaceMap.end()) {
	      internalFaceMap[rbiHash] = xVec.size();
	      xVec.push_back(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i)));
	    }
	    else {
	      const double * const x1 = xVec[iter->second];
	      const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	      const double * const x3 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
	      if ((x1 != x2)&&(x1 != x3)) {
		// tet corners in primed coords...
		xp[1][0] = DOT_PRODUCT(x1,e0)+xp[0][0];
		xp[1][1] = DOT_PRODUCT(x1,e1)+xp[0][1];
		xp[1][2] = DOT_PRODUCT(x1,e2)+xp[0][2];
		xp[2][0] = DOT_PRODUCT(x2,e0)+xp[0][0];
		xp[2][1] = DOT_PRODUCT(x2,e1)+xp[0][1];
		xp[2][2] = DOT_PRODUCT(x2,e2)+xp[0][2];
		xp[3][0] = DOT_PRODUCT(x3,e0)+xp[0][0];
		xp[3][1] = DOT_PRODUCT(x3,e1)+xp[0][1];
		xp[3][2] = DOT_PRODUCT(x3,e2)+xp[0][2];
		addTetQuadratureTerms(coeff,xp);
	      }
	      else {
		// face loop should be 1-directional...
		assert(x1 == x3);
	      }
	    }
	  }
	}
      }
      else {
	map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	if (iter == boundaryFaceMap.end()) {
	  boundaryFaceMap[ifa] = xVec.size();
	  xVec.push_back(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i)));
	}
	else {
	  const double * const x1 = xVec[iter->second];
	  const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	  const double * const x3 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
	  if ((x1 != x2)&&(x1 != x3)) {
	    // tet corners in primed coords...
	    xp[1][0] = DOT_PRODUCT(x1,e0)+xp[0][0];
	    xp[1][1] = DOT_PRODUCT(x1,e1)+xp[0][1];
	    xp[1][2] = DOT_PRODUCT(x1,e2)+xp[0][2];
	    xp[2][0] = DOT_PRODUCT(x2,e0)+xp[0][0];
	    xp[2][1] = DOT_PRODUCT(x2,e1)+xp[0][1];
	    xp[2][2] = DOT_PRODUCT(x2,e2)+xp[0][2];
	    xp[3][0] = DOT_PRODUCT(x3,e0)+xp[0][0];
	    xp[3][1] = DOT_PRODUCT(x3,e1)+xp[0][1];
	    xp[3][2] = DOT_PRODUCT(x3,e2)+xp[0][2];
	    addTetQuadratureTerms(coeff,xp);
	  }
	  else {
	    // face loop should be 1-directional...
	    assert(x1 == x3);
	  }
	}
      }
    }
  }
  
  // =============================================================
  // any orphan chunks?...
  // =============================================================
    
  int next = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
  while (next != -1) {
    // edge loop on ocdVec[next]...
    for (int ied = 0; ied < ocdVec[next].getNed(); ++ied) {
      // then other geometry...
      FOR_I2 {
	const int ifa = ocdVec[next].getFaoed(ied,i);
	if (ifa <= -ORPHAN_FACE_OFFSET) {
	  // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	  // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	  // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	  // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	  assert((-ifa-ORPHAN_FACE_OFFSET >= 0)&&(-ifa-ORPHAN_FACE_OFFSET < ocdVec[next].getNfa()));
	  const pair<int,int> rbiHash = pair<int,int>(ocdVec[next].getRankBitsForFace(-ifa-ORPHAN_FACE_OFFSET),ocdVec[next].getIndexForFace(-ifa-ORPHAN_FACE_OFFSET));
	  map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
	  if (iter == internalFaceMap.end()) {
	    internalFaceMap[rbiHash] = xVec.size();
	    xVec.push_back(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i)));
	  }
	  else {
	    const double * const x1 = xVec[iter->second];
	    const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
	    const double * const x3 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
	    if ((x1 != x2)&&(x1 != x3)) {
	      // tet corners in primed coords...
	      xp[1][0] = DOT_PRODUCT(x1,e0)+xp[0][0];
	      xp[1][1] = DOT_PRODUCT(x1,e1)+xp[0][1];
	      xp[1][2] = DOT_PRODUCT(x1,e2)+xp[0][2];
	      xp[2][0] = DOT_PRODUCT(x2,e0)+xp[0][0];
	      xp[2][1] = DOT_PRODUCT(x2,e1)+xp[0][1];
	      xp[2][2] = DOT_PRODUCT(x2,e2)+xp[0][2];
	      xp[3][0] = DOT_PRODUCT(x3,e0)+xp[0][0];
	      xp[3][1] = DOT_PRODUCT(x3,e1)+xp[0][1];
	      xp[3][2] = DOT_PRODUCT(x3,e2)+xp[0][2];
	      addTetQuadratureTerms(coeff,xp);
	    }
	    else {
	      // face loop should be 1-directional...
	      assert(x1 == x3);
	    }
	  }
	}
	else if (ifa >= 0) {
	  // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	  // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	  // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	  // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	  map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	  if (iter == boundaryFaceMap.end()) {
	    boundaryFaceMap[ifa] = xVec.size();
	    xVec.push_back(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i)));
	  }
	  else {
	    const double * const x1 = xVec[iter->second];
	    const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
	    const double * const x3 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
	    if ((x1 != x2)&&(x1 != x3)) {
	      // tet corners in primed coords...
	      xp[1][0] = DOT_PRODUCT(x1,e0)+xp[0][0];
	      xp[1][1] = DOT_PRODUCT(x1,e1)+xp[0][1];
	      xp[1][2] = DOT_PRODUCT(x1,e2)+xp[0][2];
	      xp[2][0] = DOT_PRODUCT(x2,e0)+xp[0][0];
	      xp[2][1] = DOT_PRODUCT(x2,e1)+xp[0][1];
	      xp[2][2] = DOT_PRODUCT(x2,e2)+xp[0][2];
	      xp[3][0] = DOT_PRODUCT(x3,e0)+xp[0][0];
	      xp[3][1] = DOT_PRODUCT(x3,e1)+xp[0][1];
	      xp[3][2] = DOT_PRODUCT(x3,e2)+xp[0][2];
	      addTetQuadratureTerms(coeff,xp);
	    }
	    else {
	      // face loop should be 1-directional...
	      assert(x1 == x3);
	    }
	  }
	}
      }
    }
    next = ocdVec[next].next; 
  }
  
}

#include "define_coeff.hpp"

void VoronoiPart::mapCvQuadratureTerms(double * coeff,const int ip,const double x0[3],const double L_cv,const double inv_L_fa,const double e0_inv_L_fa[3],const double e1_inv_L_fa[3],const double e2_inv_L_fa[3],const double coeff_cv[35]) const {

  //cout << "in mapCvQuadratureTerms: " << L_cv << " 1.0/inv_L_fa: " << 1.0/inv_L_fa << " L_cv*inv_L_fa: " << L_cv*inv_L_fa << endl;
  
  double dxp[3];
  dxp[0] = DOT_PRODUCT(x0,e0_inv_L_fa);
  dxp[1] = DOT_PRODUCT(x0,e1_inv_L_fa);
  dxp[2] = DOT_PRODUCT(x0,e2_inv_L_fa);

  double e0[3]; FOR_I3 e0[i] = e0_inv_L_fa[i]*L_cv;
  double e1[3]; FOR_I3 e1[i] = e1_inv_L_fa[i]*L_cv;
  double e2[3]; FOR_I3 e2[i] = e2_inv_L_fa[i]*L_cv;

  //cout << "coeff[SW]: " << coeff[SW] << " coeff_cv[SW]*factor3: " << coeff_cv[SW]*factor3 << " diff: " << coeff_cv[SW]*factor3 - coeff[SW] << endl;
  //double dmax = fabs(coeff_cv[SW]*factor3 - coeff[SW]);

  const double swx = 
    coeff_cv[SWX]*e0[0] + 
    coeff_cv[SWY]*e0[1] + 
    coeff_cv[SWZ]*e0[2] + 
    coeff_cv[SW]*dxp[0];
  const double swy = 
    coeff_cv[SWX]*e1[0] + 
    coeff_cv[SWY]*e1[1] + 
    coeff_cv[SWZ]*e1[2] + 
    coeff_cv[SW]*dxp[1];
  const double swz = 
    coeff_cv[SWX]*e2[0] + 
    coeff_cv[SWY]*e2[1] + 
    coeff_cv[SWZ]*e2[2] + 
    coeff_cv[SW]*dxp[2];
  
  
  //cout << "factors: factor3: " << factor3 << " 1.0/factor3: " << 1.0/factor3 << " factor^3: " << factor*factor*factor << " factor_local^3: " << factor_local*factor_local*factor_local << endl;

  //cout << "coeff[SWX]: " << coeff[SWX] << " testing: " << swx*factor3 << " diff: " <<  swx*factor3 - coeff[SWX] << endl;
  //cout << "coeff[SWY]: " << coeff[SWY] << " testing: " << swy*factor3 << " diff: " <<  swy*factor3 - coeff[SWY] << endl;
  //cout << "coeff[SWZ]: " << coeff[SWZ] << " testing: " << swz*factor3 << " diff: " <<  swz*factor3 - coeff[SWZ] << endl;

  //dmax = max(dmax,fabs(swx*factor3 - coeff[SWX]));
  //dmax = max(dmax,fabs(swy*factor3 - coeff[SWY]));
  //dmax = max(dmax,fabs(swz*factor3 - coeff[SWZ]));

  const double swxx = 
    coeff_cv[SWXX]*e0[0]*e0[0] + 
    coeff_cv[SWYY]*e0[1]*e0[1] + 
    coeff_cv[SWZZ]*e0[2]*e0[2] +
    2.0*( coeff_cv[SWXY]*e0[0]*e0[1] +
	  coeff_cv[SWXZ]*e0[0]*e0[2] +
	  coeff_cv[SWYZ]*e0[1]*e0[2] +
	  dxp[0]*swx) - coeff_cv[SW]*dxp[0]*dxp[0];
  
  //cout << "coeff[SWXX]: " << coeff[SWXX] << " testing: " << swxx*factor3 << " diff: " << swxx*factor3 - coeff[SWXX] << endl;
  //dmax = max(dmax,fabs(swxx*factor3 - coeff[SWXX]));

  const double swxy = 
    coeff_cv[SWXX]*e0[0]*e1[0] + 
    coeff_cv[SWYY]*e0[1]*e1[1] + 
    coeff_cv[SWZZ]*e0[2]*e1[2] +
    coeff_cv[SWXY]*(e0[0]*e1[1] + e0[1]*e1[0]) +
    coeff_cv[SWXZ]*(e0[0]*e1[2] + e0[2]*e1[0]) +
    coeff_cv[SWYZ]*(e0[1]*e1[2] + e0[2]*e1[1]) +
    dxp[0]*swy + dxp[1]*swx - coeff_cv[SW]*dxp[0]*dxp[1];

  //cout << "coeff[SWXY]: " << coeff[SWXY] << " testing: " << swxy*factor3 << " diff: " << swxy*factor3 - coeff[SWXY] << endl;
  //dmax = max(dmax,fabs(swxy*factor3 - coeff[SWXY]));

  const double swxz = 
    coeff_cv[SWXX]*e0[0]*e2[0] + 
    coeff_cv[SWYY]*e0[1]*e2[1] + 
    coeff_cv[SWZZ]*e0[2]*e2[2] +
    coeff_cv[SWXY]*(e0[0]*e2[1] + e0[1]*e2[0]) +
    coeff_cv[SWXZ]*(e0[0]*e2[2] + e0[2]*e2[0]) +
    coeff_cv[SWYZ]*(e0[1]*e2[2] + e0[2]*e2[1]) +
    dxp[0]*swz + dxp[2]*swx - coeff_cv[SW]*dxp[0]*dxp[2];
  
  //cout << "coeff[SWXZ]: " << coeff[SWXZ] << " testing: " << swxz*factor3 << " diff: " << swxz*factor3 - coeff[SWXZ] << endl;
  //dmax = max(dmax,fabs(swxz*factor3 - coeff[SWXZ]));
  
  const double swyy = 
    coeff_cv[SWXX]*e1[0]*e1[0] + 
    coeff_cv[SWYY]*e1[1]*e1[1] + 
    coeff_cv[SWZZ]*e1[2]*e1[2] +
    2.0*( coeff_cv[SWXY]*e1[0]*e1[1] +
	  coeff_cv[SWXZ]*e1[0]*e1[2] +
	  coeff_cv[SWYZ]*e1[1]*e1[2] +
	  dxp[1]*swy) - coeff_cv[SW]*dxp[1]*dxp[1];
  
  //cout << "coeff[SWYY]: " << coeff[SWYY] << " testing: " << swyy*factor3 << " diff: " << swyy*factor3 - coeff[SWYY] << endl;
  //dmax = max(dmax,fabs(swyy*factor3 - coeff[SWYY]));

  const double swyz = 
    coeff_cv[SWXX]*e1[0]*e2[0] + 
    coeff_cv[SWYY]*e1[1]*e2[1] + 
    coeff_cv[SWZZ]*e1[2]*e2[2] +
    coeff_cv[SWXY]*(e1[0]*e2[1] + e1[1]*e2[0]) +
    coeff_cv[SWXZ]*(e1[0]*e2[2] + e1[2]*e2[0]) +
    coeff_cv[SWYZ]*(e1[1]*e2[2] + e1[2]*e2[1]) +
    dxp[1]*swz + dxp[2]*swy - coeff_cv[SW]*dxp[1]*dxp[2];
  
  //cout << "coeff[SWYZ]: " << coeff[SWYZ] << " testing: " << swyz*factor3 << " diff: " << swyz*factor3 - coeff[SWYZ] << endl;
  //dmax = max(dmax,fabs(swyz*factor3 - coeff[SWYZ]));

  const double swzz = 
    coeff_cv[SWXX]*e2[0]*e2[0] + 
    coeff_cv[SWYY]*e2[1]*e2[1] + 
    coeff_cv[SWZZ]*e2[2]*e2[2] +
    2.0*( coeff_cv[SWXY]*e2[0]*e2[1] +
	  coeff_cv[SWXZ]*e2[0]*e2[2] +
	  coeff_cv[SWYZ]*e2[1]*e2[2] +
	  dxp[2]*swz) - coeff_cv[SW]*dxp[2]*dxp[2];
  
  //cout << "coeff[SWZZ]: " << coeff[SWZZ] << " testing: " << swzz*factor3 << " diff: " << swzz*factor3 - coeff[SWZZ] << endl;
  //dmax = max(dmax,fabs(swzz*factor3 - coeff[SWZZ]));

  const double swxxx = 
    coeff_cv[SWXXX]*e0[0]*e0[0]*e0[0] + 
    coeff_cv[SWYYY]*e0[1]*e0[1]*e0[1] + 
    coeff_cv[SWZZZ]*e0[2]*e0[2]*e0[2] + 
    3.0*( coeff_cv[SWXXY]*e0[0]*e0[0]*e0[1] +
	  coeff_cv[SWXXZ]*e0[0]*e0[0]*e0[2] +
	  coeff_cv[SWXYY]*e0[0]*e0[1]*e0[1] +
	  coeff_cv[SWYYZ]*e0[1]*e0[1]*e0[2] +
	  coeff_cv[SWXZZ]*e0[0]*e0[2]*e0[2] +
	  coeff_cv[SWYZZ]*e0[1]*e0[2]*e0[2] ) +
    6.0*coeff_cv[SWXYZ]*e0[0]*e0[1]*e0[2] +
    3.0*( dxp[0]*swxx - dxp[0]*dxp[0]*swx ) + coeff_cv[SW]*dxp[0]*dxp[0]*dxp[0];
  
  //cout << "coeff[SWXXX]: " << coeff[SWXXX] << " testing: " << swxxx*factor3 << " diff: " << swxxx*factor3 - coeff[SWXXX] << endl;
  //dmax = max(dmax,fabs(swxxx*factor3 - coeff[SWXXX]));
  
  const double swxxy = 
    coeff_cv[SWXXX]*e0[0]*e0[0]*e1[0] + 
    coeff_cv[SWYYY]*e0[1]*e0[1]*e1[1] + 
    coeff_cv[SWZZZ]*e0[2]*e0[2]*e1[2] + 
    coeff_cv[SWXXY]*(2.0*e0[0]*e1[0]*e0[1] + e0[0]*e0[0]*e1[1]) +
    coeff_cv[SWXXZ]*(2.0*e0[0]*e1[0]*e0[2] + e0[0]*e0[0]*e1[2]) +
    coeff_cv[SWXYY]*(2.0*e0[0]*e0[1]*e1[1] + e1[0]*e0[1]*e0[1]) +
    coeff_cv[SWYYZ]*(2.0*e0[1]*e1[1]*e0[2] + e0[1]*e0[1]*e1[2]) +
    coeff_cv[SWXZZ]*(2.0*e0[0]*e0[2]*e1[2] + e1[0]*e0[2]*e0[2]) +
    coeff_cv[SWYZZ]*(2.0*e0[1]*e0[2]*e1[2] + e1[1]*e0[2]*e0[2]) +
    2.0*coeff_cv[SWXYZ]*(e0[0]*e1[1]*e0[2] + e0[0]*e0[1]*e1[2] + e1[0]*e0[1]*e0[2]) +
    ( dxp[1]*swxx + 2.0*dxp[0]*swxy - dxp[0]*dxp[0]*swy - 2.0*dxp[0]*dxp[1]*swx ) + coeff_cv[SW]*dxp[0]*dxp[0]*dxp[1];
  
  //cout << "coeff[SWXXY]: " << coeff[SWXXY] << " testing: " << swxxy*factor3 << " diff: " << swxxy*factor3 - coeff[SWXXY] << endl;
  //dmax = max(dmax,fabs(swxxy*factor3 - coeff[SWXXY]));
  
  const double swxxz = 
    coeff_cv[SWXXX]*e0[0]*e0[0]*e2[0] + 
    coeff_cv[SWYYY]*e0[1]*e0[1]*e2[1] + 
    coeff_cv[SWZZZ]*e0[2]*e0[2]*e2[2] + 
    coeff_cv[SWXXY]*(2.0*e0[0]*e2[0]*e0[1] + e0[0]*e0[0]*e2[1]) +
    coeff_cv[SWXXZ]*(2.0*e0[0]*e2[0]*e0[2] + e0[0]*e0[0]*e2[2]) +
    coeff_cv[SWXYY]*(2.0*e0[0]*e0[1]*e2[1] + e2[0]*e0[1]*e0[1]) +
    coeff_cv[SWYYZ]*(2.0*e0[1]*e2[1]*e0[2] + e0[1]*e0[1]*e2[2]) +
    coeff_cv[SWXZZ]*(2.0*e0[0]*e0[2]*e2[2] + e2[0]*e0[2]*e0[2]) +
    coeff_cv[SWYZZ]*(2.0*e0[1]*e0[2]*e2[2] + e2[1]*e0[2]*e0[2]) +
    2.0*coeff_cv[SWXYZ]*(e0[0]*e2[1]*e0[2] + e0[0]*e0[1]*e2[2] + e2[0]*e0[1]*e0[2]) +
    ( dxp[2]*swxx + 2.0*dxp[0]*swxz - dxp[0]*dxp[0]*swz - 2.0*dxp[0]*dxp[2]*swx ) + coeff_cv[SW]*dxp[0]*dxp[0]*dxp[2];
  
  //cout << "coeff[SWXXZ]: " << coeff[SWXXZ] << " testing: " << swxxz*factor3 << " diff: " << swxxz*factor3 - coeff[SWXXZ] << endl;
  //dmax = max(dmax,fabs(swxxz*factor3 - coeff[SWXXZ]));
  
  const double swxxxx = 
    coeff_cv[SWXXXX]*e0[0]*e0[0]*e0[0]*e0[0] +
    coeff_cv[SWYYYY]*e0[1]*e0[1]*e0[1]*e0[1] +
    coeff_cv[SWZZZZ]*e0[2]*e0[2]*e0[2]*e0[2] +
    4.0*( coeff_cv[SWXXXY]*e0[0]*e0[0]*e0[0]*e0[1] +
	  coeff_cv[SWXXXZ]*e0[0]*e0[0]*e0[0]*e0[2] +
	  coeff_cv[SWXYYY]*e0[0]*e0[1]*e0[1]*e0[1] +
	  coeff_cv[SWYYYZ]*e0[1]*e0[1]*e0[1]*e0[2] +
	  coeff_cv[SWXZZZ]*e0[0]*e0[2]*e0[2]*e0[2] +
	  coeff_cv[SWYZZZ]*e0[1]*e0[2]*e0[2]*e0[2] ) +
    6.0*( coeff_cv[SWXXYY]*e0[0]*e0[0]*e0[1]*e0[1] +
	  coeff_cv[SWXXZZ]*e0[0]*e0[0]*e0[2]*e0[2] +
	  coeff_cv[SWYYZZ]*e0[1]*e0[1]*e0[2]*e0[2] ) +
    12.0*( coeff_cv[SWXXYZ]*e0[0]*e0[0]*e0[1]*e0[2] +
	   coeff_cv[SWXYYZ]*e0[0]*e0[1]*e0[1]*e0[2] +
	   coeff_cv[SWXYZZ]*e0[0]*e0[1]*e0[2]*e0[2] ) +
    ( 4.0*dxp[0]*swxxx - 6.0*dxp[0]*dxp[0]*swxx + 4.0*dxp[0]*dxp[0]*dxp[0]*swx ) - coeff_cv[SW]*dxp[0]*dxp[0]*dxp[0]*dxp[0];
  
  //cout << "coeff[SWXXXX]: " << coeff[SWXXXX] << " testing: " << swxxxx*factor3 << " diff: " << swxxxx*factor3 - coeff[SWXXXX] << endl;
  //dmax = max(dmax,fabs(swxxxx*factor3 - coeff[SWXXXX]));

  //assert(dmax < 1.0E-12);
  //getchar();

  const double factor3 = L_cv*L_cv*L_cv*inv_L_fa*inv_L_fa*inv_L_fa;
  
  coeff[SW] = coeff_cv[SW]*factor3;
  
  coeff[SWX] = swx*factor3;
  coeff[SWY] = swy*factor3;
  coeff[SWZ] = swz*factor3;
  
  coeff[SWXX] = swxx*factor3;
  coeff[SWXY] = swxy*factor3;
  coeff[SWXZ] = swxz*factor3;
  coeff[SWYY] = swyy*factor3;
  coeff[SWYZ] = swyz*factor3;
  coeff[SWZZ] = swzz*factor3;
  
  coeff[SWXXX] = swxxx*factor3;
  coeff[SWXXY] = swxxy*factor3;
  coeff[SWXXZ] = swxxz*factor3;
  
  coeff[SWXXXX] = swxxxx*factor3;
  
}

#include "undef_coeff.hpp"




#include "define_coeff.hpp"

void VoronoiPart::addAllTetQuadratureTerms(double * coeff,const double xp[4][3]) const {
  
  //return;

  using GaussQuadrature::tet4;
  using GaussQuadrature::tet10;
  using GaussQuadrature::tet20;

  // volume term...

  const double vol = SIGNED_TET_VOLUME_6(xp[0],xp[1],xp[2],xp[3]);
  coeff[SW] += vol;
  
  // [1:3] are linear...
  
  coeff[SWX] += vol*0.25*(xp[0][0]+xp[1][0]+xp[2][0]+xp[3][0]);
  coeff[SWY] += vol*0.25*(xp[0][1]+xp[1][1]+xp[2][1]+xp[3][1]);
  coeff[SWZ] += vol*0.25*(xp[0][2]+xp[1][2]+xp[2][2]+xp[3][2]);
  
  // hack - compute at the centroid...
  
  /*
    {

    double x[3] = { 0.0, 0.0, 0.0 };
    for (int i = 0; i < 4; ++i) FOR_J3 x[j] += 0.25*xp[i][j];
    coeff[SWXX] += vol*x[0]*x[0];
    coeff[SWXY] += vol*x[0]*x[1];
    coeff[SWXZ] += vol*x[0]*x[2];
    coeff[SWYY] += vol*x[1]*x[1];
    coeff[SWYZ] += vol*x[1]*x[2];
    coeff[SWZZ] += vol*x[2]*x[2];
    coeff[SWXXX] += vol*x[0]*x[0]*x[0];
    coeff[SWXXY] += vol*x[0]*x[0]*x[1];
    coeff[SWXXZ] += vol*x[0]*x[0]*x[2];
    coeff[SWXXXX] += vol*x[0]*x[0]*x[0]*x[0];
    return;

    }
  */
  
  // for the square terms, we can use the 4 point quadrature rule...

  {
    double coeff_xx = 0.0;
    double coeff_xy = 0.0;
    double coeff_xz = 0.0;
    double coeff_yy = 0.0;
    double coeff_yz = 0.0;
    double coeff_zz = 0.0;
    for (int ip = 0; ip < 4; ++ip) {
      double x[3] = { 0.0, 0.0, 0.0 };
      for (int i = 0; i < 4; ++i) FOR_J3 x[j] += tet4[ip][i]*xp[i][j];
      //    coeff[SWXX] += vol*tet4[ip][4]*x[0]*x[0];
      //    coeff[SWXY] += vol*tet4[ip][4]*x[0]*x[1];
      //    coeff[SWXZ] += vol*tet4[ip][4]*x[0]*x[2];
      //    coeff[SWYY] += vol*tet4[ip][4]*x[1]*x[1];
      //    coeff[SWYZ] += vol*tet4[ip][4]*x[1]*x[2];
      //    coeff[SWZZ] += vol*tet4[ip][4]*x[2]*x[2];
      coeff_xx += tet4[ip][4]*x[0]*x[0];
      coeff_xy += tet4[ip][4]*x[0]*x[1];
      coeff_xz += tet4[ip][4]*x[0]*x[2];
      coeff_yy += tet4[ip][4]*x[1]*x[1];
      coeff_yz += tet4[ip][4]*x[1]*x[2];
      coeff_zz += tet4[ip][4]*x[2]*x[2];
    }
    coeff[SWXX] += vol*coeff_xx;
    coeff[SWXY] += vol*coeff_xy;
    coeff[SWXZ] += vol*coeff_xz;
    coeff[SWYY] += vol*coeff_yy;
    coeff[SWYZ] += vol*coeff_yz;
    coeff[SWZZ] += vol*coeff_zz;
  }

  // cubic terms 10 pt rule...
  {
    double coeff_xxx = 0.0;
    double coeff_xxy = 0.0;
    double coeff_xxz = 0.0;
  
    // part of full
    double coeff_xyy = 0.0;
    double coeff_xyz = 0.0;
    double coeff_xzz = 0.0;
    double coeff_yyy = 0.0;
    double coeff_yyz = 0.0;
    double coeff_yzz = 0.0;
    double coeff_zzz = 0.0;
  
    for (int ip = 0; ip < 10; ++ip) {
      double x[3] = { 0.0, 0.0, 0.0 };
      for (int i = 0; i < 4; ++i) FOR_J3 x[j] += tet10[ip][i]*xp[i][j];
      //  coeff[SWXXX] += vol*tet10[ip][4]*x[0]*x[0]*x[0];
      //  coeff[SWXXY] += vol*tet10[ip][4]*x[0]*x[0]*x[1];
      //  coeff[SWXXZ] += vol*tet10[ip][4]*x[0]*x[0]*x[2];
      coeff_xxx += tet10[ip][4]*x[0]*x[0]*x[0];
      coeff_xxy += tet10[ip][4]*x[0]*x[0]*x[1];
      coeff_xxz += tet10[ip][4]*x[0]*x[0]*x[2];
  
      // full...
      coeff_xyy += tet10[ip][4]*x[0]*x[1]*x[1];
      coeff_xyz += tet10[ip][4]*x[0]*x[1]*x[2];
      coeff_xzz += tet10[ip][4]*x[0]*x[2]*x[2];
      coeff_yyy += tet10[ip][4]*x[1]*x[1]*x[1];
      coeff_yyz += tet10[ip][4]*x[1]*x[1]*x[2];
      coeff_yzz += tet10[ip][4]*x[1]*x[2]*x[2];   
      coeff_zzz += tet10[ip][4]*x[2]*x[2]*x[2];
    }
    coeff[SWXXX] += vol*coeff_xxx;
    coeff[SWXXY] += vol*coeff_xxy;
    coeff[SWXXZ] += vol*coeff_xxz;
  
    // full...
    coeff[SWXYY] += vol*coeff_xyy;
    coeff[SWXYZ] += vol*coeff_xyz;
    coeff[SWXZZ] += vol*coeff_xzz;
    coeff[SWYYY] += vol*coeff_yyy;
    coeff[SWYYZ] += vol*coeff_yyz;
    coeff[SWYZZ] += vol*coeff_yzz;
    coeff[SWZZZ] += vol*coeff_zzz;
  }

  // x^4 terms 20 pt rule... 
  {
    double coeff_xxxx = 0.0;
  
    // full...
    double coeff_XXXY = 0.0;
    double coeff_XXXZ = 0.0;
    double coeff_XXYY = 0.0;
    double coeff_XXYZ = 0.0;
    double coeff_XXZZ = 0.0;
    double coeff_XYYY = 0.0;
    double coeff_XYYZ = 0.0;
    double coeff_XYZZ = 0.0;
    double coeff_XZZZ = 0.0;
    double coeff_YYYY = 0.0;
    double coeff_YYYZ = 0.0;
    double coeff_YYZZ = 0.0;
    double coeff_YZZZ = 0.0;
    double coeff_ZZZZ = 0.0;
  
    for (int ip = 0; ip < 20; ++ip) {
      double x[3] = { 0.0, 0.0, 0.0 };
      for (int i = 0; i < 4; ++i) FOR_J3 x[j] += tet20[ip][i]*xp[i][j];
      coeff_xxxx += tet20[ip][4]*x[0]*x[0]*x[0]*x[0];
    
      // full...
      coeff_XXXY += tet20[ip][4]*x[0]*x[0]*x[0]*x[1];
      coeff_XXXZ += tet20[ip][4]*x[0]*x[0]*x[0]*x[2];
      coeff_XXYY += tet20[ip][4]*x[0]*x[0]*x[1]*x[1];
      coeff_XXYZ += tet20[ip][4]*x[0]*x[0]*x[1]*x[2];
      coeff_XXZZ += tet20[ip][4]*x[0]*x[0]*x[2]*x[2];
      coeff_XYYY += tet20[ip][4]*x[0]*x[1]*x[1]*x[1];
      coeff_XYYZ += tet20[ip][4]*x[0]*x[1]*x[1]*x[2];
      coeff_XYZZ += tet20[ip][4]*x[0]*x[1]*x[2]*x[2];
      coeff_XZZZ += tet20[ip][4]*x[0]*x[2]*x[2]*x[2];
      coeff_YYYY += tet20[ip][4]*x[1]*x[1]*x[1]*x[1];
      coeff_YYYZ += tet20[ip][4]*x[1]*x[1]*x[1]*x[2];
      coeff_YYZZ += tet20[ip][4]*x[1]*x[1]*x[2]*x[2];
      coeff_YZZZ += tet20[ip][4]*x[1]*x[2]*x[2]*x[2];
      coeff_ZZZZ += tet20[ip][4]*x[2]*x[2]*x[2]*x[2];
    
    }
    coeff[SWXXXX] += vol*coeff_xxxx;

    // full...
    coeff[SWXXXY] += vol*coeff_XXXY;
    coeff[SWXXXZ] += vol*coeff_XXXZ;
    coeff[SWXXYY] += vol*coeff_XXYY;
    coeff[SWXXYZ] += vol*coeff_XXYZ;
    coeff[SWXXZZ] += vol*coeff_XXZZ;
    coeff[SWXYYY] += vol*coeff_XYYY;
    coeff[SWXYYZ] += vol*coeff_XYYZ;
    coeff[SWXYZZ] += vol*coeff_XYZZ;
    coeff[SWXZZZ] += vol*coeff_XZZZ;
    coeff[SWYYYY] += vol*coeff_YYYY;
    coeff[SWYYYZ] += vol*coeff_YYYZ;
    coeff[SWYYZZ] += vol*coeff_YYZZ;
    coeff[SWYZZZ] += vol*coeff_YZZZ;
    coeff[SWZZZZ] += vol*coeff_ZZZZ;
  }
  
  
}

void VoronoiPart::addTetQuadratureTerms(double * coeff,const double xp[4][3]) const {
  
  //return;

  using GaussQuadrature::tet4;
  using GaussQuadrature::tet10;
  using GaussQuadrature::tet20;

  // volume term...

  const double vol = SIGNED_TET_VOLUME_6(xp[0],xp[1],xp[2],xp[3]);
  coeff[SW] += vol;
  
  // [1:3] are linear...
  
  coeff[SWX] += vol*0.25*(xp[0][0]+xp[1][0]+xp[2][0]+xp[3][0]);
  coeff[SWY] += vol*0.25*(xp[0][1]+xp[1][1]+xp[2][1]+xp[3][1]);
  coeff[SWZ] += vol*0.25*(xp[0][2]+xp[1][2]+xp[2][2]+xp[3][2]);
  
  // hack - compute at the centroid...
  
  /*
    {

    double x[3] = { 0.0, 0.0, 0.0 };
    for (int i = 0; i < 4; ++i) FOR_J3 x[j] += 0.25*xp[i][j];
    coeff[SWXX] += vol*x[0]*x[0];
    coeff[SWXY] += vol*x[0]*x[1];
    coeff[SWXZ] += vol*x[0]*x[2];
    coeff[SWYY] += vol*x[1]*x[1];
    coeff[SWYZ] += vol*x[1]*x[2];
    coeff[SWZZ] += vol*x[2]*x[2];
    coeff[SWXXX] += vol*x[0]*x[0]*x[0];
    coeff[SWXXY] += vol*x[0]*x[0]*x[1];
    coeff[SWXXZ] += vol*x[0]*x[0]*x[2];
    coeff[SWXXXX] += vol*x[0]*x[0]*x[0]*x[0];
    return;

    }
  */
  
  // for the square terms, we can use the 4 point quadrature rule...
  {
    double coeff_xx = 0.0;
    double coeff_xy = 0.0;
    double coeff_xz = 0.0;
    double coeff_yy = 0.0;
    double coeff_yz = 0.0;
    double coeff_zz = 0.0;
    for (int ip = 0; ip < 4; ++ip) {
      double x[3] = { 0.0, 0.0, 0.0 };
      for (int i = 0; i < 4; ++i) FOR_J3 x[j] += tet4[ip][i]*xp[i][j];
      //    coeff[SWXX] += vol*tet4[ip][4]*x[0]*x[0];
      //    coeff[SWXY] += vol*tet4[ip][4]*x[0]*x[1];
      //    coeff[SWXZ] += vol*tet4[ip][4]*x[0]*x[2];
      //    coeff[SWYY] += vol*tet4[ip][4]*x[1]*x[1];
      //    coeff[SWYZ] += vol*tet4[ip][4]*x[1]*x[2];
      //    coeff[SWZZ] += vol*tet4[ip][4]*x[2]*x[2];
      coeff_xx += tet4[ip][4]*x[0]*x[0];
      coeff_xy += tet4[ip][4]*x[0]*x[1];
      coeff_xz += tet4[ip][4]*x[0]*x[2];
      coeff_yy += tet4[ip][4]*x[1]*x[1];
      coeff_yz += tet4[ip][4]*x[1]*x[2];
      coeff_zz += tet4[ip][4]*x[2]*x[2];
    }
    coeff[SWXX] += vol*coeff_xx;
    coeff[SWXY] += vol*coeff_xy;
    coeff[SWXZ] += vol*coeff_xz;
    coeff[SWYY] += vol*coeff_yy;
    coeff[SWYZ] += vol*coeff_yz;
    coeff[SWZZ] += vol*coeff_zz;
  }

  // cubic terms 10 pt rule...
  {
    double coeff_xxx = 0.0;
    double coeff_xxy = 0.0;
    double coeff_xxz = 0.0;
    for (int ip = 0; ip < 10; ++ip) {
      double x[3] = { 0.0, 0.0, 0.0 };
      for (int i = 0; i < 4; ++i) FOR_J3 x[j] += tet10[ip][i]*xp[i][j];
      //  coeff[SWXXX] += vol*tet10[ip][4]*x[0]*x[0]*x[0];
      //  coeff[SWXXY] += vol*tet10[ip][4]*x[0]*x[0]*x[1];
      //  coeff[SWXXZ] += vol*tet10[ip][4]*x[0]*x[0]*x[2];
      coeff_xxx += tet10[ip][4]*x[0]*x[0]*x[0];
      coeff_xxy += tet10[ip][4]*x[0]*x[0]*x[1];
      coeff_xxz += tet10[ip][4]*x[0]*x[0]*x[2];
    }
    coeff[SWXXX] += vol*coeff_xxx;
    coeff[SWXXY] += vol*coeff_xxy;
    coeff[SWXXZ] += vol*coeff_xxz;
  }
  
  // x^4 terms 20 pt rule... 
  {
    double coeff_xxxx = 0.0;
    for (int ip = 0; ip < 20; ++ip) {
      //    double x[3] = { 0.0, 0.0, 0.0 };
      //    for (int i = 0; i < 4; ++i) FOR_J3 x[j] += tet20[ip][i]*xp[i][j];
      //    coeff[SWXXXX] += vol*tet20[ip][4]*x[0]*x[0]*x[0]*x[0];
      double x0 = 0.0; // only need x
      for (int i = 0; i < 4; ++i) x0 += tet20[ip][i]*xp[i][0];
      coeff_xxxx += tet20[ip][4]*x0*x0*x0*x0;
    }
    coeff[SWXXXX] += vol*coeff_xxxx;
  }
}

#include "undef_coeff.hpp"





























void VoronoiPart::initStaticSolver(StaticSolver * s) const {
  
  int * send_count = new int[mpi_size];
  int * send_disp = new int[mpi_size];
  int * recv_count = new int[mpi_size];
  int * recv_disp = new int[mpi_size];

  // here we assume that the VD's are all built and we are reconstructing faces
  // (and volumes?). Note that faces are not necessarily the vdArray[ip].nfa,
  // because these are just individual face loops. At this point, all face loops (on
  // the main or orphan cvs) are treated as one face...

  const double boundary_face_crease_angle = getDoubleParam("CREASE_ANGLE",175.0);
  
  map<const uint8,int> rbiMap;
  
  set<pair<int,int> > internalFaceSet;
  vector<FaceGeometryData> ifdVec;
  map<const pair<int,int>,int> internalFaceMap;

  s->ncv = points->np;
  s->ncv_g = s->ncv; // number of ghost cvs...
  assert(s->x_cv == NULL); s->x_cv = new double[s->ncv][3];
  assert(s->vol_cv == NULL); s->vol_cv = new double[s->ncv];
  assert(s->r_cv == NULL); s->r_cv = new double[s->ncv];
  for (int icv = 0; icv < s->ncv; ++icv) {
    FOR_I3 s->x_cv[icv][i] = 0.0;
    s->vol_cv[icv] = 0.0;
    s->r_cv[icv] = 0.0;
  }
  
  assert(s->faocv_i == NULL); s->faocv_i = new int[s->ncv+1];
  s->faocv_i[0] = 0;

  double my_buf[2] = { 0.0, 0.0 };
  int * fa_flag = NULL;
  FOR_RANK send_count[rank] = 0;

  for (int cycle = 0; cycle < 2; ++cycle) {

    if (cycle == 0) {
      s->nfa_i = 0;
      s->nfa = 0;
    }
    else {
      // now use nfa_i,nfa as counters offset properly...
      s->nfa = s->nfa_i;
      s->nfa_i = 0;
    }
    
    for (int ip = 0; ip < points->np; ++ip) {

      assert(vdArray[ip].checkStatusBits(VD_BUILT_AND_MATCHED_BIT));
      if (cycle == 0) {
	// first time through we count faces. Note that we can use a 
	// set here to combine multiple faces/face loops that are shared with the 
	// same neighbor. In the final grid there is at most ONE face with any RBI nbr.
	assert(internalFaceSet.empty());
      }
      else {
	// second time through we build everything... 
	assert(ifdVec.empty());
	assert(internalFaceMap.empty());
      }
      
      for (int ied = 0; ied < vdArray[ip].getNedMain(); ++ied) {

	// start with r2 calc...
	if (cycle == 0) {
	  FOR_I2 {
	    const double * const x_no = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	    const double this_r2 = DOT_PRODUCT(x_no,x_no);
	    s->r_cv[ip] = max(s->r_cv[ip],this_r2);
	  }
	}

	// then other edge-based geometry...
	FOR_I2 {
	  const int ifa = vdArray[ip].getFaoed(ied,i);
	  // consider internal faces only at this point...
	  if (ifa < 0) {
	    // recall vdArray[ip] uses -1 indexing for faces...
	    assert((-ifa-1 >= 0)&&(-ifa-1 < vdArray[ip].getNfa()));
	    // confirm that this is a group0 face. It has to be because
	    // we are looping on group0 edges...
	    // recall that faces have been paired in Step2, and active faces are paired faces where 
	    // neither face is a "zero" face (i.e. its area is below a certain tolerance)...
	    if (vdArray[ip].faceIsActive(-ifa-1)) {
	      // an active face can still be connected to a non-zero group -- this would be an
	      // open face, and should not be included in the normal...
	      int group_nbr,ifa_nbr; 
	      vdArray[ip].setGiForFaceNbr(group_nbr,ifa_nbr,-ifa-1);
	      if (group_nbr == 0) {
		// we have an active face connected to another main group, i.e. NOT open, so include this...
		int group,rank,bits,index;
		vdArray[ip].setGrbiForFace(group,rank,bits,index,-ifa-1);
		assert(bits == 0); // can be periodic in the future
		assert(group == 0); // must be group 0 -- this is a check.
		const pair<int,int> rbiHash = pair<int,int>(BitUtils::packRankBitsNew(rank,bits),index);
		if (cycle == 0) {
		  internalFaceSet.insert(rbiHash);
		}
		else {
		  map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
		  if (iter == internalFaceMap.end()) {
		    internalFaceMap[rbiHash] = ifdVec.size();
		    ifdVec.push_back(FaceGeometryData(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i))));
		  }
		  else {
		    const int ifd = iter->second;
		    const double * const x1 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
		    const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
		    if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		      const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		      const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		      s->vol_cv[ip] += this_vol;
		      ifdVec[ifd].area += this_vol;
		      FOR_J3 {
			const double tmp = this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]);
			ifdVec[ifd].xc[j] += tmp;
			s->x_cv[ip][j] += tmp;
			ifdVec[ifd].normal[j] += this_n[j];
		      }
		    }
		    else {
		      // face loop should be 1-directional...
		      assert(ifdVec[ifd].x0 == x2);
		    }
		  }
		}
	      }
	    }
	  }
	}
      }
      
      // =============================================================
      // any orphan chunks?...
      // =============================================================
    
      int next = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
      while (next != -1) {
	// edge loop on ocdVec[next]...
	for (int ied = 0; ied < ocdVec[next].getNed(); ++ied) {

	  // start with r2 calc...
	  if (cycle == 0) {
	    FOR_I2 {
	      const double * const x_no = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
	      const double this_r2 = DOT_PRODUCT(x_no,x_no);
	      s->r_cv[ip] = max(s->r_cv[ip],this_r2);
	    }
	  }
	  
	  // then other geometry...
	  FOR_I2 {
	    const int ifa = ocdVec[next].getFaoed(ied,i);
	    if (ifa <= -ORPHAN_FACE_OFFSET) {
	      // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	      // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	      // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	      // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	      assert((-ifa-ORPHAN_FACE_OFFSET >= 0)&&(-ifa-ORPHAN_FACE_OFFSET < ocdVec[next].getNfa()));
	      const pair<int,int> rbiHash = pair<int,int>(ocdVec[next].getRankBitsForFace(-ifa-ORPHAN_FACE_OFFSET),ocdVec[next].getIndexForFace(-ifa-ORPHAN_FACE_OFFSET));
	      if (cycle == 0) {
		internalFaceSet.insert(rbiHash);
	      }
	      else {
		map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
		if (iter == internalFaceMap.end()) {
		  //cout << "XXXXXXXXXXXXXXXXXX Warning: new internal face introduced by orphan chunk XXXXXXXXXXXXXXXXXXX" << endl;
		  internalFaceMap[rbiHash] = ifdVec.size();
		  ifdVec.push_back(FaceGeometryData(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i))));
		}
		else {
		  const int ifd = iter->second;
		  const double * const x1 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
		  const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
		  if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		    const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		    const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		    s->vol_cv[ip] += this_vol;
		    ifdVec[ifd].area += this_vol;
		    FOR_J3 {
		      const double tmp = this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]); 
		      ifdVec[ifd].xc[j] += tmp;
		      s->x_cv[ip][j] += tmp;
		      ifdVec[ifd].normal[j] += this_n[j];
		    }
		  }
		  else {
		    // face loop should be 1-directional...
		    assert(ifdVec[ifd].x0 == x2);
		  }
		}
	      }
	    }
	  }
	}
	next = ocdVec[next].next; 
      }

      if (cycle == 0) {
	
	// use the set to count how many there are... 

	s->faocv_i[ip+1] = s->faocv_i[ip] + internalFaceSet.size();
	
	for (set<pair<int,int> >::const_iterator iter = internalFaceSet.begin(); iter != internalFaceSet.end(); ++iter) {
	  int rank,bits;
	  BitUtils::unpackRankBitsNew(rank,bits,iter->first);
	  const int index = iter->second;
	  assert(bits == 0);
	  if ((rank == mpi_rank)&&(bits == 0)) {
	    assert(index != ip);
	    if (index > ip) // only count a new internal face when its index (i.e. ip_nbr) > ip
	      ++s->nfa_i;
	  }
	  else {
	    assert(bits == 0); // could count periodic faces separately here
	    ++s->nfa;
	  }
	}
	
	internalFaceSet.clear();

      }
      else {
	
	int foc = s->faocv_i[ip];
	for (map<const pair<int,int>,int>::const_iterator iter = internalFaceMap.begin(); iter != internalFaceMap.end(); ++iter) {
	  int rank,bits;
	  BitUtils::unpackRankBitsNew(rank,bits,iter->first.first);
	  const int index = iter->first.second;
	  const int ifd = iter->second;
	  if ((rank == mpi_rank)&&(bits == 0)) {
	    assert(index != ip);
	    if (index > ip) {
	      // create a new face...
	      const int ifa = s->nfa_i++;
	      // set cvofa...
	      assert(s->cvofa[ifa][0] == -1);
	      s->cvofa[ifa][0] = ip;
	      assert(s->cvofa[ifa][1] == -1);
	      s->cvofa[ifa][1] = index;
	      // faocv_v...
	      assert(s->faocv_v[foc] == -1);
	      s->faocv_v[foc++] = ifa;
	      // set geometry...
	      FOR_I3 s->fa[ifa].unit_n[i] = 0.5*ifdVec[ifd].normal[i]; // ifdVec[ifd].normal is actually twice the normal
	      assert(s->fa[ifa].area == 0.0); // leave area-weighted normal for now
	      FOR_I3 s->fa[ifa].x[i] = ifdVec[ifd].xc[i]/(3.0*ifdVec[ifd].area) + points->xp[ip][i];
	      // and touch the flag...
	      assert(fa_flag[ifa] == 0);
	      fa_flag[ifa] = 1;
	    }
	    else {
	      // this face already lives with a previous cv...
	      int ifa = -1;
	      int foc_nbr;
	      for (foc_nbr = s->faocv_i[index]; foc_nbr != s->faocv_i[index+1]; ++foc_nbr) {
		ifa = s->faocv_v[foc_nbr]; assert(ifa >= 0);
		if (s->cvofa[ifa][0] == index) {
		  if (s->cvofa[ifa][1] == ip) {
		    // got the match...
		    break;
		  }
		}
		else {
		  assert(s->cvofa[ifa][1] == index);
		  // cannot be this one...
		}
	      }
	      // ensure we broke out above - if we did not find one, then 
	      // there is a face match problem...
	      assert(foc_nbr != s->faocv_i[index+1]);
	      assert(ifa != -1);
	      // touch the flag...
	      assert(fa_flag[ifa] == 1);
	      fa_flag[ifa] = 2;
	      // add the face to faocv_v...
	      s->faocv_v[foc++] = ifa;
	      // average the geometry...
	      const double this_dn[3] = { s->fa[ifa].unit_n[0] + 0.5*ifdVec[ifd].normal[0],
					  s->fa[ifa].unit_n[1] + 0.5*ifdVec[ifd].normal[1],
					  s->fa[ifa].unit_n[2] + 0.5*ifdVec[ifd].normal[2] };
	      my_buf[0] = max(my_buf[0],DOT_PRODUCT(this_dn,this_dn)); // no nomalization?
	      FOR_I3 s->fa[ifa].unit_n[i] = 0.5*( s->fa[ifa].unit_n[i] - 0.5*ifdVec[ifd].normal[i] );
	      assert(s->fa[ifa].area == 0.0);
	      s->fa[ifa].area = MAG(s->fa[ifa].unit_n);
	      assert(s->fa[ifa].area > 0.0);
	      FOR_I3 s->fa[ifa].unit_n[i] /= s->fa[ifa].area;
	      // and the distance...
	      double this_x_fa[3]; FOR_I3 this_x_fa[i] = ifdVec[ifd].xc[i]/(3.0*ifdVec[ifd].area) + points->xp[ip][i];
	      my_buf[1] = max(my_buf[1],DIST2(this_x_fa,s->fa[ifa].x));
	      FOR_I3 s->fa[ifa].x[i] = 0.5*(s->fa[ifa].x[i]+this_x_fa[i]);
	    }
	  }
	  else {
	    assert(bits == 0); // could count periodic faces separately here
	    assert(rank != mpi_rank); // for now
	    send_count[rank] += 3; // ip, rank-bits_nbr, index_nbr...  
	    const int ifa = s->nfa++;
	    // set cvofa...
	    assert(s->cvofa[ifa][0] == -1);
	    s->cvofa[ifa][0] = ip;
	    assert(s->cvofa[ifa][1] == -1);
	    // look for a ghost cv...
	    const uint8 rbiHash = BitUtils::packRankBitsIndex(rank,bits,index);
	    map<const uint8,int>::const_iterator iter = rbiMap.find(rbiHash);
	    if (iter == rbiMap.end()) {
	      rbiMap[rbiHash] = s->cvofa[ifa][1] = s->ncv_g++;
	    }
	    else {
	      s->cvofa[ifa][1] = iter->second;
	    }
	    // faocv_v...
	    assert(s->faocv_v[foc] == -1);
	    s->faocv_v[foc++] = ifa;
	    // set geometry - we will average out of this loop...
	    FOR_I3 s->fa[ifa].unit_n[i] = 0.5*ifdVec[ifd].normal[i];
	    assert(s->fa[ifa].area == 0.0); // leave area-weighted normal for now
	    FOR_I3 s->fa[ifa].x[i] = ifdVec[ifd].xc[i]/(3.0*ifdVec[ifd].area) + points->xp[ip][i];
	    // and touch the flag...
	    assert(fa_flag[ifa] == 0);
	    fa_flag[ifa] = 1;
	  }
	}
	assert(foc == s->faocv_i[ip+1]);

	// and clear...

	ifdVec.clear();
	internalFaceMap.clear();
	
      }
    
    } // for ip

    // ===============================================
    // memory allocation
    // ===============================================

    if (cycle == 0) {
      
      assert(s->faocv_v == NULL);
      const int faocv_s = s->faocv_i[s->ncv];
      if (!(faocv_s == 2*s->nfa_i + s->nfa))
	cout << "rank: " << mpi_rank << " faocv_s: " << faocv_s << " 2*nfa_i + nfa: " << 2*s->nfa_i + s->nfa << endl;
      assert(faocv_s == 2*s->nfa_i + s->nfa);
      s->faocv_v = new int[faocv_s];
      for (int foc = 0; foc < faocv_s; ++foc)
	s->faocv_v[foc] = -1;
      
      // the local number of faces will be nfa_i+nfa...
      
      s->nfa += s->nfa_i;
      assert(s->fa == NULL); s->fa = new StaticSolver::FaBase[s->nfa];
      assert(s->cvofa == NULL); s->cvofa = new int[s->nfa][2];
      for (int ifa = 0; ifa < s->nfa; ++ifa)
	s->cvofa[ifa][0] = s->cvofa[ifa][1] = -1;

      // and the flags are used for counting...
      assert(fa_flag == NULL); fa_flag = new int[s->nfa];
      for (int ifa = 0; ifa < s->nfa; ++ifa)
	fa_flag[ifa] = 0;

      // reduce global face count for checking... 
      
      int8 my_nfa2_global = s->nfa + s->nfa_i; // add nfa_i again. This means all faces are double-counted.
      int8 nfa2_global;
      MPI_Reduce(&my_nfa2_global,&nfa2_global,1,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
	assert(nfa2_global%2 == 0); // should be even
	cout << " > nfa_global: " << nfa2_global/2 << endl; // divide by zero
      }
      
    }
    
  }
  
  // check it was all set as expected so far...
  
  for (int foc = 0; foc < s->faocv_i[s->ncv]; ++foc)
    assert(s->faocv_v[foc] >= 0);
  
  for (int ifa = 0; ifa < s->nfa_i; ++ifa) {
    assert((s->cvofa[ifa][0] >= 0)&&(s->cvofa[ifa][0] < s->ncv));
    assert((s->cvofa[ifa][1] >= 0)&&(s->cvofa[ifa][1] < s->ncv));
    assert(fa_flag[ifa] == 2);
  }

  // the second range of faces we check and pack at the same time below... 

  // reorder ghost data in rank/bits/index order...

  assert(rbiMap.size() == s->ncv_g-s->ncv);
  int * cv_flag_g = new int[s->ncv_g-s->ncv];
  assert(s->rbi_g == NULL); s->rbi_g = new uint8[s->ncv_g-s->ncv];
  int ig = 0;
  for (map<const uint8,int>::const_iterator iter = rbiMap.begin(); iter != rbiMap.end(); ++iter) {
    s->rbi_g[ig] = iter->first;
    cv_flag_g[iter->second-s->ncv] = ig++;
  }
  rbiMap.clear();
  
  // inter-processor faces...

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  assert((s->nfa-s->nfa_i)*3 == send_disp[mpi_size-1] + send_count[mpi_size-1]);
  
  int * send_buf_int = new int[(s->nfa-s->nfa_i)*3];
  double * send_buf_double = new double[(s->nfa-s->nfa_i)*6];

  for (int ifa = s->nfa_i; ifa < s->nfa; ++ifa) {
    assert((s->cvofa[ifa][0] >= 0)&&(s->cvofa[ifa][0] < s->ncv));
    assert((s->cvofa[ifa][1] >= s->ncv)&&(s->cvofa[ifa][1] < s->ncv_g));
    assert(fa_flag[ifa] == 1); // touched once so far
    const int icv_old = s->cvofa[ifa][1];
    s->cvofa[ifa][1] = s->ncv + cv_flag_g[icv_old-s->ncv];
    assert((s->cvofa[ifa][1] >= s->ncv)&&(s->cvofa[ifa][1] < s->ncv_g));
    // pack this face...
    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,s->rbi_g[s->cvofa[ifa][1]-s->ncv]);
    assert(rank != mpi_rank);
    assert(bits == 0);
    const int inverse_bits = 0;
    send_buf_int[send_disp[rank]]   = index;
    send_buf_int[send_disp[rank]+1] = BitUtils::packRankBitsNew(mpi_rank,inverse_bits);
    send_buf_int[send_disp[rank]+2] = s->cvofa[ifa][0];
    FOR_I3 send_buf_double[send_disp[rank]*2+i] = s->fa[ifa].unit_n[i]; // not a unit vector yet
    FOR_I3 send_buf_double[send_disp[rank]*2+3+i] = s->fa[ifa].x[i];
    send_disp[rank] += 3;
  }
  delete[] cv_flag_g; 
  
  // reset send_disp...
  
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
  
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
	
  int * recv_buf_int = new int[recv_count_sum];
  MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
  delete[] send_buf_int;   
  
  FOR_RANK {
    send_count[rank] *= 2;
    send_disp[rank] *= 2;
    recv_count[rank] *= 2;
    recv_disp[rank] *= 2;
  }

  double * recv_buf_double = new double[recv_count_sum*2];
  MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  delete[] send_buf_double;   
  
  for (int irecv = 0; irecv < recv_count_sum; irecv += 3) {
    const int icv = recv_buf_int[irecv];
    assert((icv >= 0)&&(icv < s->ncv));
    int rank,bits;
    BitUtils::unpackRankBitsNew(rank,bits,recv_buf_int[irecv+1]);
    int index = recv_buf_int[irecv+2];
    const uint8 rbiHash = BitUtils::packRankBitsIndex(rank,bits,index);
    int ifa = -1;
    int foc;
    for (foc = s->faocv_i[icv]; foc != s->faocv_i[icv+1]; ++foc) {
      ifa = s->faocv_v[foc];
      if (s->cvofa[ifa][1] >= s->ncv) {
	assert(ifa >= s->nfa_i);
	if (s->rbi_g[s->cvofa[ifa][1]-s->ncv] == rbiHash)
	  break;
      }
    }
    assert(foc != s->faocv_i[icv+1]);
    assert(ifa != -1);
    assert(fa_flag[ifa] == 1);
    fa_flag[ifa] = 2;
    // the normal is in the first part of the recv_buf_double...
    double this_dn[3] = { 
      s->fa[ifa].unit_n[0] + recv_buf_double[irecv*2  ],
      s->fa[ifa].unit_n[1] + recv_buf_double[irecv*2+1],
      s->fa[ifa].unit_n[2] + recv_buf_double[irecv*2+2] };
    my_buf[0] = max(my_buf[0],DOT_PRODUCT(this_dn,this_dn));
    FOR_I3 s->fa[ifa].unit_n[i] = 0.5*( s->fa[ifa].unit_n[i] - recv_buf_double[irecv*2+i] );
    assert(s->fa[ifa].area == 0.0);
    s->fa[ifa].area = MAG(s->fa[ifa].unit_n);
    assert(s->fa[ifa].area > 0.0);
    FOR_I3 s->fa[ifa].unit_n[i] /= s->fa[ifa].area;
    // and the distance...
    double this_x_fa[3]; FOR_I3 this_x_fa[i] = recv_buf_double[irecv*2+3+i];
    my_buf[1] = max(my_buf[1],DIST2(this_x_fa,s->fa[ifa].x));
    FOR_I3 s->fa[ifa].x[i] = 0.5*(s->fa[ifa].x[i]+this_x_fa[i]);
  }
  delete[] recv_buf_int;
  delete[] recv_buf_double;

  // confirm inter-processor faces have been visited twice...

  for (int ifa = s->nfa_i; ifa < s->nfa; ++ifa) {
    assert(fa_flag[ifa] == 2);
  }
  delete[] fa_flag;
  
  // reduce/report the tol data...
  
  double buf[2];
  MPI_Reduce(my_buf,buf,2,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
  if (mpi_rank == 0)
    cout << " > internal face area mismatch: " << sqrt(buf[0]) << ", internal face centroid mismatch: " << sqrt(buf[1]) << endl;
  
  // ================================================
  // ================================================
  // ================================================
  // ================================================
  // now boundary faces...
  // ================================================
  // ================================================
  // ================================================
  // ================================================

  vector<double> bfDoubleVec;
  vector<int> bfIntVec;
  assert(s->bfocv_i == NULL); s->bfocv_i = new int[s->ncv+1];
  
  vector<int> stIntVec; // stocv_v eventually
  assert(s->stocv_i == NULL); s->stocv_i = new int[s->ncv+1];
  
  map<const int,int> boundaryFaceMap;
  set<pair<int,int> > stLinkSet; // surface tri link
  
  s->bfocv_i[0] = 0;
  s->stocv_i[0] = 0;
  
  for (int ip = 0; ip < points->np; ++ip) {
    if (vdArray[ip].checkStatusBits(VD_HAS_BOUNDARY_BIT)) {
      
      assert(ifdVec.empty());
      assert(boundaryFaceMap.empty());
      assert(stLinkSet.empty());

      for (int ied = 0; ied < vdArray[ip].getNedMain(); ++ied) {
	
	// stLinkSet first...

	if ((vdArray[ip].getFaoed(ied,0) >= 0)&&(vdArray[ip].getFaoed(ied,1) >= 0)) {
	  const int ist0 = vdArray[ip].getFaoed(ied,0);
	  const int ist1 = vdArray[ip].getFaoed(ied,1);
	  assert(ist0 != ist1);
	  const int izone0 = surface->getZnost(ist0); assert(izone0 >= 0);
	  const int izone1 = surface->getZnost(ist1); assert(izone1 >= 0);
	  if (izone0 == izone1) {
	    if (surface->checkCoplanar(ist0,ist1,boundary_face_crease_angle)) {
	      stLinkSet.insert(pair<int,int>(min(ist0,ist1),max(ist0,ist1)));
	    }
	  }
	}
	
	// now just loop on edges...

	FOR_I2 {
	  const int ifa = vdArray[ip].getFaoed(ied,i);
	  // consider boundary faces only at this point...
	  if (ifa >= 0) {
	    map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	    if (iter == boundaryFaceMap.end()) {
	      boundaryFaceMap[ifa] = ifdVec.size();
	      ifdVec.push_back(FaceGeometryData(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i))));
	    }
	    else {
	      const int ifd = iter->second;
	      const double * const x1 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	      const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
	      if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		const double this_area = MAG(this_n);
		const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		ifdVec[ifd].area += this_area;
		s->vol_cv[ip] += this_vol;
		FOR_J3 {
		  ifdVec[ifd].xc[j] += this_area*(ifdVec[ifd].x0[j]+x1[j]+x2[j]);
		  s->x_cv[ip][j] += this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]);
		  ifdVec[ifd].normal[j] += this_n[j];
		}
	      }
	      else {
		// face loop should be 1-directional...
		assert(ifdVec[ifd].x0 == x2);
	      }
	    }
	  }
	}
      }
      
      // any orphan chunks?...
      
      int next = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
      while (next != -1) {
	// edge loop on ocdVec[next]...
	for (int ied = 0; ied < ocdVec[next].getNed(); ++ied) {
	  
	  // stLinkSet first...

	  if ((ocdVec[next].getFaoed(ied,0) >= 0)&&(ocdVec[next].getFaoed(ied,1) >= 0)) {
	    const int ist0 = ocdVec[next].getFaoed(ied,0);
	    const int ist1 = ocdVec[next].getFaoed(ied,1);
	    assert(ist0 != ist1);
	    const int izone0 = surface->getZnost(ist0); assert(izone0 >= 0);
	    const int izone1 = surface->getZnost(ist1); assert(izone1 >= 0);
	    if (izone0 == izone1) {
	      if (surface->checkCoplanar(ist0,ist1,boundary_face_crease_angle)) {
		stLinkSet.insert(pair<int,int>(min(ist0,ist1),max(ist0,ist1)));
	      }
	    }
	  }

	  // then face geometry...
	  
	  FOR_I2 {
	    const int ifa = ocdVec[next].getFaoed(ied,i);
	    if (ifa >= 0) {
	      // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	      // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	      // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	      // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	      map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	      if (iter == boundaryFaceMap.end()) {
		boundaryFaceMap[ifa] = ifdVec.size();
		ifdVec.push_back(FaceGeometryData(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i))));
	      }
	      else {
		const int ifd = iter->second;
		const double * const x1 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
		const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
		if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		  const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		  const double this_area = MAG(this_n);
		  const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		  ifdVec[ifd].area += this_area;
		  s->vol_cv[ip] += this_vol;
		  FOR_J3 {
		    ifdVec[ifd].xc[j] += this_area*(ifdVec[ifd].x0[j]+x1[j]+x2[j]); 
		    s->x_cv[ip][j] += this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]); 
		    ifdVec[ifd].normal[j] += this_n[j];
		  }
		}
		else {
		  // face loop should be 1-directional...
		  assert(ifdVec[ifd].x0 == x2);
		}
	      }
	    }
	  }
	}
	next = ocdVec[next].next; 
      }

      // at this point, the boundaryFaceMap links to the surface tris. Now combine surface tris to 
      // form the final set of boundary faces. In the future we can return here and build more 
      // boundary face data if required, or build the set of tris associated with each boundary face...
      
      assert(!boundaryFaceMap.empty());
      assert(boundaryFaceMap.size() == ifdVec.size());
      const int nbf_full = boundaryFaceMap.size(); 
      int * bf_flag = new int[nbf_full];
      for (int ibf = 0; ibf < nbf_full; ++ibf)
	bf_flag[ibf] = ibf;
      
      // now use stLinkSet to combine faces...
      
      for (set<pair<int,int> >::const_iterator iter = stLinkSet.begin(); iter != stLinkSet.end(); ++iter) {
	// find the bf indices associated with these faces...
	map<const int,int>::const_iterator iter0 = boundaryFaceMap.find(iter->first);
	assert(iter0 != boundaryFaceMap.end());
	map<const int,int>::const_iterator iter1 = boundaryFaceMap.find(iter->second);
	assert(iter1 != boundaryFaceMap.end());
	int ibf0 = iter0->second; assert((ibf0 >= 0)&&(ibf0 < nbf_full));
	while(bf_flag[ibf0] != ibf0)
	  ibf0 = bf_flag[ibf0];
	int ibf1 = iter1->second; assert((ibf1 >= 0)&&(ibf1 < nbf_full));
	while(bf_flag[ibf1] != ibf1)
	  ibf1 = bf_flag[ibf1];
	bf_flag[ibf0] = bf_flag[ibf1] = min(ibf0,ibf1);
      }
      stLinkSet.clear();
      
      // now count the final boundaries...
      //int nbf = 0;
      s->nbf = 0;
      for (int ibf = 0; ibf < nbf_full; ++ibf) {
	if (bf_flag[ibf] == ibf) {
	  ++s->nbf;
	  bf_flag[ibf] = -s->nbf;
	}
	else {
	  int ibf_ = bf_flag[ibf];
	  while (ibf_ >= 0)
	    ibf_ = bf_flag[ibf_];
	  bf_flag[ibf] = ibf_;
	}
      }
      
      // bf_flag should now contain the final ibf in -1 indexing...

      assert(s->nbf >= 1);
      int ibf_offset = bfIntVec.size();
      bfIntVec.resize(ibf_offset+s->nbf);
      assert(bfDoubleVec.size() == ibf_offset*6);
      bfDoubleVec.resize((ibf_offset+s->nbf)*6);
      for (int ibf = 0; ibf < s->nbf; ++ibf) {
	bfIntVec[ibf_offset+ibf] = -1;
	FOR_I6 bfDoubleVec[(ibf_offset+ibf)*6+i] = 0.0;
      }

      // condense the boundary face stuff...
      
      for (int ibf_full = 0; ibf_full < nbf_full; ++ibf_full) {
	const int ibf = -bf_flag[ibf_full]-1;
	assert((ibf >= 0)&&(ibf < s->nbf));
	FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+i] += ifdVec[ibf_full].normal[i];
      }
      
      for (int ibf_full = 0; ibf_full < nbf_full; ++ibf_full) {
	const int ibf = -bf_flag[ibf_full]-1;
	assert((ibf >= 0)&&(ibf < s->nbf));
	if (ifdVec[ibf_full].area > 0.0) {
	  const double dp = 
	    bfDoubleVec[(ibf_offset+ibf)*6  ]*ifdVec[ibf_full].normal[0] + 
	    bfDoubleVec[(ibf_offset+ibf)*6+1]*ifdVec[ibf_full].normal[1] + 
	    bfDoubleVec[(ibf_offset+ibf)*6+2]*ifdVec[ibf_full].normal[2];
	  FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+3+i] += ifdVec[ibf_full].xc[i]*dp/ifdVec[ibf_full].area;
	}
      }
      
      // and set the zone, and build stIntVec...
      
      int st_offset = stIntVec.size();
      stIntVec.resize(st_offset+boundaryFaceMap.size());
      for (map<const int,int>::const_iterator iter = boundaryFaceMap.begin(); iter != boundaryFaceMap.end(); ++iter) {
	const int ist = iter->first;
	const int ibf_full = iter->second; assert((ibf_full >= 0)&&(ibf_full < nbf_full));
	const int ibf = -bf_flag[ibf_full]-1;
	const int izone = surface->getZnost(ist); assert(izone >= 0);
	if (bfIntVec[ibf_offset+ibf] == -1)
	  bfIntVec[ibf_offset+ibf] = izone;
	else {
	  assert(bfIntVec[ibf_offset+ibf] == izone);
	}
	// also add to stIntvec...
	stIntVec[st_offset++] = ist;
      }
      assert(st_offset == stIntVec.size());

      delete[] bf_flag;
      
      // and normalize the data. Should remove any zeros in the future -- currently
      // just check...
      
      for (int ibf = 0; ibf < s->nbf; ++ibf) {
	assert(bfIntVec[ibf_offset+ibf] >= 0);
	double bf_area2 = 0.0;
	FOR_I3 {
	  bfDoubleVec[(ibf_offset+ibf)*6+i] *= 0.5;
	  bf_area2 += bfDoubleVec[(ibf_offset+ibf)*6+i]*bfDoubleVec[(ibf_offset+ibf)*6+i];
	}
	assert(bf_area2 > 0.0);
	FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+3+i] = bfDoubleVec[(ibf_offset+ibf)*6+3+i]/(12.0*bf_area2) + points->xp[ip][i];
      }
      
      /*
	{
	FILE * fp = fopen("bf.dat","w");
	for (int ibf = 0; ibf < s->nbf; ++ibf) {
	fprintf(fp,"%18.15le %18.15le %18.15le\n",
	bfDoubleVec[(ibf_offset+ibf)*6+3+0],
	bfDoubleVec[(ibf_offset+ibf)*6+3+1],
	bfDoubleVec[(ibf_offset+ibf)*6+3+2]);
	}
	fclose(fp);
	writeFullCvTecplot(ip,points->xp[ip]);
	cout << "take a look" << endl;
	getchar();
	}
      */

      // cleanup...
      
      boundaryFaceMap.clear();
      ifdVec.clear();
      
    }
    
    // set the bfocv_i...
    s->bfocv_i[ip+1] = bfIntVec.size();
    
    // and the stocv_i...
    s->stocv_i[ip+1] = stIntVec.size();
  
    // =======================================================================
    // use this ip loop to also adjust centroid and volume...
    // =======================================================================
	
    assert(s->vol_cv[ip] > 0.0);

    // TODO: should the solver store the voronoi points or cv centroids?.... 
    // for now, store the cv centroids. The voronoi points are still available if required
    // from the points->xp[][]...
    FOR_I3 s->x_cv[ip][i] = s->x_cv[ip][i]/(4.0*s->vol_cv[ip]) + points->xp[ip][i]; // add the offset of the Voronoi point
    //FOR_I3 s->x_cv[ip][i] = points->xp[ip][i]; // OR just set x_cv in the solvers to the voronoi points
    s->vol_cv[ip] /= 6.0;

    // and sqrt r_cv...
    
    assert(s->r_cv[ip] > 0.0);
    s->r_cv[ip] = sqrt(s->r_cv[ip]);
    
  } // for (int ip...
  
  // report the volume...
  
  double my_vol_sum = 0.0;
  //FOR_ICV my_vol_sum += s->vol_cv[icv];
  for (int icv = 0; icv < s->ncv; ++icv) my_vol_sum += s->vol_cv[icv];
  double vol_sum;
  MPI_Reduce(&my_vol_sum,&vol_sum,1,MPI_DOUBLE,MPI_SUM,0,mpi_comm);
  if (mpi_rank == 0)
    cout << " > Voronoi volume: " << vol_sum << endl;

  // the boundary faces...

  int * zone_count = new int[surface->zoneVec.size()];
  for (int izone = 0; izone < surface->zoneVec.size(); ++izone)
    zone_count[izone] = 0;
  
  for (int ii = 0; ii < bfIntVec.size(); ++ii) {
    const int izone = bfIntVec[ii];
    assert((izone >= 0)&&(izone < surface->zoneVec.size()));
    ++zone_count[izone];
  }
  
  // temporarily use zone_disp to hold the global ibf count. Here we use just an 
  // int. Hopefully no zone has more than 2B faces, right ;)
  
  int * zone_disp = new int[surface->zoneVec.size()];
  MPI_Allreduce(zone_count,zone_disp,surface->zoneVec.size(),MPI_INT,MPI_SUM,mpi_comm);
  
  assert(s->bfZoneVec.empty());
  s->nbf = 0;
  for (int izone = 0; izone < surface->zoneVec.size(); ++izone) {
    // if ANYONE has this zone, we ALL get this zone, even if our local ibf count is empty...
    if (zone_disp[izone] > 0) {
      s->bfZoneVec.push_back(StaticSolver::BfZone(surface->zoneVec[izone].getName(),s->nbf,s->nbf+zone_count[izone]));
      s->nbf += zone_count[izone];
    }
  }
  assert(s->nbf == bfIntVec.size());
  
  // switch zone_disp to a disp...
  zone_disp[0] = 0;
  for (int izone = 1; izone < surface->zoneVec.size(); ++izone)
    zone_disp[izone] = zone_disp[izone-1] + zone_count[izone-1];
  assert(zone_disp[surface->zoneVec.size()-1] + zone_count[surface->zoneVec.size()-1] == bfIntVec.size());
  
  // and now allocate and populate the boundary face data structure...
  
  assert(s->bf == NULL); s->bf = new StaticSolver::BfBase[s->nbf];
  assert(s->bfocv_v == NULL); s->bfocv_v = new int[s->nbf];
  assert(s->bzobf == NULL); s->bzobf = new int[s->nbf];
  
  for (int ibf = 0; ibf < bfIntVec.size(); ++ibf) {
    const int izone = bfIntVec[ibf];
    const int ibf_new = zone_disp[izone]++;
    s->bzobf[ibf_new] = izone;
    // store the new index in bfocv_v...
    s->bfocv_v[ibf] = ibf_new;
    // and set the bf data...
    FOR_I3 s->bf[ibf_new].unit_n[i] = bfDoubleVec[ibf*6+i]; // still area-weighted
    assert(s->bf[ibf_new].area == 0.0);
    s->bf[ibf_new].area = MAG(s->bf[ibf_new].unit_n);
    assert(s->bf[ibf_new].area > 0.0);
    FOR_I3 s->bf[ibf_new].unit_n[i] /= s->bf[ibf_new].area;
    FOR_I3 s->bf[ibf_new].x[i] = bfDoubleVec[ibf*6+3+i];
  }
  
  assert(s->cvobf == NULL); s->cvobf = new int[s->nbf];
  for (int ibf = 0; ibf < s->nbf; ++ibf)
    s->cvobf[ibf] = -1;
  
  for (int icv = 0; icv < s->ncv; ++icv) {
    for (int boc = s->bfocv_i[icv]; boc != s->bfocv_i[icv+1]; ++boc) {
      const int ibf = s->bfocv_v[boc];
      assert(s->cvobf[ibf] == -1);
      s->cvobf[ibf] = icv;
      // and the viscous closure...
      assert(s->bf[ibf].area_over_delta == 0.0);
      assert(s->bf[ibf].area > 0.0);
      // for viscous closure...
      const double delta_vol_area = 0.5*s->vol_cv[icv]/s->bf[ibf].area;
      const double delta_vol = 0.5*pow(s->vol_cv[icv],1.0/3.0);
      s->bf[ibf].area_over_delta = s->bf[ibf].area/min(delta_vol_area,delta_vol);
      assert(s->bf[ibf].area_over_delta > 0.0);
    }
  }
  
  for (int ibf = 0; ibf < s->nbf; ++ibf)
    assert(s->cvobf[ibf] >= 0);
  
  delete[] zone_count;
  delete[] zone_disp;

  // complete stocv_v...
  
  assert(s->stocv_i[s->ncv] == stIntVec.size());
  assert(s->stocv_v == NULL); s->stocv_v = new int[stIntVec.size()];
  // in the future we will build a subsurface here. For now, take a copy of the 
  // surface and just copy the index in stIntVec into stocv_v...
  assert(s->surface == NULL); s->surface = surface; // HACK -- use subsurface eventually so we can throw away VoronoiPart
  for (int soc = 0; soc < stIntVec.size(); ++soc) 
    s->stocv_v[soc] = stIntVec[soc];
  
  // cleanup...
  
  delete[] send_count;
  delete[] send_disp;
  delete[] recv_count;
  delete[] recv_disp;
  
}


















#ifdef fdjksfjdklsfd

void checkGclExtended() {

  COUT1("StaticSolver::checkGclExtended()");

  assert(fa2);

  double (*gcl)[3] = new double[ncv][3];
  FOR_ICV FOR_I3 gcl[icv][i] = 0.0;
    
  for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
    const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
    const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= 0)&&(icv1 < ncv));
    assert(icv1 > icv0);
    FOR_I3 gcl[icv0][i] += fa2[ifa2].area*fa2[ifa2].unit_n[i];
    FOR_I3 gcl[icv1][i] -= fa2[ifa2].area*fa2[ifa2].unit_n[i];
  }

  for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
    const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
    const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
    assert(icv1 > icv0);
    FOR_I3 gcl[icv0][i] += fa2[ifa2].area*fa2[ifa2].unit_n[i];
  }
    
  // all boundaries are outward-pointing...
  FOR_ICV {
    for (int boc = bfocv_i[icv]; boc != bfocv_i[icv+1]; ++boc) {
      const int ibf = bfocv_v[boc];
      FOR_I3 gcl[icv][i] += bf[ibf].area*bf[ibf].unit_n[i];
    }
  }

  /*
    {
    char filename[128];
    sprintf(filename,"gcl.%03d.dat",mpi_rank);
    FILE * fp = fopen(filename,"w");
    FOR_ICV {
    fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
    x_cv[icv][0],x_cv[icv][1],x_cv[icv][2],
    gcl[icv][0],gcl[icv][1],gcl[icv][2]);
    }
    fclose(fp);
    }
  */

  dumpRange(gcl,ncv,"GCL (should be small)");
    
  delete[] gcl;
    
}

void checkGradExtended() {
    
  COUT1("StaticSolverOps::checkGradExtended()");
    
  //assert(b_cv2Prcomm);
    
  const double grad_check[3] = { 1.1234, -1.3243, 1.5321 }; // some order-1 gradient
  //const double grad_check[3] = { 1.0, 1.0, 1.0 }; 
    
  double * phi = new double[ncv_g2];
  for (int icv = 0; icv < ncv_g2; ++icv) 
    phi[icv] = DOT_PRODUCT(x_cv[icv],grad_check);
    
  double (*grad_phi)[3] = new double[ncv][3];
  FOR_ICV FOR_I3 grad_phi[icv][i] = 0.0;
    
  for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
    const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
    const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= 0)&&(icv1 < ncv));
    double flux[3];	FOR_I3 flux[i] = 0.5*fa2[ifa2].area*fa2[ifa2].unit_n[i]*(phi[icv0]+phi[icv1]) + 0.5*fa2[ifa2].c[i]*(phi[icv1]-phi[icv0]);
    FOR_I3 grad_phi[icv0][i] += flux[i];
    FOR_I3 grad_phi[icv1][i] -= flux[i];
  }
      
  for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
    const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
    const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
    double flux[3];	FOR_I3 flux[i] = 0.5*fa2[ifa2].area*fa2[ifa2].unit_n[i]*(phi[icv0]+phi[icv1]) + 0.5*fa2[ifa2].c[i]*(phi[icv1]-phi[icv0]);
    FOR_I3 grad_phi[icv0][i] += flux[i];
  }
    
  // and close the gradient at the boundary...
    
  for (int ibf = 0; ibf < nbf; ++ibf) {
    const int icv = cvobf[ibf];
    const double phi_bf = DOT_PRODUCT(bf[ibf].x,grad_check);
    FOR_I3 grad_phi[icv][i] += phi_bf*bf[ibf].area*bf[ibf].unit_n[i];
  }
      
  for (int icv = 0; icv < ncv; ++icv) {
    FOR_I3 grad_phi[icv][i] /= vol_cv[icv]*grad_check[i]; // to produce 1
  }
    
  dumpRange(grad_phi,ncv,"extended grad");
    
  FILE * fp = fopen("grad.dat","w");
  FOR_ICV {
    fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
	    x_cv[icv][0],x_cv[icv][1],x_cv[icv][2],
	    grad_phi[icv][0],grad_phi[icv][1],grad_phi[icv][2]);
  }
  fclose(fp);
    
  delete[] grad_phi;
  delete[] phi;
    
  MPI_Pause("OKOK");
  
}

  

#endif




    /*
    if (mpi_rank == 0) {
      cout << 
	" sizeof(pair<double*,int8>): " << sizeof(pair<double*,int8>) << 
	" sizeof(pair<double*,int>): " << sizeof(pair<double*,int>) << 
	" sizeof(pair<double*,pair<int,int> >): " << sizeof(pair<double*,pair<int,int> >) << endl;
    }
    MPI_Pause("ok");
    */
  
  double  x0[3] = { 0.0, 0.0, 0.0 };
  double  x1[3] = { 1.0123, 0.0, 0.0 };
  double  x2[3] = { 0.0, 1.0456, 0.0 };
  double  x3[3] = { 0.0, 0.0, 1.0789 };
  
  int iter = 0;
  while(iter++ < 10000000) {

          
	  double n[3] = {2.0*(double(rand())/double(RAND_MAX)-0.5),
                         2.0*(double(rand())/double(RAND_MAX)-0.5),
                         2.0*(double(rand())/double(RAND_MAX)-0.5)};
	  double c = 2.67*(double(rand())/double(RAND_MAX)-0.5);

	  double phi0 = DOT_PRODUCT(n,x0)+c;
	  double phi1 = DOT_PRODUCT(n,x1)+c;
	  double phi2 = DOT_PRODUCT(n,x2)+c;
	  double phi3 = DOT_PRODUCT(n,x3)+c;

	  double int_phi = tetIntegrateAbsSignedDistance2(phi0,phi1,phi2,phi3,x0,x1,x2,x3);

	  //cout << "base volume: " << SIGNED_TET_VOLUME_6(x0,x1,x2,x3) << endl;
          cout << "phi: " << phi0 << " " << phi1 << " " << phi2 << " " << phi3 << endl;
	  cout << " >> plane: " << COUT_VEC(n) << " " << c << endl;
	  cout << " >> int phi dV: " << int_phi << " ? " << SIGNED_TET_VOLUME_6(x0,x1,x2,x3)*(phi0+phi1+phi2+phi3) << endl;
          if (fabs(int_phi - SIGNED_TET_VOLUME_6(x0,x1,x2,x3)*(phi0+phi1+phi2+phi3)) > 1.0E-08)

		  getchar();
  
  }
      /*
	assert(mpi_size == 1);
	double x_check[3] = { 0.0, 0.0, 0.0 };
	
	FILE * fp = fopen("check.dat","w");
	fprintf(fp,"%18.15le %18.15le %18.15le\n",x_fa[ifa][0],x_fa[ifa][1],x_fa[ifa][2]);

	FILE * fp2 = fopen("vor.dat","w");
	fprintf(fp2,"TITLE = \"%s\"\n","debug.dat");
	fprintf(fp2,"VARIABLES = \"X\"\n");
	fprintf(fp2,"\"Y\"\n");
	fprintf(fp2,"\"Z\"\n");

	for (int coc = 0; coc < ncoc; ++coc) {
	if (rhs[coc][4] != 0.0) {
	const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];

	uint8 rbi_nbr;
	if (icv_nbr < ncv) {
	rbi_nbr = BitUtils::packRankBitsIndex(mpi_rank,0,icv_nbr);
	}
	else {
	rbi_nbr = rbi_g[icv_nbr-ncv];
	}
	    
	assert(icv_nbr < ncv);
	FOR_I3 x_check[i] += rhs[coc][4]/nonzero_sum*x_cv[icv_nbr][i];
	fprintf(fp,"%18.15le %18.15le %18.15le\n",x_cv[icv_nbr][0],x_cv[icv_nbr][1],x_cv[icv_nbr][2]);
	writeFullCvTecplotZone(fp2,icv_nbr,points->xp[icv_nbr]);
	    
	double coeff[3];
	FOR_I3 coeff[i] = rhs[coc][4]/nonzero_sum*wgt*fa_sign*n_fa[ifa][i];
	coeffVec.push_back(Coeff(rbi,rbi_nbr,coeff));
	FOR_I3 coeff[i] = -coeff[i];
	coeffVec.push_back(Coeff(rbi_fa_nbr,rbi_nbr,coeff));
	}
	}

	fprintf(fp,"%18.15le %18.15le %18.15le\n",x_check[0],x_check[1],x_check[2]);
	fclose(fp);
	fclose(fp2);
	
	// compare x_check and fa[ifa].x...
	cout << "x_check: " << COUT_VEC(x_check) << " fa[ifa].x: " << COUT_VEC(x_fa[ifa]) << " dist: " << DIST(x_check,x_fa[ifa]) << endl;

	if (DIST(x_check,x_fa[ifa]) > 1.0E-8)
	getchar();
      */

	
	
	/*
	
	LU[0][0] = A[0][0];
	LU[0][1] = A[0][1];
	LU[0][2] = A[0][2];
	LU[0][3] = A[0][3];
	LU[0][4] = A[0][4];
	LU[0][5] = C[0][0];
	LU[0][6] = C[1][0];
    
	assert(LU[0][0] != 0.0);
	LU[1][0] = A[1][0]/LU[0][0];
	LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
	LU[1][2] = A[1][2] - LU[0][2]*LU[1][0];
	LU[1][3] = A[1][3] - LU[0][3]*LU[1][0];
	LU[1][4] = A[1][4] - LU[0][4]*LU[1][0];
	LU[1][5] = C[0][1] - LU[0][5]*LU[1][0];
	LU[1][6] = C[1][1] - LU[0][6]*LU[1][0];
	
	LU[2][0] = A[2][0]/LU[0][0];
	assert(LU[1][1] != 0.0);
	LU[2][1] = (A[2][1] - LU[0][1]*LU[2][0])/LU[1][1];
	LU[2][2] = A[2][2] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
	LU[2][3] = A[2][3] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
	LU[2][4] = A[2][4] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
	LU[2][5] = C[0][2] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
	LU[2][6] = C[1][2] - LU[0][6]*LU[2][0] - LU[1][6]*LU[2][1];
	
	LU[3][0] = A[3][0]/LU[0][0];
	LU[3][1] = (A[3][1] - LU[0][1]*LU[3][0])/LU[1][1];
	assert(LU[2][2] != 0.0);
	LU[3][2] = (A[3][2] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
	LU[3][3] = A[3][3] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
	LU[3][4] = A[3][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
	LU[3][5] = C[0][3] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];
	LU[3][6] = C[1][3] - LU[0][6]*LU[3][0] - LU[1][6]*LU[3][1] - LU[2][6]*LU[3][2];
	
	LU[4][0] = A[4][0]/LU[0][0];
	LU[4][1] = (A[4][1] - LU[0][1]*LU[4][0])/LU[1][1];
	LU[4][2] = (A[4][2] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
	assert(LU[3][3] != 0.0);
	LU[4][3] = (A[4][3] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
	LU[4][4] = A[4][4] - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
	LU[4][5] = C[0][4] - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
	LU[4][6] = C[1][4] - LU[0][6]*LU[4][0] - LU[1][6]*LU[4][1] - LU[2][6]*LU[4][2] - LU[3][6]*LU[4][3];
	
	LU[5][0] = C[0][0]/LU[0][0];
	LU[5][1] = (C[0][1] - LU[0][1]*LU[5][0])/LU[1][1];
	LU[5][2] = (C[0][2] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
	LU[5][3] = (C[0][3] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
	assert(LU[4][4] != 0.0);
	LU[5][4] = (C[0][4] - LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
	LU[5][5] = - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];
	LU[5][6] = - LU[0][6]*LU[5][0] - LU[1][6]*LU[5][1] - LU[2][6]*LU[5][2] - LU[3][6]*LU[5][3] - LU[4][6]*LU[5][4];
	
	LU[6][0] = C[1][0]/LU[0][0];
	LU[6][1] = (C[1][1] - LU[0][1]*LU[6][0])/LU[1][1];
	LU[6][2] = (C[1][2] - LU[0][2]*LU[6][0] - LU[1][2]*LU[6][1])/LU[2][2];
	LU[6][3] = (C[1][3] - LU[0][3]*LU[6][0] - LU[1][3]*LU[6][1] - LU[2][3]*LU[6][2])/LU[3][3];
	LU[6][4] = (C[1][4] - LU[0][4]*LU[6][0] - LU[1][4]*LU[6][1] - LU[2][4]*LU[6][2] - LU[3][4]*LU[6][3])/LU[4][4];
	assert(LU[5][5] != 0.0);
	LU[6][5] = (- LU[0][5]*LU[6][0] - LU[1][5]*LU[6][1] - LU[2][5]*LU[6][2] - LU[3][5]*LU[6][3] - LU[4][5]*LU[6][4])/LU[5][5];
	LU[6][6] = - LU[0][6]*LU[6][0] - LU[1][6]*LU[6][1] - LU[2][6]*LU[6][2] - LU[3][6]*LU[6][3] - LU[4][6]*LU[6][4] - LU[5][6]*LU[6][5];
	assert(LU[6][6] != 0.0);
	
	// check...

	for (int i = 0; i < 7; ++i) {
	for (int j = 0; j < 7; ++j) {
	double coeff;
	if (i < 5) {
	if (j < 5) {
	coeff = A[i][j];
	}
	else {
	coeff = C[j-5][i];
	}
	}
	else if (j < 5) {
	coeff = C[i-5][j];
	}
	else {
	coeff = 0.0;
	}
	// now compute the L*U...
	{
	double l[7];
	for (int k = 0; k < i; ++k) l[k] = LU[i][k];
	l[i] = 1.0;
	for (int k = i+1; k < 7; ++k) l[k] = 0.0;
	double u[7];
	for (int k = 0; k <= j; ++k) u[k] = LU[k][j];
	for (int k = j+1; k < 7; ++k) u[k] = 0.0;
	double sum = 0.0;
	for (int k = 0; k < 7; ++k) sum += l[k]*u[k];
	//cout << coeff-sum << " ";
	if (!(fabs(coeff-sum) < 1.0E-12)) {
	cout << "WARNING: sum problem L*U: " << coeff-sum << endl;
	}
	//assert(fabs(coeff-sum) < 1.0E-12);
	}
	}
	//cout << endl;
	}
	//cout << "was this matrix zero?" << endl;
	
	*/











#ifdef JUNKUNKJ

// v3 io...

    
    }
    else if (io_version == 3) {
      
      // ================================================================================
      // ================================================================================
      // ================================================================================
      // io version 3
      // ================================================================================
      // ================================================================================
      // ================================================================================

      MPI_File fh;
      MPI_Offset offset = 0;
      MPI_File_open(mpi_comm,fname,MPI_MODE_WRONLY|MPI_MODE_CREATE,MPI_INFO_NULL,&fh);
    
      if ( mpi_rank == 0 )  { 
	int itmp[2] = {UGP_IO_MAGIC_NUMBER, io_version}; 
	cout << " > UGP_IO_VERSION: " << itmp[1] << endl;
	MPI_File_write(fh,itmp,2,MPI_INT,MPI_STATUS_IGNORE);
      }

      offset += int_size*2;

      //=========================
      // counts
      //=========================

      if ( mpi_rank == 0 ) { 
	Header header;
	sprintf(header.name,"no_fa_bf_cv_counts"); 
	header.id     = UGP_IO_NO_FA_CV_COUNTS;
	header.skip   = header_size;
	ByteSwap::setLswMswPairForInt8(header.idata+0,noora[mpi_size]);
	ByteSwap::setLswMswPairForInt8(header.idata+2,nbf_global+nfa_global);
	ByteSwap::setLswMswPairForInt8(header.idata+4,cvora[mpi_size]);
	MPI_File_write(fh,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      offset += header_size;

      // ============================
      // fa_check...
      // ============================

      if ( mpi_rank == 0 ) { 
	Header header;
	sprintf(header.name,"%s","fa_check");
	header.id   = UGP_IO_FA_CHECK;
	header.skip = header_size + int_size*(nbf_global+nfa_global);
        header.idata[0] = nbf_global+nfa_global;
	MPI_File_write(fh,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      offset += header_size;
      
      {
	
	int my_nfa_zone_max = 0;
	for (int izone = 0; izone < nzone; ++izone) 
	  my_nfa_zone_max = max(my_nfa_zone_max,(int)my_nbf_zone[izone]);
	for (int izone = 0; izone < 27; ++izone) 
	  my_nfa_zone_max = max(my_nfa_zone_max,(int)my_nfa_zone[izone]);
	
	int * fa_flag = new int[my_nfa_zone_max];
	
	int ifa_offset = 0;
	for (int izone = 0; izone < nzone; ++izone) {
	  if (nbf_zone[izone] > 0) {
	    for (int ifa = 0; ifa < my_nbf_zone[izone]; ++ifa) 
	      fa_flag[ifa] = ifa_offset+my_nbf_disp[izone]+ifa;
	    MPI_File_write_at_all(fh,offset+my_nbf_disp[izone]*sizeof(int),
				  fa_flag,my_nbf_zone[izone],
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += nbf_zone[izone]*sizeof(int);
	    ifa_offset += nbf_zone[izone];
	  }
	}
	for (int izone = 0; izone < 27; ++izone) {
	  if (nfa_zone[izone] > 0) {
	    for (int ifa = 0; ifa < my_nfa_zone[izone]; ++ifa) 
	      fa_flag[ifa] = ifa_offset+my_nfa_disp[izone]+ifa;
	    MPI_File_write_at_all(fh,offset+my_nfa_disp[izone]*sizeof(int),
				  fa_flag,my_nfa_zone[izone],
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += nfa_zone[izone]*sizeof(int);
	    ifa_offset += nfa_zone[izone];
	  }
	}
	
	delete[] fa_flag;
	
      }
      
      //=========================
      // face zone headers:
      // boundary zones first...
      //=========================
      
      int nzone_final = 0;
      int8 ibf_end = 0;
      int8 noobf_end = 0;
      for (int izone = 0; izone < nzone; ++izone) {
	if (nbf_zone[izone] > 0) {
	  assert(noobf_zone[izone] > 0);
	  const int8 ibf_begin = ibf_end; ibf_end += nbf_zone[izone];
	  const int8 noobf_begin = noobf_end; noobf_end += noobf_zone[izone];
	  // this zone needs to be written...
	  if ( mpi_rank == 0 ) { 
	    Header header; 
	    header.id       = UGP_IO_FA_ZONE_HEADER;
	    header.skip     = header_size;
	    header.idata[0] = FA_ZONE_BOUNDARY;
	    if (izone == nzone-1)
	      sprintf(header.name,"_orphans"); //.. protected name 
	    else 
	      sprintf(header.name,"%s",mainPart->surface->zoneVec[izone].getName().c_str());
	    cout << " > FA_ZONE \"" << header.name << "\" nfa: " << nbf_zone[izone] << endl;
	    header.idata[1] = nzone_final;
	    ByteSwap::setLswMswPairForInt8(header.idata+2,nbf_zone[izone]);
	    MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	  }
	  ++nzone_final;
	  offset += header_size;
	}
	else {
	  assert(nbf_zone[izone] == 0);
	  assert(noobf_zone[izone] == 0);
	}
      }
      
      // ============================
      // periodic zones...
      // ============================
      
      for (int izone = 0; izone < 26; ++izone) {
	if (nfa_zone[izone] > 0) {
	  assert(0);
	}
      }

      // ============================
      // default internal...
      // ============================
      
      if (nfa_zone[26] > 0) {
      
	if ( mpi_rank == 0 ) {
	  Header header; 
	  header.id       = UGP_IO_FA_ZONE_HEADER;
	  header.skip     = header_size;
	  header.idata[0] = FA_ZONE_INTERNAL;
	  sprintf(header.name,"default-internal"); //.. protected name 
	  cout << " > FA_ZONE \"" << header.name << "\" nfa: " << nfa_zone[26] << endl;
	  header.idata[1] = nzone_final;
	  ByteSwap::setLswMswPairForInt8(header.idata+2,nfa_zone[26]);
	  MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	}
	++nzone_final;
	offset += header_size;
      
      }
      
      // ============================
      // fa_zone...
      // ============================
      
      if ( mpi_rank == 0 ) { 
	Header header;
	sprintf(header.name,"%s","fa_zone");
	header.id   = UGP_IO_FA_ZONE;
	header.skip = header_size + int_size*(nbf_global+nfa_global);
        header.idata[0] = nbf_global+nfa_global;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      offset += header_size;
      
      {
	
	int my_nfa_zone_max = 0;
	for (int izone = 0; izone < nzone; ++izone) 
	  my_nfa_zone_max = max(my_nfa_zone_max,(int)my_nbf_zone[izone]);
	for (int izone = 0; izone < 27; ++izone) 
	  my_nfa_zone_max = max(my_nfa_zone_max,(int)my_nfa_zone[izone]);

	int * fa_zone = new int[my_nfa_zone_max];
	
	int izone_final = 0;
	for (int izone = 0; izone < nzone; ++izone) {
	  if (nbf_zone[izone] > 0) {
	    for (int ifa = 0; ifa < my_nbf_zone[izone]; ++ifa)
	      fa_zone[ifa] = izone_final;
	    MPI_File_write_at_all(fh,offset+my_nbf_disp[izone]*sizeof(int),
				  fa_zone,my_nbf_zone[izone],
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += nbf_zone[izone]*sizeof(int);
	    ++izone_final;
	  }
	}
	for (int izone = 0; izone < 27; ++izone) {
	  if (nfa_zone[izone] > 0) {
	    for (int ifa = 0; ifa < my_nfa_zone[izone]; ++ifa)
	      fa_zone[ifa] = izone_final;
	    MPI_File_write_at_all(fh,offset+my_nfa_disp[izone]*sizeof(int),
				  fa_zone,my_nfa_zone[izone],
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += nfa_zone[izone]*sizeof(int);
	    ++izone_final;
	  }
	}
	assert(izone_final == nzone_final);
	
	delete[] fa_zone;
	
      }

      //=========================
      // cv zone header:
      // - just 1 fluid zone
      //=========================
      
      if (mpi_rank == 0 ) { // one cv zone named "fluid"...
	Header header;
	sprintf(header.name,"fluid");
	header.id       = UGP_IO_CV_ZONE_HEADER;
	header.skip     = header_size;
	header.idata[0] = CV_ZONE_FLUID;
	header.idata[1] = 0;
	ByteSwap::setLswMswPairForInt8(header.idata+2,cvora[mpi_size]);
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }

      offset += header_size; 
      
      
      if ( mpi_rank == 0 ) { 
	cout << " > cv_zone... " << endl; 
	Header header; 
	sprintf(header.name,"cv_zone"); 
	header.id     = UGP_IO_CV_ZONE; 
	header.skip   = header_size + cvora[mpi_size]*int_size;
	header.idata[0] = cvora[mpi_size];
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      {
	// cv_zone == 0
	int * cv_zone = new int[ncv]; 
	
	for (int icv = 0; icv < ncv; ++icv) 
	  cv_zone[icv] = 0;
	
	MPI_File_write_at_all(fh,offset+header_size+cvora[mpi_rank]*int_size, 
			      cv_zone,ncv,MPI_INT,MPI_STATUS_IGNORE);

	delete[] cv_zone;
      }
      
      offset += header_size + cvora[mpi_size]*int_size;
      
      // ============================
      // noofa_i/v...
      // ============================
      
      if ( mpi_rank == 0 ) { 
	Header header;
        sprintf(header.name,"NOOFA_I_AND_V");
        header.id = UGP_IO_NOOFA_I_AND_V;
        header.skip = header_size + int_size*(nbf_global+nfa_global) + int_size*(noobf_global+noofa_global);
        header.idata[0] = nbf_global+nfa_global;
        // noofa_count gets written as 2 ints...
        ByteSwap::setLswMswPairForInt8(header.idata+1,noobf_global+noofa_global);
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      offset += header_size;
      
      int my_disp_local = 0;
      for (int izone = 0; izone < nzone; ++izone) {
	if (nbf_zone[izone] > 0) {
	  MPI_File_write_at_all(fh,offset+my_nbf_disp[izone]*sizeof(int),
				noobf_count+my_disp_local,my_nbf_zone[izone],
				MPI_INT,MPI_STATUS_IGNORE);
	  offset += nbf_zone[izone]*sizeof(int);
	  my_disp_local += my_nbf_zone[izone];
	}
      }
      my_disp_local = 0;
      for (int izone = 0; izone < 27; ++izone) {
	if (nfa_zone[izone] > 0) {
	  MPI_File_write_at_all(fh,offset+my_nfa_disp[izone]*sizeof(int),
				noofa_count+my_disp_local,my_nfa_zone[izone],
				MPI_INT,MPI_STATUS_IGNORE);
	  offset += nfa_zone[izone]*sizeof(int);
	  my_disp_local += my_nfa_zone[izone];
	}
      }
      
      {
	
	int * noofa_v = new int[max(noobf_s,noofa_s)];
	
	for (int nob = 0; nob < noobf_s; ++nob) {
	  assert(noobf_v_global[nob] == int(noobf_v_global[nob]));
	  noofa_v[nob] = noobf_v_global[nob];
	}
	my_disp_local = 0;
	for (int izone = 0; izone < nzone; ++izone) {
	  if (nbf_zone[izone] > 0) {
	    MPI_File_write_at_all(fh,offset+my_noobf_disp[izone]*sizeof(int),
				  noofa_v+my_disp_local,my_noobf_zone[izone],
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += noobf_zone[izone]*sizeof(int);
	    my_disp_local += my_noobf_zone[izone];
	  }
	}

	for (int nof = 0; nof < noofa_s; ++nof) {
	  assert(noofa_v_global[nof] == int(noofa_v_global[nof]));
	  noofa_v[nof] = noofa_v_global[nof];
	}
	my_disp_local = 0;
	for (int izone = 0; izone < 27; ++izone) {
	  if (nfa_zone[izone] > 0) {
	    MPI_File_write_at_all(fh,offset+my_noofa_disp[izone]*sizeof(int),
				  noofa_v+my_disp_local,my_noofa_zone[izone],
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += noofa_zone[izone]*sizeof(int);
	    my_disp_local += my_noofa_zone[izone];
	  }
	}

	delete[] noofa_v;

      }

      // ============================
      // cvofa...
      // ============================
      
      if ( mpi_rank == 0 ) { 
	Header header;
        sprintf(header.name,"CVOFA");
        header.id = UGP_IO_CVOFA;
        header.skip = header_size + int_size*(nbf_global+nfa_global)*2;
        header.idata[0] = nbf_global+nfa_global;
        header.idata[1] = 2;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      offset += header_size;

      {
	int (*cvofa)[2] = new int[max(nbf,nfa)][2];

	for (int ibf = 0; ibf < nbf; ++ibf) {
	  assert(cvobf_global[ibf] == int(cvobf_global[ibf]));
	  cvofa[ibf][0] = (int)cvobf_global[ibf];
	  cvofa[ibf][1] = -1;
	}
	
	my_disp_local = 0;
	for (int izone = 0; izone < nzone; ++izone) {
	  if (nbf_zone[izone] > 0) {
	    MPI_File_write_at_all(fh,offset+my_nbf_disp[izone]*sizeof(int)*2,
				  cvofa+my_disp_local,my_nbf_zone[izone]*2,
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += nbf_zone[izone]*sizeof(int)*2;
	    my_disp_local += my_nbf_zone[izone];
	  }
	}
	assert(my_disp_local == nbf);
	
	// XXXXX fix this for periodic zones eventually...

	for (int ifa = 0; ifa < nfa; ++ifa) {
	  assert(cvofa_global[ifa][0] == int(cvofa_global[ifa][0]));
	  assert(cvofa_global[ifa][1] == int(cvofa_global[ifa][1]));
	  cvofa[ifa][0] = (int)cvofa_global[ifa][0];
	  cvofa[ifa][1] = (int)cvofa_global[ifa][1];
	}
	
	my_disp_local = 0;
	for (int izone = 0; izone < 27; ++izone) {
	  if (nfa_zone[izone] > 0) {
	    MPI_File_write_at_all(fh,offset+my_nfa_disp[izone]*sizeof(int)*2,
				  cvofa+my_disp_local,my_nfa_zone[izone]*2,
				  MPI_INT,MPI_STATUS_IGNORE);
	    offset += nfa_zone[izone]*sizeof(int)*2;
	    my_disp_local += my_nfa_zone[izone];
	  }
	}
	assert(my_disp_local == nfa);

	delete[] cvofa;
	
      }

      //===================================
      // nodal records 
      //===================================

      // nodal coordinates... 
      // double (*x_no)[3] = new double[nno][3];
    
      if ( mpi_rank == 0 ) { 
	cout << " > x_no... " << endl; 
	Header header;
	sprintf(header.name,"x_no"); 
	header.id     = UGP_IO_X_NO;
	header.skip   = header_size + noora[mpi_size]*double_size*3; 
	header.idata[0] = noora[mpi_size];
	header.idata[1] = 3;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      
      MPI_File_write_at_all(fh,offset+header_size+noora[mpi_rank]*double_size*3,
			    x_no,nno*3,MPI_DOUBLE,MPI_STATUS_IGNORE); 
      
      offset += header_size + noora[mpi_size]*double_size*3;
      
      //==================================
      // cv based records
      //==================================
    
      {
	// vol_vv 
	double * vol_vv = new double[ncv]; 
	for (int icv = 0; icv < ncv; ++icv) 
	  vol_vv[icv] = mainPart->cvdVec[icv].vol;
	
	if ( mpi_rank == 0 ) { 
	  cout << " > vol_vv... " << endl; 
	  Header header; 
	  sprintf(header.name,"vol_vv"); 
	  header.id     = UGP_IO_CV_D1; 
	  header.skip   = header_size + cvora[mpi_size]*double_size;
	  header.idata[0] = cvora[mpi_size];
	  MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	}
	
	MPI_File_write_at_all(fh,offset+header_size+cvora[mpi_rank]*double_size, 
			      vol_vv,ncv,MPI_DOUBLE,MPI_STATUS_IGNORE);
	delete[] vol_vv;
      }
      
      offset += header_size + cvora[mpi_size]*double_size;
      
      // x_vv 
      if ( mpi_rank == 0 ) { 
	cout << " > x_vv ... " << endl;
	Header header; 
	sprintf(header.name,"x_vv"); 
	header.id       = UGP_IO_CV_D2; 
	header.skip     = header_size + cvora[mpi_size]*double_size*3;
	header.idata[0] = cvora[mpi_size]; 
	header.idata[1] = 3;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      } 
      
      MPI_File_write_at_all(fh,offset+header_size+cvora[mpi_rank]*double_size*3,
			    mainPart->points->xp,ncv*3,MPI_DOUBLE,MPI_STATUS_IGNORE); 
      
      offset += header_size + cvora[mpi_size]*double_size*3;
      
      // ============================
      // EOF...
      // ============================
      
      if ( mpi_rank == 0 ) { 
	cout << " > EOF ... " << endl;
	Header header;
	header.id = UGP_IO_EOF; 
	sprintf(header.name,"EOF"); 
	header.skip = header_size; 
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
    
      offset += header_size; 
    
      MPI_File_set_size(fh,offset); 
      MPI_File_close(&fh); 



    }
    else {

      // no earlier io versions implemented -- sorry...
    
      assert(0);

    }
    
    // cleanup...

  







#endif


















    delete[] ino_global; 
    delete[] cvofa_global; 
    delete[] noofa_count;
    delete[] noofa_v_global; 
    delete[] noobf_count;
    delete[] noobf_v_global;
    delete[] x_no;
    delete[] cvobf_global;
    delete[] cvora; 
    delete[] noora;

    delete[] my_nbf_zone;
    delete[] my_noobf_zone;
    delete[] my_nbf_disp;
    delete[] my_noobf_disp;
    delete[] nbf_zone;
    delete[] noobf_zone;


      { 
      
	vector<int> bitsVec;
	if (mainPart->surface->periodicData[0].getType() == PERIODIC_NULL) {
	
	  // no periodicity...
	  FOR_I6 assert(mainPart->surface->periodicData[i].getType() == PERIODIC_NULL);
      
	}
	else if (mainPart->surface->periodicData[4].getType() != PERIODIC_NULL) {

	  // triple periodic...
	  FOR_I6 assert(mainPart->surface->periodicData[i].getType() != PERIODIC_NULL);
	
	  bitsVec.push_back((1<<0));
	  bitsVec.push_back((1<<1));
	  bitsVec.push_back((1<<2));
	  bitsVec.push_back((1<<3));
	  bitsVec.push_back((1<<4));
	  bitsVec.push_back((1<<5));

	  bitsVec.push_back((1<<0)|(1<<2));
	  bitsVec.push_back((1<<0)|(1<<3));
	  bitsVec.push_back((1<<0)|(1<<4));	
	  bitsVec.push_back((1<<0)|(1<<5));
	  bitsVec.push_back((1<<1)|(1<<2));
	  bitsVec.push_back((1<<1)|(1<<3));
	  bitsVec.push_back((1<<1)|(1<<4));
	  bitsVec.push_back((1<<1)|(1<<5));
	  bitsVec.push_back((1<<2)|(1<<4));
	  bitsVec.push_back((1<<2)|(1<<5));
	  bitsVec.push_back((1<<3)|(1<<4));
	  bitsVec.push_back((1<<3)|(1<<5));

	  bitsVec.push_back((1<<0)|(1<<2)|(1<<4));
	  bitsVec.push_back((1<<0)|(1<<2)|(1<<5));
	  bitsVec.push_back((1<<0)|(1<<3)|(1<<4));
	  bitsVec.push_back((1<<0)|(1<<3)|(1<<5));
	  bitsVec.push_back((1<<1)|(1<<2)|(1<<4));
	  bitsVec.push_back((1<<1)|(1<<2)|(1<<5));
	  bitsVec.push_back((1<<1)|(1<<3)|(1<<4));
	  bitsVec.push_back((1<<1)|(1<<3)|(1<<5));
	
	  // that's 26 entries!!
	} 
	else if (mainPart->surface->periodicData[2].getType() != PERIODIC_NULL) {

	  // double periodicity...
	  assert(mainPart->surface->periodicData[4].getType() == PERIODIC_NULL);
	  assert(mainPart->surface->periodicData[5].getType() == PERIODIC_NULL);
	  FOR_I4 assert(mainPart->surface->periodicData[i].getType() != PERIODIC_NULL);
	
	  bitsVec.push_back((1<<0));
	  bitsVec.push_back((1<<1));
	  bitsVec.push_back((1<<2));
	  bitsVec.push_back((1<<3));

	  bitsVec.push_back((1<<2)|(1<<0));
	  bitsVec.push_back((1<<3)|(1<<0));
	  bitsVec.push_back((1<<2)|(1<<1));
	  bitsVec.push_back((1<<3)|(1<<1));
      
	}
	else {
	
	  // single periodicity...
	  assert(mainPart->surface->periodicData[4].getType() == PERIODIC_NULL);
	  assert(mainPart->surface->periodicData[5].getType() == PERIODIC_NULL);
	  assert(mainPart->surface->periodicData[3].getType() == PERIODIC_NULL);
	  assert(mainPart->surface->periodicData[2].getType() == PERIODIC_NULL);
	  FOR_I2 assert(mainPart->surface->periodicData[i].getType() != PERIODIC_NULL);
	
	  bitsVec.push_back((1<<0));
	  bitsVec.push_back((1<<1));
	
	}

	// ----------------------------------------------------
	// now write a header for each possible transform with 
	// the transform data stored as R[9] and t[3]...
	// ----------------------------------------------------
    
	for (int ii = 0; ii < bitsVec.size(); ++ii) {
	  const int bits = bitsVec[ii];
	  // cycle through bits pairs...
	  // SB: "lucky the identity matrix is symmetric" -- inside joke re column-major format 
	  // of R -- hee hee
	  double R[9] = { 1.0, 0.0, 0.0 , 
			  0.0, 1.0, 0.0 , 
			  0.0, 0.0, 1.0 };
	  double t[3] = { 0.0, 0.0, 0.0 };
	  bool has_R = false;
	  bool has_t = false;
	  FOR_I3 {
	    if (bits & (1<<(2*i))) {
	      // even bit pair set...
	      assert(!(bits & (1<<(2*i+1)))); // only one pair set
	      assert(mainPart->surface->periodicData[2*i].getType() != PERIODIC_NULL);
	      double this_R[9];
	      double this_t[3];
	      if (mainPart->surface->periodicData[2*i].getR(this_R)) {
		has_R = true;
		double Rtmp[9] = { 0.0, 0.0, 0.0,
				   0.0, 0.0, 0.0,
				   0.0, 0.0, 0.0 };
		FOR_M3 {
		  FOR_J3 {
		    FOR_K3 {
		      Rtmp[3*m+j] += R[3*m+k]*this_R[3*k+j];
		    }
		  }
		}
	      
		for (int ii =0; ii < 9; ++ii) 
		  R[ii] = Rtmp[ii];
	      }
	    
	      if (mainPart->surface->periodicData[2*i].getT(this_t)) { 
		has_t = true;
		FOR_J3 t[j] += this_t[j];
	      }

	    }
	    else if (bits & (1<<(2*i+1))) {
	      // odd bit pair set...
	      assert(mainPart->surface->periodicData[2*i+1].getType() != PERIODIC_NULL);
	      double this_R[9];
	      double this_t[3];
	      if (mainPart->surface->periodicData[2*i+1].getR(this_R)) {
		has_R = true;
		double Rtmp[9] = { 0.0, 0.0, 0.0,
				   0.0, 0.0, 0.0,
				   0.0, 0.0, 0.0 };
		FOR_M3 {
		  FOR_J3 {
		    FOR_K3 {
		      Rtmp[3*m+j] += R[3*m+k]*this_R[3*k+j];
		    }
		  }
		}
		
		for (int ii =0; ii < 9; ++ii) 
		  R[ii] = Rtmp[ii];
	      }
	    
	      if (mainPart->surface->periodicData[2*i+1].getT(this_t)) { 
		has_t = true;
		FOR_J3 t[j] += this_t[j];
	      }
	    }
	    
	  }
	  
	  if (mpi_rank == 0) { // root writes the transform record  
	    Header header;
	    header.id     = UGP_IO_BIT_TRANSFORM_DATA;
	    header.skip   = header_size;
	    sprintf(header.name,"bit-%d",bits);
	    if (has_R) { 
	      header.idata[0] = 1;
	      for (int i = 0; i < 9; ++i) 
		header.rdata[i] = R[i];
	    }
	    else {
	      header.idata[0] = -1; // R is NULL
	    } 

	    if (has_t) { 
	      header.idata[1] =  1;
	      for (int i = 0; i < 3 ; ++i) 
		header.rdata[i+9] = t[i];
	    }
	    else {
	      header.idata[1] = -1; // t is NULL 
	    }

	    header.idata[2] = bits;
	    MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	  }
	  offset += header_size;
      
	}
      
      }  

















#ifdef JFKSFDKLJSFDKJSFDK
  


  
  for (int ii = 0, limit = nodeVec.size(); ii < limit; ++ii) {
    // the first of the pair is "ino_local"
    nodeVec[ii].second.first = -no_flag[nodeVec[ii].second.first]-1;
    
  
  limit = node



  for (int nob = 0, limit = noobf_v_vec.size(); nob < limit; ++nob) {
    if (noobf_v_vec[nob].ino >= 0) {
      noobf_v_vec[nob].ino = -no_flag[noobf_v_vec[nob].ino]-1;
      FOR_I3 x_no[noobf_v_vec[nob].ino][i] += noobf_v_vec[nob].x_no[i];
      x_count[noobf_v_vec[nob].ino] += 1;
    }
    else {
      noobf_v_vec[nob].ino = no_flag[-noobf_v_vec[nob].ino-1]; // keep this guy negative
      FOR_I3 x_no[-noobf_v_vec[nob].ino-1][i] += noobf_v_vec[nob].x_no[i];
      x_count[-noobf_v_vec[nob].ino-1] += 1;
    }
  }

  for (int nof = 0, limit = noofa_v_vec.size(); nof < limit; ++nof) {
    noofa_v_vec[nof].ino = -no_flag[noofa_v_vec[nof].ino]-1;
    FOR_I3 x_no[noofa_v_vec[nof].ino][i] += noofa_v_vec[nof].x_no[i];
    x_count[noofa_v_vec[nof].ino] += 1;
  }
  
  // normalize...
  
  for (int ino = 0; ino < nno_local_reduced; ++ino) {
    assert(x_count[ino] > 0);
    FOR_I3 x_no[ino][i] /= double(x_count[ino]);
  }
  
  {
    FILE * fp = fopen("pts.dat","w");
    for (int ino = 0; ino < nno_local_reduced; ++ino) {
      fprintf(fp,"%18.15le %18.15le %18.15le\n",
	      x_no[ino][0],
	      x_no[ino][1],
	      x_no[ino][2]);
      
    }
    fclose(fp);
  }
  
  
  {
    // HACK write the faces using noobf_v_vec...
    // recall face loops use a -ve sign convention...
    int ino_local_max = -1;
    // first count how many bf loops -- this is not the same as the 
    // number of faces, which we need to figure out later...
    int nbf_loop = 0;
    for (int nob = 0, limit = noobf_v_vec.size(); nob < limit; ++nob) {
      if (noobf_v_vec[nob].ino < 0)
	++nbf_loop;
      ino_local_max = max(ino_local_max,max(noobf_v_vec[nob].ino,-noobf_v_vec[nob].ino-1));
    }
    cout << "nbf_loop: " << nbf_loop << " ino_local_max: " << ino_local_max << " nno_local_b_reduced: " << nno_local_b_reduced << endl;
    
    FILE * fp = fopen("bf.dat","w");
    fprintf(fp,"TITLE = \"%s\"\n","bf.dat");
    fprintf(fp,"VARIABLES = \"X\"\n");
    fprintf(fp,"\"Y\"\n");
    fprintf(fp,"\"Z\"\n");

    fprintf(fp,"ZONE T=\"%s\"\n","wall");
    fprintf(fp,"N=%d, E=%d, F=FEPOINT, ET=TRIANGLE\n",nno_local_b_reduced+nbf_loop,noobf_v_vec.size());
    
    // node coords first...
    for (int ino = 0; ino < nno_local_b_reduced; ++ino) {
      fprintf(fp,"%18.15le %18.15le %18.15le\n",x_no[ino][0],x_no[ino][1],x_no[ino][2]);
    }

    // then nbf_loop centers...
    double xc[3];
    double wgt;
    bool first = true;
    int ino_local0;
    for (int nob = 0, limit = noobf_v_vec.size(); nob < limit; ++nob) {
      if (first) {
	FOR_I3 xc[i] = 0.0;
	wgt = 0.0;
	first = false;
	assert(noobf_v_vec[nob].ino >= 0);
	ino_local0 = noobf_v_vec[nob].ino;
      }
      else if (noobf_v_vec[nob].ino >= 0) {
	double this_wgt = DIST(x_no[noobf_v_vec[nob].ino],x_no[noobf_v_vec[nob-1].ino]);
	FOR_I3 xc[i] += this_wgt*(x_no[noobf_v_vec[nob].ino][i]+x_no[noobf_v_vec[nob-1].ino][i]);
	wgt += this_wgt;
      }
      else {
	int ino_local = -noobf_v_vec[nob].ino-1;
	double this_wgt = DIST(x_no[ino_local],x_no[noobf_v_vec[nob-1].ino]);
	FOR_I3 xc[i] += this_wgt*(x_no[ino_local][i]+x_no[noobf_v_vec[nob-1].ino][i]);
	wgt += this_wgt;
	// and the one with the first point...
	this_wgt = DIST(x_no[ino_local0],x_no[ino_local]);
	FOR_I3 xc[i] += this_wgt*(x_no[ino_local0][i]+x_no[ino_local][i]);
	wgt += this_wgt;
	// we are done this loop, so write the point...
	FOR_I3 xc[i] /= 2.0*wgt;
	fprintf(fp,"%18.15le %18.15le %18.15le\n",xc[0],xc[1],xc[2]);
	// and get ready for the next time...
	first = true;
      }
    }

    // write the triangle connectivity...
   
    first = true;
    int ibf_loop = 0;
    for (int nob = 0, limit = noobf_v_vec.size(); nob < limit; ++nob) {
      if (first) {
	first = false;
	assert(noobf_v_vec[nob].ino >= 0);
	ino_local0 = noobf_v_vec[nob].ino;
      }
      else if (noobf_v_vec[nob].ino >= 0) {
	fprintf(fp,"%d %d %d\n",ibf_loop+nno_local_b_reduced+1,noobf_v_vec[nob-1].ino+1,noobf_v_vec[nob].ino+1);
      }
      else {
	int ino_local = -noobf_v_vec[nob].ino-1;
	fprintf(fp,"%d %d %d\n",ibf_loop+nno_local_b_reduced+1,noobf_v_vec[nob-1].ino+1,ino_local+1);
	// and the one with the first point...
	fprintf(fp,"%d %d %d\n",ibf_loop+nno_local_b_reduced+1,ino_local+1,ino_local0+1);
	// we are done this loop, so write the point...
	first = true;
	++ibf_loop;
      }
    }
    
    assert(ibf_loop == nbf_loop);
    
    fclose(fp);
    
  }

#endif
    


  /*
    {
    int8 my_count[1] = { zone_of_bf_vec.size() };
    int8 count[1];
    MPI_Reduce(my_count,count,1,MPI_INT8,MPI_SUM,0,mpi_comm);
    if (mpi_rank == 0) {
    cout << " counts: nbf_global: " << count[0] << endl;
    }
    }
  */
  







  
	  
	
	  
	nob0; ++nob) {
	if (noobf_v_vec[nob] >= 0) {
	  nodeVec.push_back(pair<double*,pair<int,int> >(noobf_double_ptr_vec[nob],pair<int,int>(nno_local,ip)));
	  noobf_v_vec.push_back(nno_local++);
	}



  HEREHERE

  for (int ibf_local = 0; ibf_local < nbf_local; ++ibf_local) {
    cout << "working on ibf_local: " << ibf_local << endl;
    int nob1 = noobf_i_vec[ibf_local];
    while (nob1 < noobf_i_vec[ibf_local+1]) {
      // advance until the first negative -- it can the the first point...
      int nob0 = nob1;
      while (noobf_v_vec[nob1] >= 0) ++nob1;
      for (int nob = nob0; nob <= nob1; ++nob) {
        const int ino_local = noobf_v_vec[nob];
        if (mpi_rank == 0) cout << "nob: " << nob << " ino_local: " << ino_local 
				<< " ino_global[max(ino_local,-ino_local-1)]: " << ino_global[max(ino_local,-ino_local-1)] << endl;
        
      }
      if (mpi_rank == 0) cout << "done inner loop" << endl;
      ++nob1; // first element of next loop/face
    }
    assert(nob1 == noobf_i_vec[ibf_local+1]);
    MPI_Pause("ok");
  }
  //noobf_i.resize(nbf+1);

  /*
    for (int ip = 0; ip < points->np; ++ip) {
    for (int ibf = bfocv_i[ip]; ibf != bfocv_i[ip+1]; ++ibf) {
      size_t noobf_v_vec_size0 = noobf_v_vec.size();
      noobf_v_vec.resize(noobf_v_vec_size0+
			 noobf_i_vec[ibf+1]-noobf_i_vec[ibf]);
      // includes NULL for loop separation
      int ii = 0;
      for (int nob = noobf_i_vec[ibf]; nob != noobf_i_vec[ibf+1]; ++nob) {
	if (noobf_double_ptr_vec[nob]) {
	const int ino_local = nno_local_b++;
	  nodeVec.push_back(pair<double*,pair<int,int> >(noobf_double_ptr_vec[nob],pair<int,int>(ino_local,ip)));


  
  
  
  int nob1 = 0;
  while (nob1 < noobf_v_vec.size()) {
    const int nob0 = nob1++;
    while ((nob1 < noobf_v_vec.size())&&(noobf_v_vec[nob1] >= 0)) ++nob1;
    cout << "got loop from nob0: " << nob0 << " to nob1: " << nob1 << endl;
    for (int nob = nob0; nob <= nob1; ++nob) {
      int ino_local = noobf_v_vec[nob];
      if (nob == nob1) ino_local = -ino_local-1;
      cout << "nob: " << nob << " ino_local: " << ino_local << " ino_global[ino_local]: " << ino_global[ino_local] << endl;
    }
    ++nob1;
    MPI_Pause("OKKOK");
  }

  MPI_Pause("OKKOK2");
  





              /*
              if ( no_flag[ino0] != no_flag[ino1] ) { 
                cout << "found unaccounted for close points rank: " << mpi_rank << " ip: " << nodeVec[ii].second.second << endl;
                cout << "< double* 0: " << nodeVec[ii].first << " double* 1: " << nodeVec[jj].first << endl;
                cout << "< ino_local 0: " << nodeVec[ii].second.first << " ino_local 1: " << nodeVec[jj].second.first << endl;
                cout << "< no_flag[ino_local 0]: " << no_flag[nodeVec[ii].second.first] << " no_flag[ino_local 1]: " << no_flag[nodeVec[jj].second.first] << endl;
                cout << "< x[ip]: " << COUT_VEC(points->xp[nodeVec[ii].second.second]) << " ";
                cout << "dx[ino_local 0]: " << COUT_VEC(nodeVec[ii].first) << " "; 
                cout << "dx[ino_local 0]: " << COUT_VEC(nodeVec[jj].first) << " " << endl;
              } 
              */





    
    if (!(loopVec.size()-loopVec_size0 >= 3)) {
      
      cout << "loopVec.size(): " << loopVec.size() << " loopVec.size()-loopVec_size0: " << loopVec.size()-loopVec_size0 << " mpi_rank: " << mpi_rank << " counter: " << counter << endl;
      
      if ((mpi_rank == debug_rank)&&(counter == debug_count)) {

	FILE * fp = fopen("x0Vec.dat","w");
	for (int i0 = i0_f; i0 <= i0_l; ++i0) {
	  if (x0Vec[i0]) {
	    fprintf(fp,"%18.15le %18.15le %18.15le\n",
		    x0Vec[i0][0],
		    x0Vec[i0][1],
		    x0Vec[i0][2]);
	  }
	  
	}
	fclose(fp);
	
	fp = fopen("x1Vec.dat","w");
	for (int i1 = i1_f; i1 <= i1_l; ++i1) {
	  if (x1Vec[i1]) {
	    fprintf(fp,"%18.15le %18.15le %18.15le\n",
		    x0Vec[i1][0],
		    x0Vec[i1][1],
		    x0Vec[i1][2]);
	  }
	}
	fclose(fp);
	
      }

      
    }






	    if (!(bfMultiMap.find(pair<int,double*>(bf_color[iter0->second],x0)) == bfMultiMap.end())) {
	      cout << "debug_counter: " << debug_counter << " ip " << ip << endl;
	      cout << "x0: " << 
		x0[0]+points->xp[ip][0] << " " << 
		x0[1]+points->xp[ip][1] << " " << 
		x0[2]+points->xp[ip][2] << endl;
	      cout << "x1: " << 
		x1[0]+points->xp[ip][0] << " " << 
		x1[1]+points->xp[ip][1] << " " << 
		x1[2]+points->xp[ip][2] << endl;

	      
              multimap<const pair<int,double*>,double*>::iterator iter = bfMultiMap.find(pair<int,double*>(bf_color[iter0->second],x0));
              assert(iter != bfMultiMap.end());
	      cout << "hit x0: " << 
		iter->first.second[0]+points->xp[ip][0] << " " << 
		iter->first.second[1]+points->xp[ip][1] << " " << 
		iter->first.second[2]+points->xp[ip][2] << endl;
	      cout << "hit x1: " << 
		iter->second[0]+points->xp[ip][0] << " " << 
		iter->second[1]+points->xp[ip][1] << " " << 
		iter->second[2]+points->xp[ip][2] << endl;
	    }

	    {
	      double * x0 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
	      double * x1 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
	      map<const int,int>::iterator iter = colorMap.find(ifa); assert(iter != colorMap.end());
	      //cout << "XXXXXXX EDGE ied: " << ied << " i: " << i << " x0: " << 
	    	x0[0]+points->xp[ip][0] << " " << 
		x0[1]+points->xp[ip][1] << " " << 
		x0[2]+points->xp[ip][2] << 
		" to x1: " << 
		x1[0]+points->xp[ip][0] << " " << 
		x1[1]+points->xp[ip][1] << " " << 
		x1[2]+points->xp[ip][2] << " color: " << bf_color[iter->second] << endl;
	    }

	  multimap<const pair<int,double*>,double*>::iterator iter = bfMultiMap.find(pair<int,double*>(bf_color[iter0->second],x0));
	  if (iter != bfMultiMap.end()) {
              cout << "color x0 x1: " << iter->first.first << " " << iter->first.second << " " << iter->second << endl;
              cout << "color x0 x1: " << bf_color[iter0->second] << " " << x0 << " " << x1 << endl;
              //assert(0);
            }
            /*
            if (bfMultiMap.find(pair<int,double*>(bf_color[iter0->second],x0)) != bfMultiMap.end()) {
              for (map<const pair<int,double*>,double*>::iterator iter = bfMultiMap.begin(); iter != bfMultiMap.end(); ++iter) {
                cout << "color x0 x1: " << iter->first.first << " " << iter->first.second << " " << iter->second << endl;
              }
              cout << "color x0 x1: " << bf_color[iter0->second] << " " << x0 << " " << x1 << endl;
              //assert(0);
            }
            */

           //bfMultiMap[pair<int,double*>(bf_color[iter0->second],x0)] = x1;


// orphan:

              multimap<const pair<int,double*>,double*>::iterator iter = bfMultiMap.find(pair<int,double*>(bf_color[iter0->second],x0));
              if (iter != bfMultiMap.end()) {
                cout << "color x0 x1: " << iter->first.first << " " << iter->first.second << " " << iter->second << endl;
                cout << "color x0 x1: " << bf_color[iter0->second] << " " << x0 << " " << x1 << endl;
                //assert(0);
              }
              /*
              if (bfMultiMap.find(pair<int,double*>(bf_color[iter0->second],x0)) != bfMultiMap.end()) {
                for (map<const pair<int,double*>,double*>::iterator iter = bfMultiMap.begin(); iter != bfMultiMap.end(); ++iter) {
                  cout << "color x0 x1: " << iter->first.first << " " << iter->first.second << " " << iter->second << endl;
                }
                cout << "color x0 x1: " << bf_color[iter0->second] << " " << x0 << " " << x1 << endl;
                //assert(0);
              }
              */
              //bfMultiMap[pair<int,double*>(bf_color[iter0->second],x0)] = x1;




	
	if (!(x0Set.size()%2 == 0)) {
	  cout << "ERROR: --DEBUG_RANK " << mpi_rank << " --DEBUG_COUNT " << debug_counter << " x0Set.size(): " << x0Set.size() << endl;
	
	  if (debug) {
	    FILE * fp = fopen("debug.dat","w");
	    for (int ii = 0; ii < debugVec.size(); ++ii) {
	      fprintf(fp,"%18.15le %18.15le %18.15le\n",
		      debugVec[ii][0]+points->xp[ip][0],
		      debugVec[ii][1]+points->xp[ip][1],
		      debugVec[ii][2]+points->xp[ip][2]);
	    }
	    fclose(fp);
	    
	    for (int ii = 0; ii < debugVec.size(); ii += 2) {
	      cout << debugVec[ii] << " " << debugVec[ii+1] << endl;
	    }

	  }
	  
	}
	





  if (fail) {
    
    FILE * fp = fopen("loop0.dat","w");
    int i0 = i0_closest;
    do {
      fprintf(fp,"%18.15le %18.15le %18.15le\n",x0Vec[i0][0],x0Vec[i0][1],x0Vec[i0][2]);
      ++i0; 
      if (x0Vec[i0] == NULL) i0 = i0_loop_closest_f;
    } while (i0 != i0_closest);
    fclose(fp);
    
    fp = fopen("loop1.dat","w");
    int i1 = i1_closest;
    do {
      fprintf(fp,"%18.15le %18.15le %18.15le\n",x1Vec[i1][0],x1Vec[i1][1],x1Vec[i1][2]);
      if (i1 == i1_f) i1 = i1_l; // note using the fact that i1_l has a NULL in x1Vec
      else --i1;
      if (x1Vec[i1] == NULL) i1 = i1_loop_closest_l;
    } while (i1 != i1_closest);
    fclose(fp);
    
    assert(0);
  
  }


    char filename[128];
    sprintf(filename,"cv.%06d.dat",ip);
    FILE * fp = fopen(filename,"w");
    














	/*
      cout << "ifa_dup: " << ifa_dup << " rbi_nbr: " << rbi_nbr << endl; 
      
      // this is our node loop:
      
      bool done = false;
      
      for (int nof = noofa_i_vec[ifa_dup]; nof != noofa_i_vec[ifa_dup+1]; ++nof) {
	
	if (noofa_v_vec[nof]) {
	  done = false;
	  fprintf(fp,"%18.15le %18.15le %18.15le\n",noofa_v_vec[nof][0]+points->xp[ip][0],noofa_v_vec[nof][1]+points->xp[ip][1],noofa_v_vec[nof][2]+points->xp[ip][2]);
	  cout << " > node: " << noofa_v_vec[nof] << " " << COUT_VEC(noofa_v_vec[nof]) << endl;
	}
	else {
	  cout << " > done" << endl;
	  done = true;
	}
	
      }
      
      assert(done);
	*/
	
    }

    fclose(fp);
    


    //map<const pair<uint8,uint8>,double> coeffMap;






	    map<const pair<uint8,uint8>,double>::iterator iter = coeffMap.find(pair<uint8,uint8>(rbi,rbi_nbr));
	    if (iter == coeffMap.end()) {
	      coeffMap[pair<uint8,uint8>(rbi,rbi_nbr)] = coeff[0];
	    }
	    else {
	      //FOR_I3 iter->second.coeff[i] += coeff[i];
	      iter->second += coeff[0];
	    }
	    

	    iter = coeffMap.find(pair<uint8,uint8>(rbi_fa_nbr,rbi_nbr));
	    if (iter == coeffMap.end()) {
	      coeffMap[pair<uint8,uint8>(rbi_fa_nbr,rbi_nbr)] = coeff[0];
	    }
	    else {
	      //FOR_I3 iter->second.coeff[i] += coeff[i];
	      iter->second += coeff[0];
	    }
	    

    int8 my_count[2] = { coeffMap.size(), coeffMap.size() };


    MPI_Pause("FSDKLFDSL:FDS");
    
    

    
    writeVoronoiTecplot("all.dat");
    
    
    
    

    
    
    const double x_debug[3] = { 0.0, 0.0, 0.52 };
    int icv_debug = -1;
    double d2_debug;
    for (int icv = 0; icv < ncv; ++icv) {
      const double d2 = DIST2(x_cv[icv],x_debug);
      if ((icv_debug == -1)||(d2 < d2_debug)) {
	icv_debug = icv;
	d2_debug = d2;
      }
    }
    assert(icv_debug != -1);
    
    cout << ">> got icv_debug: " << icv_debug << " at x_cv: " << COUT_VEC(x_cv[icv_debug]) << " dist: " << sqrt(d2_debug) << endl;

    int icv = icv_debug;
    int ifa = faocv_v[faocv_i[icv]];
    int icv0 = cvofa[ifa][0];
    int icv1 = cvofa[ifa][1];
    
    // figure out the maximum size of the rhs...
    
    double A[5][5],C[2][5];
    double LU[7][7];
    double (*rhs)[7] = new double[coc_max][7];
    
    cout << "working with ifa: " << ifa << " with icv0/1: " << icv0 << " " << icv1 << endl;
    
    writePointTecplot("icv0.dat",x_cv[icv0]);
    writePointTecplot("icv1.dat",x_cv[icv1]);

    // test to see what quadrature is sufficiently accurate...
    
    writePointTecplot("ifa.dat",fa[ifa].x);
    cout << "n: " << COUT_VEC(fa[ifa].unit_n) << endl;

    // we want to produce a normalization that leads to O(1) values for
    // the coordinate points used in integrations/quadrature, so divide the unit normal
    // but a characteristic length scale. Here we use the points->delta, 
    
    double e0[3],e1[3],e2[3];
    setFaceVectors(e0,e1,e2,ifa,icv);
    
      // the polynomial is centered about the face, and in local face-normal 
      // cordinates with form
      //
      // P(x,y,z) = c5 + c4*x + c3*x*x + c2*y + c1*z
      //
      // the coefficients are reversed to minimize the work required to compute
      // the desired value of c5 during back-substitution in the LU decomposition.
      
    // we are going to set up the (KKT?) matrix problem:
    //
    // [ A C^T ] [c1,c2,c3,c4,c5,cP,cQ]^T  =  [g] [PP,PQ,Pnbr,...]
    // [ C  0  ]                              [h]
    //
    
    for (int i = 0; i < 5; ++i)
      for (int j = 0; j < 5; ++j)
	A[i][j] = 0.0;
    
    double coeff[14];
    
    // now loop through the icv_nbrs of icv...
    
    for (int coc = 0, ncoc = cvocv_i[icv+1]-cvocv_i[icv]; coc < ncoc; ++coc) {
      const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
      assert((icv_nbr >= 0)&&(icv_nbr < ncv)); // serial for now

      // HACK
      //if ((coc!=0)&&(coc!=1)&&(coc!= 6))
      //continue;

      cout << "XXXX icv: " << icv << " icv_nbr: " << icv_nbr << endl;
      
      // HACK
      //if ((icv_nbr != icv0)&&(icv_nbr != icv1)) 
      //	continue;

      const double dx[3] = DIFF(voronoiPart->points->xp[icv_nbr],fa[ifa].x);
      voronoiPart->calcQuadratureTerms(coeff,icv_nbr,dx,e0,e1,e2);
      
      // top left matrix is A[][]...

      // old ordering...
      /*
      A[0][0] += 2.0*coeff[SW];
      A[0][1] += 2.0*coeff[SWX];
      A[0][2] += 2.0*coeff[SWXX];
      A[0][3] += 2.0*coeff[SWY];
      A[0][4] += 2.0*coeff[SWZ];
      
      A[1][0] += 2.0*coeff[SWX];
      A[1][1] += 2.0*coeff[SWXX];
      A[1][2] += 2.0*coeff[SWXXX];
      A[1][3] += 2.0*coeff[SWXY];
      A[1][4] += 2.0*coeff[SWXZ];
      
      A[2][0] += 2.0*coeff[SWXX];
      A[2][1] += 2.0*coeff[SWXXX];
      A[2][2] += 2.0*coeff[SWXXXX];
      A[2][3] += 2.0*coeff[SWXXY];
      A[2][4] += 2.0*coeff[SWXXZ];
      
      A[3][0] += 2.0*coeff[SWY];
      A[3][1] += 2.0*coeff[SWXY];
      A[3][2] += 2.0*coeff[SWXXY];
      A[3][3] += 2.0*coeff[SWYY];
      A[3][4] += 2.0*coeff[SWYZ];
      
      A[4][0] += 2.0*coeff[SWZ];
      A[4][1] += 2.0*coeff[SWXZ];
      A[4][2] += 2.0*coeff[SWXXZ];
      A[4][3] += 2.0*coeff[SWYZ];
      A[4][4] += 2.0*coeff[SWZZ];
      */

      A[0][0] += 2.0*coeff[SWZZ];
      A[0][1] += 2.0*coeff[SWYZ];
      A[0][2] += 2.0*coeff[SWXXZ];
      A[0][3] += 2.0*coeff[SWXZ];
      A[0][4] += 2.0*coeff[SWZ];
      
      A[1][0] += 2.0*coeff[SWYZ];
      A[1][1] += 2.0*coeff[SWYY];
      A[1][2] += 2.0*coeff[SWXXY];
      A[1][3] += 2.0*coeff[SWXY];
      A[1][4] += 2.0*coeff[SWY];
      
      A[2][0] += 2.0*coeff[SWXXZ];
      A[2][1] += 2.0*coeff[SWXXY];
      A[2][2] += 2.0*coeff[SWXXXX];
      A[2][3] += 2.0*coeff[SWXXX];
      A[2][4] += 2.0*coeff[SWXX];
      
      A[3][0] += 2.0*coeff[SWXZ];
      A[3][1] += 2.0*coeff[SWXY];
      A[3][2] += 2.0*coeff[SWXXX];
      A[3][3] += 2.0*coeff[SWXX];
      A[3][4] += 2.0*coeff[SWX];
      
      A[4][0] += 2.0*coeff[SWZ];
      A[4][1] += 2.0*coeff[SWY];
      A[4][2] += 2.0*coeff[SWXX];
      A[4][3] += 2.0*coeff[SWX];
      A[4][4] += 2.0*coeff[SW];

      // rhs...

      // old ordering...
      /*
      rhs[coc][0] = 2.0*coeff[SW];
      rhs[coc][1] = 2.0*coeff[SWX];
      rhs[coc][2] = 2.0*coeff[SWXX];
      rhs[coc][3] = 2.0*coeff[SWY];
      rhs[coc][4] = 2.0*coeff[SWZ];
      */

      rhs[coc][0] = 2.0*coeff[SWZ];
      rhs[coc][1] = 2.0*coeff[SWY];
      rhs[coc][2] = 2.0*coeff[SWXX];
      rhs[coc][3] = 2.0*coeff[SWX];
      rhs[coc][4] = 2.0*coeff[SW];

      if (icv_nbr == cvofa[ifa][0]) {
	
	cout << "got icv0!" << endl;
	
	// this is the first constraint...
	
	C[0][0] = coeff[SWZ];
	C[0][1] = coeff[SWY];
	C[0][2] = coeff[SWXX];
	C[0][3] = coeff[SWX];
	C[0][4] = coeff[SW];
	
	rhs[coc][5] = coeff[SW];
	rhs[coc][6] = 0.0;
	
      }
      else if (icv_nbr == cvofa[ifa][1]) {
	
	cout << "got icv1!" << endl;
	
	C[1][0] = coeff[SWZ];
	C[1][1] = coeff[SWY];
	C[1][2] = coeff[SWXX];
	C[1][3] = coeff[SWX];
	C[1][4] = coeff[SW];
	
	rhs[coc][5] = 0.0;
	rhs[coc][6] = coeff[SW];
	
      }
      else {

	rhs[coc][5] = 0.0;
	rhs[coc][6] = 0.0;

      }
      
    }
    
    // now solve the equality-constrained minimization problem...
    
    // build LU using doolittle's method?...

    LU[0][0] = A[0][0];
    LU[0][1] = A[0][1];
    LU[0][2] = A[0][2];
    LU[0][3] = A[0][3];
    LU[0][4] = A[0][4];
    LU[0][5] = C[0][0];
    LU[0][6] = C[1][0];
    
    assert(LU[0][0] != 0.0);
    LU[1][0] = A[1][0]/LU[0][0];
    LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
    LU[1][2] = A[1][2] - LU[0][2]*LU[1][0];
    LU[1][3] = A[1][3] - LU[0][3]*LU[1][0];
    LU[1][4] = A[1][4] - LU[0][4]*LU[1][0];
    LU[1][5] = C[0][1] - LU[0][5]*LU[1][0];
    LU[1][6] = C[1][1] - LU[0][6]*LU[1][0];
    
    LU[2][0] = A[2][0]/LU[0][0];
    assert(LU[1][1] != 0.0);
    LU[2][1] = (A[2][1] - LU[0][1]*LU[2][0])/LU[1][1];
    LU[2][2] = A[2][2] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
    LU[2][3] = A[2][3] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
    LU[2][4] = A[2][4] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
    LU[2][5] = C[0][2] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
    LU[2][6] = C[1][2] - LU[0][6]*LU[2][0] - LU[1][6]*LU[2][1];
    
    LU[3][0] = A[3][0]/LU[0][0];
    LU[3][1] = (A[3][1] - LU[0][1]*LU[3][0])/LU[1][1];
    assert(LU[2][2] != 0.0);
    LU[3][2] = (A[3][2] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
    LU[3][3] = A[3][3] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
    LU[3][4] = A[3][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
    LU[3][5] = C[0][3] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];
    LU[3][6] = C[1][3] - LU[0][6]*LU[3][0] - LU[1][6]*LU[3][1] - LU[2][6]*LU[3][2];
    
    LU[4][0] = A[4][0]/LU[0][0];
    LU[4][1] = (A[4][1] - LU[0][1]*LU[4][0])/LU[1][1];
    LU[4][2] = (A[4][2] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
    assert(LU[3][3] != 0.0);
    LU[4][3] = (A[4][3] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
    LU[4][4] = A[4][4] - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
    LU[4][5] = C[0][4] - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
    LU[4][6] = C[1][4] - LU[0][6]*LU[4][0] - LU[1][6]*LU[4][1] - LU[2][6]*LU[4][2] - LU[3][6]*LU[4][3];
    
    LU[5][0] = C[0][0]/LU[0][0];
    LU[5][1] = (C[0][1] - LU[0][1]*LU[5][0])/LU[1][1];
    LU[5][2] = (C[0][2] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
    LU[5][3] = (C[0][3] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
    assert(LU[4][4] != 0.0);
    LU[5][4] = (C[0][4] - LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
    LU[5][5] = - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];
    LU[5][6] = - LU[0][6]*LU[5][0] - LU[1][6]*LU[5][1] - LU[2][6]*LU[5][2] - LU[3][6]*LU[5][3] - LU[4][6]*LU[5][4];

    LU[6][0] = C[1][0]/LU[0][0];
    LU[6][1] = (C[1][1] - LU[0][1]*LU[6][0])/LU[1][1];
    LU[6][2] = (C[1][2] - LU[0][2]*LU[6][0] - LU[1][2]*LU[6][1])/LU[2][2];
    LU[6][3] = (C[1][3] - LU[0][3]*LU[6][0] - LU[1][3]*LU[6][1] - LU[2][3]*LU[6][2])/LU[3][3];
    LU[6][4] = (C[1][4] - LU[0][4]*LU[6][0] - LU[1][4]*LU[6][1] - LU[2][4]*LU[6][2] - LU[3][4]*LU[6][3])/LU[4][4];
    assert(LU[5][5] != 0.0);
    LU[6][5] = (- LU[0][5]*LU[6][0] - LU[1][5]*LU[6][1] - LU[2][5]*LU[6][2] - LU[3][5]*LU[6][3] - LU[4][5]*LU[6][4])/LU[5][5];
    LU[6][6] = - LU[0][6]*LU[6][0] - LU[1][6]*LU[6][1] - LU[2][6]*LU[6][2] - LU[3][6]*LU[6][3] - LU[4][6]*LU[6][4] - LU[5][6]*LU[6][5];
    assert(LU[6][6] != 0.0);
    
    // check...

    for (int i = 0; i < 7; ++i) {
      for (int j = 0; j < 7; ++j) {
	
	double coeff;

	if (i < 5) {
	  if (j < 5) {
	    coeff = A[i][j];
	  }
	  else {
	    coeff = C[j-5][i];
	  }
	}
	else if (j < 5) {
	  coeff = C[i-5][j];
	}
	else {
	  coeff = 0.0;
	}

	
	// now compute the L*U...
	
	{
	double l[7];
	for (int k = 0; k < i; ++k) l[k] = LU[i][k];
	l[i] = 1.0;
	for (int k = i+1; k < 7; ++k) l[k] = 0.0;
	double u[7];
	for (int k = 0; k <= j; ++k) u[k] = LU[k][j];
	for (int k = j+1; k < 7; ++k) u[k] = 0.0;
	double sum = 0.0;
	for (int k = 0; k < 7; ++k) sum += l[k]*u[k];
	
	cout << coeff-sum << " ";
	}
	
      }
      cout << endl;
    }

    getchar();

    // now 
    
    double sum = 0.0;
    for (int coc = 0, ncoc = cvocv_i[icv+1]-cvocv_i[icv]; coc < ncoc; ++coc) {
      
      // HACK
      //if ((coc!=0)&&(coc!=1)&&(coc!= 6))
      //continue;
      
      const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
      assert((icv_nbr >= 0)&&(icv_nbr < ncv)); // serial for now

      // HACK
      //if ((icv_nbr != icv0)&&(icv_nbr != icv1)) 
      //	continue;

      // overwrite rhs...
      
      for (int i = 1; i < 7; ++i) 
	for (int j = 0; j < i; ++j)
	  rhs[coc][i] -= LU[i][j]*rhs[coc][j];
      
      // and back substitute to solve...
      
      rhs[coc][6] /= LU[6][6];
      
      for (int i = 5; i >= 4; --i) {
	for (int j = i+1; j < 7; ++j)
	  rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	rhs[coc][i] /= LU[i][i];
      }
      
      cout << "coc: " << coc << " rhs: " << rhs[coc][4] << " at dx: " << 
	x_cv[icv_nbr][0]-x_cv[icv][0] << " " << 
	x_cv[icv_nbr][1]-x_cv[icv][1] << " " << 
	x_cv[icv_nbr][2]-x_cv[icv][2] << endl;
      sum += rhs[coc][4]; 
      
    }
    
    cout << "coeff sum: " << sum << " error: " << 1.0-sum << endl;

      
    // for the dimensions tangent to the face, use dimensions
    

    MPI_Pause("MADE IT to the end of buildNewOps()");





  
#ifdef JUNKJUNK

  void addLsp(const int np,const double (* const xp)[4]) {
    
    assert(rgb_local);
    assert(depth_local);

    const float base3[3] = { 0.99f, 0.96f, 0.89f }; // * color
    const float base2[3] = { 0.92f, 0.91f, 0.83f };
    const float base00[3] = { 0.40f, 0.48f, 0.51f };
    
    const float light1[3] = { 0.0f, 0.0f, 1.0f };
    const float light2[3] = { -0.57f, -0.57f, 0.57f };
    
    //const float rp = 2; // particle radius in pixels
    for (int ip = 0; ip < np; ++ip) {
      const float rp = (xp[ip][3]) / (width/float(ni)); // particle radius in pixels
      const float ic = CALC_PIXEL_I(xp[ip]);
      if ((ic+rp > 0)&&(ic-rp < ni)) {
	const float jc = CALC_PIXEL_J(xp[ip]);
	if ((jc+rp > 0)&&(jc-rp < nj)) {
	  const float dc = CALC_PIXEL_DEPTH(xp[ip]);
	  const int i0 = max(0,(int)ceil(ic-rp));
	  const int i1 = min(ni-1,(int)floor(ic+rp));
	  const int j0 = max(0,(int)ceil(jc-rp));
	  const int j1 = min(nj-1,(int)floor(jc+rp));
	  for (int j = j0; j <= j1; ++j) {
	    const float dj = float(j)-jc;
	    for (int i = i0; i <= i1; ++i) {
	      const float di = float(i)-ic;
	      const float dz2 = rp*rp - di*di - dj*dj;
	      if (dz2 > 0.0) {
		// the normal...
		const float dz = sqrtf(dz2);
		const int ij = CALC_PIXEL_IJ(i,j);
		if (dc + dz > depth_local[ij]) {
		  depth_local[ij] = dc + dz;
		  const float normal[3] = { di, dj, dz };
		  const float mag = sqrtf( normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2] );
		  assert(mag > 0.0f);
		  // lighting model...
		  const float a = DOT_PRODUCT(normal,light1)/mag;
		  const float b = DOT_PRODUCT(normal,light2)/mag;
		  const double p =
		    (a*base2[0] + (1.0-a)*base00[0])*0.5 +
		    (b*base3[0] + (1.0-b)*base00[0])*0.5;
		  rgb_local[ij][0] = max(0,min(255,(int)(p*256.0)));
		  rgb_local[ij][1] = rgb_local[ij][0];
		  rgb_local[ij][2] = rgb_local[ij][0];
		}
	      }
	    }
	  }
	}
      }
    }

  }
  
  void activateScalarPlane() {

    if (scalar_plane_dist2_value_local == NULL) {
      scalar_plane_dist2_value_local = new float[ni*nj][2];
      for (int ij = 0; ij < ni*nj; ++ij) {
	scalar_plane_dist2_value_local[ij][0] = PIXEL_DIST2_MAX;
      }
    }
    
  }
  
  void addScalarPlane(const double * const phi_cv,const int ncv,const double (* const x_cv)[3],const double * const r_cv) {
  
    assert(scalar_plane_dist2_value_local);
  
    for (int icv = 0; icv < ncv; ++icv) {

      const float dc = CALC_PIXEL_DEPTH(x_cv[icv]);
      const float rc = r_cv[icv]*float(ni)/width; // convert r to pixels...
      const float rxy2 = rc*rc - dc*dc;
      if (rxy2 > 0.0) {
	// the radius on the image plane is less than the pixel version of r_cv because
	// the point is generally off the plane...
	const double rxy = sqrtf(rxy2);
	const float ic = CALC_PIXEL_I(x_cv[icv]);
	if ((ic+rxy > 0)&&(ic-rxy < ni)) {
	  const float jc = CALC_PIXEL_J(x_cv[icv]);
	  if ((jc+rxy > 0)&&(jc-rxy < nj)) {
	    for (int j = max(0,(int)ceil(jc-rxy)); j <= min(nj-1,(int)floor(jc+rxy)); ++j) {
	      const double rx = sqrtf(max(0.f,rxy2 - (float(j)-jc)*(float(j)-jc)));
	      for (int i = max(0,(int)ceil(ic-rx)); i <= min(ni-1,(int)floor(ic+rx)); ++i) {
		const float dist2 = dc*dc + (float(i)-ic)*(float(i)-ic) + (float(j)-jc)*(float(j)-jc);
		const int ij = CALC_PIXEL_IJ(i,j);
		if (dist2 < scalar_plane_dist2_value_local[ij][0]) {
		  scalar_plane_dist2_value_local[ij][0] = dist2;
		  scalar_plane_dist2_value_local[ij][1] = float(phi_cv[icv]);
		}
	      }
	    }
	  }
	}
      }
      
    }

    /*
      FILE * fp = fopen("junk.dat","w");
      for (int i = 0; i < ni; ++i) {
      for (int j = 0; j < nj; ++j) {
      const int ij = CALC_PIXEL_IJ(i,j);
      if (scalar_plane_dist2_local[ij] < PIXEL_DIST2_MAX)
      fprintf(fp,"%d %d %18.15le\n",i+1,j+1,scalar_plane_value_local[ij]);
      }
      }
      fclose(fp);
      MPI_Pause("take a look");
    */

  }
  
  void activateRgbFlood() {

    if (rgb_plane_local == NULL) {
      rgb_plane_local = new unsigned char[ni*nj][4]; // r,g,b, and on
      for (int ij = 0; ij < ni*nj; ++ij) {
	rgb_plane_local[ij][0] = 0;
	rgb_plane_local[ij][1] = 0;
	rgb_plane_local[ij][2] = 0;
	rgb_plane_local[ij][3] = 255; // fully transparent
      }
    }
    
  }
    
  void addRgbFlood(const unsigned char r,const unsigned char g,const unsigned char b,
		   const double (* const x_cv)[3],const double * const r_cv,const int ncv) {
  
    assert(rgb_plane_local);
  
    for (int icv = 0; icv < ncv; ++icv) {
      
      // for these points, use the full radius...
      const float rxy = r_cv[icv]*float(ni)/width; // was rc*rc - dc*dc;
      // the radius on the image plane is less than the pixel version of r_cv because
      // the point is generally off the plane...
      const float ic = CALC_PIXEL_I(x_cv[icv]);
      if ((ic+rxy > 0)&&(ic-rxy < ni)) {
	const float jc = CALC_PIXEL_J(x_cv[icv]);
	if ((jc+rxy > 0)&&(jc-rxy < nj)) {
	  for (int j = max(0,(int)ceil(jc-rxy)); j <= min(nj-1,(int)floor(jc+rxy)); ++j) {
	    const double rx = sqrtf(max(0.f,rxy*rxy - (float(j)-jc)*(float(j)-jc)));
	    for (int i = max(0,(int)ceil(ic-rx)); i <= min(ni-1,(int)floor(ic+rx)); ++i) {
	      const int ij = CALC_PIXEL_IJ(i,j);
	      if (rgb_plane_local[ij][3] >= 1) { // 1 or 255
		rgb_plane_local[ij][0] = r;
		rgb_plane_local[ij][1] = g;
		rgb_plane_local[ij][2] = b;
		rgb_plane_local[ij][3] = 1; // active if plotted on gray background 
	      }
	    }
	  }
	}
      }

    }
    
  }
  
  void forceRgbPixels(const unsigned char r,const unsigned char g,const unsigned char b,
		      const double (* const x_cv)[3],const int ncv) {

    assert(rgb_plane_local);

    for (int icv = 0; icv < ncv; ++icv) {
      const int ic = (int)floor(CALC_PIXEL_I(x_cv[icv])+0.5);
      if ((ic >= 0)&&(ic < ni)) {
	const int jc = (int)floor(CALC_PIXEL_J(x_cv[icv])+0.5);
	if ((jc >= 0)&&(jc < nj)) {
	  const int ij = CALC_PIXEL_IJ(ic,jc);
	  rgb_plane_local[ij][0] = r;
	  rgb_plane_local[ij][1] = g;
	  rgb_plane_local[ij][2] = b;
	  rgb_plane_local[ij][3] = 0; // active and forced
	}
      }
    }
    
  }
      
  void writeLocalImage(const string& prefix,const int index) {
    
    assert(rgb_local);
    assert(depth_local);
    
    // because the PngImage class deletes its passed buffer, we need to 
    // allocate a separate buffer here...
    
    unsigned char (*rgb)[3] = new unsigned char[ni*nj][3];
    for (int ij = 0; ij < ni*nj; ++ij) {
      if (depth_local[ij] == PIXEL_DEPTH_MIN) {
	// set famous blue in parts of the image where no information exists...
	rgb[ij][0] = 73;
	rgb[ij][1] = 175;
	rgb[ij][2] = 205;
      }
      else {
	rgb[ij][0] = rgb_local[ij][0];
	rgb[ij][1] = rgb_local[ij][1];
	rgb[ij][2] = rgb_local[ij][2];
      }
    }
    
    // note: this deletes passes rgb...

    PngImage png(ni,nj,0,&rgb[0][0]); // what is precision?

    char filename[128];
    sprintf(filename,"%s.%08d.%04d.png",prefix.c_str(),index,mpi_rank);
    png.write(filename);
    
  }

  void setRgb24BitStraight(unsigned char rgb[3],const float p) {
    assert((p >= 0.f)&&(p <= 1.f));
    // 2^24-1 = 16777215
    unsigned int ui = max((unsigned int)0,min((unsigned int)16777215,(unsigned int)(16777216.0*p)));
    rgb[0] = (unsigned char)(ui & ((1<<8)-1));
    rgb[1] = (unsigned char)((ui>>8) & ((1<<8)-1));
    rgb[2] = (unsigned char)((ui>>16) & ((1<<8)-1));
    assert( (unsigned char)((ui>>24) & ((1<<8)-1)) == 0 );
  }
  
  void setRgb24BitWoven(unsigned char rgb[3],const float p) {
    assert((p >= 0.f)&&(p <= 1.f));
    // 2^24-1 = 16777215
    unsigned int ui = max((unsigned int)0,min((unsigned int)16777215,(unsigned int)(16777216.0*p)));
    rgb[0] = 0;
    rgb[1] = 0;
    rgb[2] = 0;
    for (int i = 0; i < 8; ++i) {
      for (int j = 0; j < 3; ++j) {
	const int bit = i*3+j;
	if (ui & (1<<bit)) {
	  rgb[j] |= (1<<i);
	}
      }
    }
  }
  
  void setRgb24Bit(unsigned char rgb[3],const float p) {
    // simple greyscale...
    assert((p >= 0.f)&&(p <= 1.f));
    // 2^24-1 = 16777215
    unsigned int ui = max((unsigned int)0,min((unsigned int)255,(unsigned int)(256.0*p)));
    rgb[0] = (unsigned char)ui;
    rgb[1] = (unsigned char)ui;
    rgb[2] = (unsigned char)ui;
  }
  
  void writeImage(const string& prefix,const int index) {
    
    char filename[128];
    sprintf(filename,"%s.%08d.png",prefix.c_str(),index);
    writeImage(filename);

  }
  
  void writeImage(const string& filename) {

    const int write_rank = 0;
    
    // set famous blue in parts of the image where no information exists...

    if (rgb_full == NULL) 
      reduceToRgbFull();

    // =======================================================================
    // is there a planar part?...
    // eventually break this out from above so it can be done 
    // on a saved version of the rgb_full...
    // =======================================================================
    
    if (scalar_plane_dist2_value_local != NULL) {
      
      int ibuf[4] = { ni, -1, nj, -1 }; // imin, imax, jmin, jmax
      float my_range[2] = { LARGE_FLOAT, LARGE_FLOAT };
      for (int j = 0; j < nj; ++j) {
	for (int i = 0; i < ni; ++i) {
	  const int ij = CALC_PIXEL_IJ(i,j);
	  if (scalar_plane_dist2_value_local[ij][0] < PIXEL_DIST2_MAX) {
	    ibuf[0] = min(ibuf[0],i);
	    ibuf[1] = max(ibuf[1],i);
	    ibuf[2] = min(ibuf[2],j);
	    ibuf[3] = max(ibuf[3],j);
	    my_range[0] = min(my_range[0],scalar_plane_dist2_value_local[ij][1]);
	    my_range[1] = min(my_range[1],-scalar_plane_dist2_value_local[ij][1]);
	  }
	}
      }
      
      int (*ibuf_global)[4] = NULL;
      if (mpi_rank == write_rank)
	ibuf_global = new int[mpi_size][4];
      MPI_Gather(ibuf,4,MPI_INT,ibuf_global,4,MPI_INT,write_rank,mpi_comm);
      
      float actual_range[2];
      MPI_Reduce(my_range,actual_range,2,MPI_FLOAT,MPI_MIN,write_rank,mpi_comm);
      
      if (mpi_rank == write_rank) {
	
	actual_range[1] = -actual_range[1];
	cout << " > actual plane data range: " << actual_range[0] << " " << actual_range[1] << endl;

	if (!got_range) {
	  // if no range is set, use the actual_range...
	  range[0] = actual_range[0];
	  range[1] = actual_range[1];
	}
	else {
	  cout << " > user-specified range: " << range[0] << " " << range[1] << endl;
	}
			
	
	// build a float dist2_full   
	
	float * dist2_full = new float[ni*nj];
	for (int ij = 0; ij < ni*nj; ++ij) {
	  // look for "grey" pixels...
	  if ((rgb_full[ij][0] == rgb_full[ij][1])&&(rgb_full[ij][0] == rgb_full[ij][2])) {
	    dist2_full[ij] = PIXEL_DIST2_MAX;
	  }
	  else {
	    dist2_full[ij] = -1.0; // can never be overwritten...
	  }
	}
	
	// add our own data first...
	
	for (int j = ibuf[2]; j <= ibuf[3]; ++j) {
	  for (int i = ibuf[0]; i <= ibuf[1]; ++i) {
	    const int ij = CALC_PIXEL_IJ(i,j);
	    if (scalar_plane_dist2_value_local[ij][0] < dist2_full[ij]) {
	      dist2_full[ij] = scalar_plane_dist2_value_local[ij][0];
	      const float p = max(0.f,min(1.f,(scalar_plane_dist2_value_local[ij][1]-range[0])/(range[1]-range[0])));
	      // use a "special" colormap that uses rgb as 8 bit parts of a 24 bit unsigned int...
	      setRgb24Bit(rgb_full[ij],p);
	    }
	  }
	}
	
	
	int buf_size_max = 0;
	FOR_RANK
	  if (rank != mpi_rank) 
	    buf_size_max = max(buf_size_max,max(0,(ibuf_global[rank][1]-ibuf_global[rank][0]+1))*max(0,(ibuf_global[rank][3]-ibuf_global[rank][2]+1)));
      
	float (*dist2_value_buf)[2] = new float[buf_size_max][2];
            
	// and then from messages...
	
	FOR_RANK {
	  if (rank != mpi_rank) {

	    const int buf_size = max(0,(ibuf_global[rank][1]-ibuf_global[rank][0]+1))*max(0,(ibuf_global[rank][3]-ibuf_global[rank][2]+1));
	    if (buf_size > 0) {
	      
	      MPI_Recv(dist2_value_buf,buf_size*2,MPI_FLOAT,rank,323334,mpi_comm,MPI_STATUS_IGNORE);
	      
	      int ij_buf = 0;
	      for (int j = ibuf_global[rank][2]; j <= ibuf_global[rank][3]; ++j) {
		for (int i = ibuf_global[rank][0]; i <= ibuf_global[rank][1]; ++i) {
		  const int ij = CALC_PIXEL_IJ(i,j);
		  if (dist2_value_buf[ij_buf][0] < dist2_full[ij]) {
		    dist2_full[ij] = dist2_value_buf[ij_buf][0];
		    const float p = max(0.f,min(1.f,(dist2_value_buf[ij_buf][1]-range[0])/(range[1]-range[0])));
		    setRgb24Bit(rgb_full[ij],p);
		  }
		  ++ij_buf;
		}
	      }
	      assert(ij_buf == buf_size);
	      
	    }
	  }
	}

	delete[] dist2_value_buf;
	delete[] dist2_full;
	delete[] ibuf_global;
	
      }
      else {

	// non-image rank...
      
	const int buf_size = max(0,(ibuf[1]-ibuf[0]+1))*max(0,(ibuf[3]-ibuf[2]+1));
	if (buf_size > 0) {
	
	  float (*dist2_value_buf)[2] = new float[buf_size][2];
	  
	  // add our own data first...
	  
	  int ij_buf = 0;
	  for (int j = ibuf[2]; j <= ibuf[3]; ++j) {
	    for (int i = ibuf[0]; i <= ibuf[1]; ++i) {
	      const int ij = CALC_PIXEL_IJ(i,j);
	      dist2_value_buf[ij_buf][0] = scalar_plane_dist2_value_local[ij][0];
	      dist2_value_buf[ij_buf][1] = scalar_plane_dist2_value_local[ij][1];
	      ++ij_buf;
	    }
	  }
	  assert(ij_buf == buf_size);

	  MPI_Ssend(dist2_value_buf,buf_size*2,MPI_FLOAT,write_rank,323334,mpi_comm);
	  
	  delete[] dist2_value_buf;
	
	}
      }

    }
    
    // =======================================================================
    // is there an rgb part?...
    // AS FOR ABOVE PLANE, eventually break this out from above so it can be done 
    // on a saved version of the rgb_full...
    // =======================================================================
    
    if (rgb_plane_local != NULL) {
      
      int ibuf[4] = { ni, -1, nj, -1 }; // imin, imax, jmin, jmax
      for (int j = 0; j < nj; ++j) {
	for (int i = 0; i < ni; ++i) {
	  const int ij = CALC_PIXEL_IJ(i,j);
	  // recall alpha channel == 0,1 means on...
	  if (rgb_plane_local[ij][3] <= 1) { 
	    ibuf[0] = min(ibuf[0],i);
	    ibuf[1] = max(ibuf[1],i);
	    ibuf[2] = min(ibuf[2],j);
	    ibuf[3] = max(ibuf[3],j);
	  }
	}
      }
      
      int (*ibuf_global)[4] = NULL;
      if (mpi_rank == write_rank)
	ibuf_global = new int[mpi_size][4];
      MPI_Gather(ibuf,4,MPI_INT,ibuf_global,4,MPI_INT,write_rank,mpi_comm);
      
      if (mpi_rank == write_rank) {
	
	// add our own data first...
	
	for (int j = ibuf[2]; j <= ibuf[3]; ++j) {
	  for (int i = ibuf[0]; i <= ibuf[1]; ++i) {
	    const int ij = CALC_PIXEL_IJ(i,j);
	    // if force is set, then render, otherwise look for "grey" pixels only...
	    if ((rgb_plane_local[ij][3] == 0) || ((rgb_plane_local[ij][3] == 1)&&(rgb_full[ij][0] == rgb_full[ij][1])&&(rgb_full[ij][0] == rgb_full[ij][2]))) {
	      rgb_full[ij][0] = rgb_plane_local[ij][0];
	      rgb_full[ij][1] = rgb_plane_local[ij][1];
	      rgb_full[ij][2] = rgb_plane_local[ij][2];
	    }
	  }
	}
	
	int buf_size_max = 0;
	FOR_RANK
	  if (rank != mpi_rank) 
	    buf_size_max = max(buf_size_max,max(0,(ibuf_global[rank][1]-ibuf_global[rank][0]+1))*max(0,(ibuf_global[rank][3]-ibuf_global[rank][2]+1)));
	
	unsigned char (*rgb_plane_buf)[4] = new unsigned char[buf_size_max][4];
        
	// and then from messages...
	
	FOR_RANK {
	  if (rank != mpi_rank) {
	    
	    const int buf_size = max(0,(ibuf_global[rank][1]-ibuf_global[rank][0]+1))*max(0,(ibuf_global[rank][3]-ibuf_global[rank][2]+1));
	    if (buf_size > 0) {
	      
	      MPI_Recv(rgb_plane_buf,buf_size*4,MPI_UNSIGNED_CHAR,rank,42324,mpi_comm,MPI_STATUS_IGNORE);
	      
	      int ij_buf = 0;
	      for (int j = ibuf_global[rank][2]; j <= ibuf_global[rank][3]; ++j) {
		for (int i = ibuf_global[rank][0]; i <= ibuf_global[rank][1]; ++i) {
		  const int ij = CALC_PIXEL_IJ(i,j);
		  if ((rgb_plane_buf[ij_buf][3] == 0) || ((rgb_plane_buf[ij_buf][3] == 1)&&(rgb_full[ij][0] == rgb_full[ij][1])&&(rgb_full[ij][0] == rgb_full[ij][2]))) {
		    rgb_full[ij][0] = rgb_plane_buf[ij_buf][0];
		    rgb_full[ij][1] = rgb_plane_buf[ij_buf][1];
		    rgb_full[ij][2] = rgb_plane_buf[ij_buf][2];
		  }
		  ++ij_buf;
		}
	      }
	      assert(ij_buf == buf_size);
	    }
	  }
	}

	delete[] rgb_plane_buf;
	delete[] ibuf_global;
	
      }
      else {

	// non-image rank...
      
	const int buf_size = max(0,(ibuf[1]-ibuf[0]+1))*max(0,(ibuf[3]-ibuf[2]+1));
	if (buf_size > 0) {
	  
	  unsigned char (*rgb_plane_buf)[4] = new unsigned char[buf_size][4];
	  
	  // add our own data first...
	  
	  int ij_buf = 0;
	  for (int j = ibuf[2]; j <= ibuf[3]; ++j) {
	    for (int i = ibuf[0]; i <= ibuf[1]; ++i) {
	      const int ij = CALC_PIXEL_IJ(i,j);
	      rgb_plane_buf[ij_buf][0] = rgb_plane_local[ij][0];
	      rgb_plane_buf[ij_buf][1] = rgb_plane_local[ij][1];
	      rgb_plane_buf[ij_buf][2] = rgb_plane_local[ij][2];
	      rgb_plane_buf[ij_buf][3] = rgb_plane_local[ij][3];
	      ++ij_buf;
	    }
	  }
	  assert(ij_buf == buf_size);
	  
	  MPI_Ssend(rgb_plane_buf,buf_size*4,MPI_UNSIGNED_CHAR,write_rank,42324,mpi_comm);
	  
	  delete[] rgb_plane_buf;
	  
	}
      }
      
    }
      
    // ==================================================================
    // finally write the image...
    // ==================================================================
    
    if (mpi_rank == write_rank) {

      // and finally, write the reduced image...
      
      assert(rgb_full);
      
      {
	
	PngImage png(ni,nj,0,&rgb_full[0][0]); // what is precision?
	
	ImageMetadata imd;
	imd.colorMapName      = "GRAYSCALE_RGB";
	char strbuf[1024]={'\0'};
	sprintf(strbuf,"%.15g",range[0]);
	imd.rangeMin          = strbuf;
	sprintf(strbuf,"%.15g",range[1]);
	imd.rangeMax          = strbuf;

	imd.varId             = "PHI";

	const double width_ni_ratio = width/(double)ni;

	sprintf(strbuf,"%.15g",width_ni_ratio);
	imd.lengthScale       = strbuf;
	
	double transMat[16];
	const double width_ni_ratio2 = width_ni_ratio*width_ni_ratio;
	transMat[0]  = e0[0]*width_ni_ratio2;
	transMat[1]  = e0[1]*width_ni_ratio2;
	transMat[2]  = e0[2]*width_ni_ratio2;
	transMat[3]  = 0.0;
	transMat[4]  = e1[0]*width_ni_ratio2;
	transMat[5]  = e1[1]*width_ni_ratio2;
	transMat[6]  = e1[2]*width_ni_ratio2;
	transMat[7]  = 0.0;
	transMat[8]  = e2[0]*width_ni_ratio2;
	transMat[9]  = e2[1]*width_ni_ratio2;
	transMat[10] = e2[2]*width_ni_ratio2;
	transMat[11] = 0.0;
	transMat[12] = x0[0];
	transMat[13] = x0[1];
	transMat[14] = x0[2];
	transMat[15] = 1.0;
	imd.setTransformMat(transMat,16);
	
	png.set_metadata(&imd);
	png.setDepth(0);
	
	png.write(filename.c_str());
    
      }

      rgb_full = NULL; // delete'd when png destroyed
      
    }

    MPI_Barrier(mpi_comm);
    
  }
  
  void reduceToRgbFull() {

    const int write_rank = 0;
      
    assert(rgb_full == NULL);
    assert(rgb_local);
    assert(depth_local);
      
    // step 1. figure out the minimal bounding box for our image...
    
    int ibuf[4] = { ni, -1, nj, -1 }; // imin, imax, jmin, jmax
    for (int j = 0; j < nj; ++j) {
      for (int i = 0; i < ni; ++i) {
	const int ij = CALC_PIXEL_IJ(i,j);
	if (depth_local[ij] > PIXEL_DEPTH_MIN) {
	  ibuf[0] = min(ibuf[0],i);
	  ibuf[1] = max(ibuf[1],i);
	  ibuf[2] = min(ibuf[2],j);
	  ibuf[3] = max(ibuf[3],j);
	}
      }
    }
    
    int (*ibuf_global)[4] = NULL;
    if (mpi_rank == write_rank)
      ibuf_global = new int[mpi_size][4];
    
    MPI_Gather(ibuf,4,MPI_INT,ibuf_global,4,MPI_INT,write_rank,mpi_comm);
    
    if (mpi_rank == write_rank) {
      
      // we are the image rank...
      
      assert(rgb_full == NULL);
      rgb_full = new unsigned char[ni*nj][3];
      float * depth = new float[ni*nj];
      for (int ij = 0; ij < ni*nj; ++ij) {
	depth[ij] = PIXEL_DEPTH_MIN;
	rgb_full[ij][0] = 73;
	rgb_full[ij][1] = 175;
	rgb_full[ij][2] = 205;
      }
      
      // add our own data first...
      
      for (int j = ibuf[2]; j <= ibuf[3]; ++j) {
	for (int i = ibuf[0]; i <= ibuf[1]; ++i) {
	  const int ij = CALC_PIXEL_IJ(i,j);
	  if (depth_local[ij] > depth[ij]) {
	    depth[ij] = depth_local[ij];
	    rgb_full[ij][0] = rgb_local[ij][0];
	    rgb_full[ij][1] = rgb_local[ij][1];
	    rgb_full[ij][2] = rgb_local[ij][2];
	  }
	}
      }
      
      // and then from messages...
      
      int buf_size_max = 0;
      FOR_RANK
	if (rank != mpi_rank) 
	  buf_size_max = max(buf_size_max,max(0,(ibuf_global[rank][1]-ibuf_global[rank][0]+1))*max(0,(ibuf_global[rank][3]-ibuf_global[rank][2]+1)));
      
      unsigned char (*rgb_buf)[3] = new unsigned char[buf_size_max][3];
      float * depth_buf = new float[buf_size_max];
      
      FOR_RANK {
	if (rank != mpi_rank) {
	  
	  const int buf_size = max(0,(ibuf_global[rank][1]-ibuf_global[rank][0]+1))*max(0,(ibuf_global[rank][3]-ibuf_global[rank][2]+1));
	  if (buf_size > 0) {
	    
	    MPI_Recv(depth_buf,buf_size,MPI_FLOAT,rank,121314,mpi_comm,MPI_STATUS_IGNORE);
	    MPI_Recv(rgb_buf,buf_size*3,MPI_CHAR,rank,222324,mpi_comm,MPI_STATUS_IGNORE);
	    
	    int ij_buf = 0;
	    for (int j = ibuf_global[rank][2]; j <= ibuf_global[rank][3]; ++j) {
	      for (int i = ibuf_global[rank][0]; i <= ibuf_global[rank][1]; ++i) {
		const int ij = CALC_PIXEL_IJ(i,j);
		if (depth_buf[ij_buf] > depth[ij]) {
		  depth[ij] = depth_buf[ij_buf];
		  rgb_full[ij][0] = rgb_buf[ij_buf][0];
		  rgb_full[ij][1] = rgb_buf[ij_buf][1];
		  rgb_full[ij][2] = rgb_buf[ij_buf][2];
		}
		++ij_buf;
	      }
	    }
	    assert(ij_buf == buf_size);
	    
	  }
	}
      }

      delete[] ibuf_global;
      
      delete[] rgb_buf;
      delete[] depth_buf;
      delete[] depth;
      
    }
    else {
      
      // non-image rank...
      
      const int buf_size = max(0,(ibuf[1]-ibuf[0]+1))*max(0,(ibuf[3]-ibuf[2]+1));
      if (buf_size > 0) {
	
	unsigned char (*rgb_buf)[3] = new unsigned char[buf_size][3];
	float * depth_buf = new float[buf_size];
	
	// add our own data first...
	
	int ij_buf = 0;
	for (int j = ibuf[2]; j <= ibuf[3]; ++j) {
	  for (int i = ibuf[0]; i <= ibuf[1]; ++i) {
	    const int ij = CALC_PIXEL_IJ(i,j);
	    depth_buf[ij_buf] = depth_local[ij];
	    rgb_buf[ij_buf][0] = rgb_local[ij][0];
	    rgb_buf[ij_buf][1] = rgb_local[ij][1];
	    rgb_buf[ij_buf][2] = rgb_local[ij][2];
	    ++ij_buf;
	  }
	}
	assert(ij_buf == buf_size);
	
	MPI_Ssend(depth_buf,buf_size,MPI_FLOAT,write_rank,121314,mpi_comm);
	MPI_Ssend(rgb_buf,buf_size*3,MPI_CHAR,write_rank,222324,mpi_comm);
	
	delete[] rgb_buf;
	delete[] depth_buf;
	
      }
      
    }
   
    delete[] rgb_local; rgb_local = NULL;
    delete[] depth_local; depth_local = NULL;
 
  }
  
#endif



      

      unsigned char this_rgb[3];
      {
	const float light1[3] = { 0.0f, 0.0f, 1.0f };
	const float light2[3] = { -0.57f, -0.57f, 0.57f };
	const float base3[3] = { 0.99f, 0.96f, 0.89f }; // * color
	const float base2[3] = { 0.92f, 0.91f, 0.83f };
	const float base00[3] = { 0.40f, 0.48f, 0.51f };
	if (normal[2] >= 0.0) {
	  // surface gold...
	  const float a = DOT_PRODUCT(normal,light1)/mag;
	  const float b = DOT_PRODUCT(normal,light2)/mag;
	  const float p = (a*base2[0] + (1.0-a)*base00[0])*0.5 + (b*base3[0] + (1.0-b)*base00[0])*0.5;
	  this_rgb[0] = max(0,min(255,(int)(p*256.0)));
	  this_rgb[1] = max(0,min(255,(int)(0.93*p*256.0)));
	  this_rgb[2] = max(0,min(255,(int)(0.72*p*256.0)));
	  if (this_rgb[0] == this_rgb[2]) {
	    assert(this_rgb[0] = 0);
	    this_rgb[0] = 1;
	  }
	}
	else {
	  const float a = -DOT_PRODUCT(normal,light1)/mag;
	  const float b = -DOT_PRODUCT(normal,light2)/mag;
	  const float p = (a*base2[0] + (1.0-a)*base00[0])*0.5 + (b*base3[0] + (1.0-b)*base00[0])*0.5;
	  this_rgb[0] = max(0,min(255,(int)(p*128.0))); // dark version of grey
	  this_rgb[1] = this_rgb[0];
	  this_rgb[2] = this_rgb[0];
	}
      }
      


    

    
    cout << "got ni: " << ni << " " << (ni+ni%8)/8 << " " << ((ni+ni%8)>>3) << " nj: " << nj << " " << (nj+nj%8)/8 << endl;

    for (int i = 0; i < ni; ++i) {
      cout << "i: " << i << " i>>3: " << (i>>3) << " (i&7): " << (i&7) << endl;
    }

    for (int j = 0; j < nj; ++j) {
      cout << "j: " << j << " j>>3: " << (j>>3) << " (j&7): " << (j&7) << endl;
    }

    cout << "sizeof(BlockPixelData): " << sizeof(BlockPixelData) << endl;

    getchar();
    

    
    /*
    rgb_local = NULL;
    depth_local = NULL;

    // and the rgb_full...
    
    rgb_full = NULL;
    
    // and the scalar plane storage...
    
    scalar_plane_dist2_value_local = NULL;
    rgb_plane_local = NULL;
    */
    
  }


    if (mpi_rank == 1) {

      for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
	const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
	const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= 0)&&(icv1 < ncv));
      }

      for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
	const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
	const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
	if (icv1 >= ncv_g) {
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g2[icv1-ncv_g]);
	  if (rank == 2) {
	    cout << "rank 1,icv " << icv0 << " linked to rank " << rank << ",icv " << index << " in rbi_g2 range" << endl;
	  }
	}
	else if (icv1 >= ncv) {
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv1-ncv]);
	  if (rank == 2) {
	    cout << "rank 1,icv " << icv0 << " linked to rank " << rank << ",icv " << index << " in rbi_g range" << endl;
	  }
	}
      }
    
      /*
      for (int icv = ncv_g;  icv < ncv_g2; ++icv) {
	int rank,bits,index;
	BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g2[icv-ncv_g]);
	if (rank == 2) {
	  cout << "rank 1 GOT rbi: " << rank << " " << bits << " " << index << endl;
	}
      }
      */

    }

    MPI_Pause("1a");
   
    if (mpi_rank == 2) {
      
      for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
	const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
	const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= 0)&&(icv1 < ncv));
      }
      
      for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
	const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
	const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
	if (icv1 >= ncv_g) {
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g2[icv1-ncv_g]);
	  if (rank == 1) {
	    cout << "rank 2,icv " << icv0 << " linked to rank " << rank << ",icv " << index << " in rbi_g2 range" << endl;
	  }
	}
	else if (icv1 >= ncv) {
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv1-ncv]);
	  if (rank == 1) {
	    cout << "rank 2,icv " << icv0 << " linked to rank " << rank << ",icv " << index << " in rbi_g range" << endl;
	  }
	}
      }
      
      /*
	for (int icv = ncv_g;  icv < ncv_g2; ++icv) {
	int rank,bits,index;
	BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g2[icv-ncv_g]);
	if (rank == 1) {
	  cout << "rank 2 GOT rbi: " << rank << " " << bits << " " << index << endl;
	}
      }
      */
    }

 
    MPI_Pause("1b");
	


    /*

    {

    // and check operator normal sum...
    
    double (*gcl)[3] = new double[ncv][3];
    FOR_ICV FOR_I3 gcl[icv][i] = 0.0;
    
    // check gcl associated with 0.5*(D-D^T)

    for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
    int rank,bits,icv;
    BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
    assert(rank == mpi_rank);
    assert(bits == 0);
    assert((icv >= 0)&&(icv < ncv));
    int rank_nbr,bits_nbr,icv_nbr;
    BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,icv_nbr,coeffVec[ii].rbi_nbr);
    assert(bits_nbr == 0);
    if (coeffVec[ii].transpose)
    FOR_I3 gcl[icv][i] -= 0.5*coeffVec[ii].coeff[i];
    else
    FOR_I3 gcl[icv][i] += 0.5*coeffVec[ii].coeff[i];
    }
    
    for (int ibf = 0; ibf < nbf; ++ibf) {
    const int icv = cvobf[ibf];
    FOR_I3 gcl[icv][i] += bf[ibf].area*bf[ibf].unit_n[i];
    }
    
    dumpRange(gcl,ncv,"GCL of 0.5*(D-DT)");

    for (int ibf = 0; ibf < nbf; ++ibf) {
    const int icv = cvobf[ibf];
    FOR_I3 gcl[icv][i] = 0.0;
    }
    
    dumpRange(gcl,ncv,"GCL of 0.5*(D-DT) excluding boundary cvs");

    //FILE * fp = fopen("debug.dat","w");
    //FOR_ICV {
    //  fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
    //	      x_cv[icv][0],x_cv[icv][1],x_cv[icv][2],
    //	      gcl[icv][0],gcl[icv][1],gcl[icv][2]);
    //   }
    //  fclose(fp);

    delete[] gcl;
    
    }

    MPI_Pause("OKOK");

    */


    /*
      for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
      if (coeffVec[ii].transpose) {
      if (coeffVec[ii].rbi == BitUtils::packRankBitsIndex(rank_debug,0,icv_debug)) {
      if (coeffVec[ii].rbi == coeffVec[ii].rbi_nbr) {
      //cout << "FINAL diag: " << COUT_VEC(coeffVec[ii].coeff) << endl;
      }
      else {
      int rank_nbr,bits_nbr,icv_nbr;
      BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,icv_nbr,coeffVec[ii].rbi_nbr);
      if (rank_nbr == mpi_rank) {
      cout << "FINAL nbr: " << COUT_VEC(coeffVec[ii].coeff) << " at: " << COUT_VEC(x_cv[icv_nbr]) << endl;
      }
      else {
      map<const uint8,int>::const_iterator iter = rbiMap.find(coeffVec[ii].rbi_nbr);
      assert(iter != rbiMap.end());
      const int icv_nbr = iter->second; assert((icv_nbr >= ncv)&&(icv_nbr < ncv_g));
      cout << "FINAL nbr: " << COUT_VEC(coeffVec[ii].coeff) << " at: " << COUT_VEC(x_cv[icv_nbr]) << endl;
      }
      }
      }
      }
      }
      MPI_Pause("transpose: AFTER REDUCTION");
      }
    */





    

    // HEREHERE

    
    
    // now the near flux plane cvs are flagged 4/-4 and the 1-nbr away ones are
    // flagged 2/-2...

    // we need to get the minimum value AND the winning rank: use
    // MPI's MPI_MINLOC capability...
    
    struct {
      double val;
      int   rank;
    } myDi,di;
    
    myDi.val = d2_closest;
    myDi.rank = mpi_rank;
    MPI_Allreduce(&myDi,&di,1,MPI_DOUBLE_INT,MPI_MINLOC,mpi_comm);
    
    if (di.rank == mpi_rank) {
      assert(icv_closest >= 0);
      cv_flag[icv_closest] *= 2;
      cout << "cv_flag[icv_closest]: " << cv_flag[icv_closest] << endl;
      assert((cv_flag[icv_closest] == 8)||(cv_flag[icv_closest] == -8));
    }
    
    // now grow region out...
    
    updateCvData(cv_flag);
    
    for (int icv = 0; icv < ncv; ++icv) {
      if ((cv_flag[icv] == 
      for (int coc = cvocv_i[icv]+1; coc != cvocv_i[icv+1]; ++coc) {
	const int icv_nbr = cvocv_v[coc];
	if (cv_flag[icv]*cv_flag[icv_nbr] < 0) {
	  // an odd product means this cv is on the boundary...
	  cv_flag[icv] *= 2; // makes -1 -> -2
	  assert((cv_flag[icv] == 2)||(cv_flag[icv] == -2));
	  break;
	}
      }
    }

    





      float * filter = new float[nx*ny];
      
      for (int iter = 0; iter < 10; ++iter) {

      for (int i = 0; i < nx; ++i) {
	for (int j = 0; j < ny; ++j) {
	  const int ij = CALC_PIXEL_IJ(i,j);
	  if ((rgb_full[ij][0] == rgb_full[ij][1])&&(rgb_full[ij][0] == rgb_full[ij][2])) {
	    filter[ij] = 2.f*float(rgb_full[ij][0]);
	    float wgt = 2.f;
	    if (i > 0) {
	      const int ij_nbr = CALC_PIXEL_IJ(i-1,j);
	      if ((rgb_full[ij_nbr][0] == rgb_full[ij_nbr][1])&&(rgb_full[ij_nbr][0] == rgb_full[ij_nbr][2])) {
		filter[ij] += float(rgb_full[ij_nbr][0]);
		wgt += 1.f;
	      }
	    }
	    if (i < nx-1) {
	      const int ij_nbr = CALC_PIXEL_IJ(i+1,j);
	      if ((rgb_full[ij_nbr][0] == rgb_full[ij_nbr][1])&&(rgb_full[ij_nbr][0] == rgb_full[ij_nbr][2])) {
		filter[ij] += float(rgb_full[ij_nbr][0]);
		wgt += 1.f;
	      }
	    }
	    filter[ij] /= wgt;
	  }
	}
      }

      for (int i = 0; i < nx; ++i) {
	for (int j = 0; j < ny; ++j) {
	  const int ij = CALC_PIXEL_IJ(i,j);
	  if ((rgb_full[ij][0] == rgb_full[ij][1])&&(rgb_full[ij][0] == rgb_full[ij][2])) {
	    float filter2 = 2.f*filter[ij];
	    float wgt = 2.f;
	    if (j > 0) {
	      const int ij_nbr = CALC_PIXEL_IJ(i,j-1);
	      if ((rgb_full[ij_nbr][0] == rgb_full[ij_nbr][1])&&(rgb_full[ij_nbr][0] == rgb_full[ij_nbr][2])) {
		filter2 += filter[ij_nbr];
		wgt += 1.f;
	      }
	    }
	    if (j < ny-1) {
	      const int ij_nbr = CALC_PIXEL_IJ(i,j+1);
	      if ((rgb_full[ij_nbr][0] == rgb_full[ij_nbr][1])&&(rgb_full[ij_nbr][0] == rgb_full[ij_nbr][2])) {
		filter2 += filter[ij_nbr];
		wgt += 1.f;
	      }
	    }
	    rgb_full[ij][0] = max(0,min(255,(int)(filter2/wgt)));
	    rgb_full[ij][1] = rgb_full[ij][0];
	    rgb_full[ij][2] = rgb_full[ij][0];
	  }
	}
      }

      }

      delete[] filter;
      

    
    

    


void buildSurfaceImageTest(const int index,
			   const int nst,const int (* const spost)[3],const double (* const xsp)[3],
			   const double xp[3],const double np[3],
			   double (*xd)[4],const int nxd,
			   const double width,const int nx,const int ny) {

  // loop through all surface tris and build pixels and/or pixel scan lines:

  float up[3] = { 0.0, 0.0, 1.0 };
  
  float e0[3] = CROSS_PRODUCT(up,np);
  const float e0_mag = MAG(e0); assert(e0_mag > 0.0); // problem with up
  
  float e1[3] = CROSS_PRODUCT(np,e0);
  const float e1_mag = MAG(e1); assert(e1_mag > 0.0); 

  // now we can compute the bottom left corner of the image: this is pixel (i,j) = (0,0)...
  
  const float xp0[3] = {
    xp[0] - 0.5*width*float(nx-1)/float(nx)*e0[0]/e0_mag - 0.5*width*float(ny-1)/float(nx)*e1[0]/e1_mag,
    xp[1] - 0.5*width*float(nx-1)/float(nx)*e0[1]/e0_mag - 0.5*width*float(ny-1)/float(nx)*e1[1]/e1_mag,
    xp[2] - 0.5*width*float(nx-1)/float(nx)*e0[2]/e0_mag - 0.5*width*float(ny-1)/float(nx)*e1[2]/e1_mag
  };

  // and scale the e0 and e1 vectors to produce the correct image width...
  
  FOR_I3 e0[i] *= float(nx)/(width*e0_mag);
  FOR_I3 e1[i] *= float(nx)/(width*e1_mag);
  
  const float np_mag = MAG(np);
  const float np0[3] = {
    np[0]*float(nx)/(width*np_mag),
    np[1]*float(nx)/(width*np_mag),
    np[2]*float(nx)/(width*np_mag)
  };
  
  // check CALC_PIXEL_* macros on xp...
  /*
    cout << "CALC_PIXEL_I(xp): " << CALC_PIXEL_I(xp) << endl;
    cout << "CALC_PIXEL_J(xp): " << CALC_PIXEL_J(xp) << endl;
    cout << "CALC_PIXEL_DEPTH(xp): " << CALC_PIXEL_DEPTH(xp) << endl;
    getchar();
  */
  
  // ======================================================
  // now the pixel location in the image can be computed as
  //   i = (x-xp0)*e0, and 
  //   j = (x-xp0)*e1
  // where
  //   0 <= i < nx
  //   0 <= j < ny
  // ======================================================
  
  // every rank gets their own image-size array of data. Do something smarter 
  // here in the future...

  PixelData * pixelDataArray = new PixelData[nx*ny];

  //assert(mpi_size == 1);
  for (int ist = 0; ist < nst; ++ist) {
    
    const double * const x0 = xsp[spost[ist][0]];
    const double * const x1 = xsp[spost[ist][1]];
    const double * const x2 = xsp[spost[ist][2]];
    
    const float d0 = CALC_PIXEL_DEPTH(x0);
    const float d1 = CALC_PIXEL_DEPTH(x1);
    const float d2 = CALC_PIXEL_DEPTH(x2);
    
    if (min(d0,min(d1,d2)) >= 0) 
      continue;
    
    const float i0 = CALC_PIXEL_I(x0);
    const float i1 = CALC_PIXEL_I(x1);
    const float i2 = CALC_PIXEL_I(x2);

    if ( (max(i0,max(i1,i2)) < 0) || (min(i0,min(i1,i2)) > nx-1) )
      continue;
    
    const float j0 = CALC_PIXEL_J(x0);
    const float j1 = CALC_PIXEL_J(x1);
    const float j2 = CALC_PIXEL_J(x2);

    if ( (max(j0,max(j1,j2)) < 0) || (min(j0,min(j1,j2)) > ny-1) )
      continue;

    const float normal[3] = { (j1-j0)*(d2-d0)-(d1-d0)*(j2-j0),
			      (d1-d0)*(i2-i0)-(i1-i0)*(d2-d0),
			      (i1-i0)*(j2-j0)-(j1-j0)*(i2-i0) };
    const double mag = sqrt( normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2] );
    if (mag == 0.0f)
      continue;
    
    float p;
    if (normal[2] >= 0.0) {
      const float light1[3] = { 0.0f, 0.0f, 1.0f };
      const float light2[3] = { -0.57f, -0.57f, 0.57f };
      const float a = DOT_PRODUCT(normal,light1)/mag;
      const float b = DOT_PRODUCT(normal,light2)/mag;
      const float base3[3] = { 0.99f, 0.96f, 0.89f }; // * color
      const float base2[3] = { 0.92f, 0.91f, 0.83f };
      const float base00[3] = { 0.40f, 0.48f, 0.51f };
      p = (a*base2[0] + (1.0-a)*base00[0])*0.5 + (b*base3[0] + (1.0-b)*base00[0])*0.5;
    }
    else {
      const float light1[3] = { 0.0f, 0.0f, 1.0f };
      const float light2[3] = { -0.57f, -0.57f, 0.57f };
      const float a = -DOT_PRODUCT(normal,light1)/mag;
      const float b = -DOT_PRODUCT(normal,light2)/mag;
      const float base3[3] = { 0.99f, 0.96f, 0.89f }; // * color
      const float base2[3] = { 0.92f, 0.91f, 0.83f };
      const float base00[3] = { 0.40f, 0.48f, 0.51f };
      p = -( (a*base2[0] + (1.0-a)*base00[0])*0.5 + (b*base3[0] + (1.0-b)*base00[0])*0.5 );
    }

    /*
      if (

      // a negative indicates a "gold" color...
      cbuf[ii*3  ] = (unsigned char) max(0,min(255,int(-pixelVec[ip].c*256.0)));
      cbuf[ii*3+1] = (unsigned char) max(0,min(255,int(-pixelVec[ip].c*0.93*256.0)));
      cbuf[ii*3+2] = (unsigned char) max(0,min(255,int(-pixelVec[ip].c*0.72*256.0)));
    */

    // sort the data by y...
    float x0_s[3],x1_s[3],x2_s[3];
    if (j0 <= j1) {
      if (j1 <= j2) {
	x0_s[0] = i0; x0_s[1] = j0; x0_s[2] = d0; 
	x1_s[0] = i1; x1_s[1] = j1; x1_s[2] = d1; 
	x2_s[0] = i2; x2_s[1] = j2; x2_s[2] = d2; 
      }
      else if (j0 <= j2) {
	x0_s[0] = i0; x0_s[1] = j0; x0_s[2] = d0; 
	x1_s[0] = i2; x1_s[1] = j2; x1_s[2] = d2; 
	x2_s[0] = i1; x2_s[1] = j1; x2_s[2] = d1; 
      }
      else {
	x0_s[0] = i2; x0_s[1] = j2; x0_s[2] = d2; 
	x1_s[0] = i0; x1_s[1] = j0; x1_s[2] = d0; 
	x2_s[0] = i1; x2_s[1] = j1; x2_s[2] = d1; 
      }
    }
    else if (j0 <= j2) {
      x0_s[0] = i1; x0_s[1] = j1; x0_s[2] = d1; 
      x1_s[0] = i0; x1_s[1] = j0; x1_s[2] = d0; 
      x2_s[0] = i2; x2_s[1] = j2; x2_s[2] = d2; 
    }
    else if (j1 <= j2) {
      x0_s[0] = i1; x0_s[1] = j1; x0_s[2] = d1; 
      x1_s[0] = i2; x1_s[1] = j2; x1_s[2] = d2; 
      x2_s[0] = i0; x2_s[1] = j0; x2_s[2] = d0; 
    }
    else {
      x0_s[0] = i2; x0_s[1] = j2; x0_s[2] = d2; 
      x1_s[0] = i1; x1_s[1] = j1; x1_s[2] = d1; 
      x2_s[0] = i0; x2_s[1] = j0; x2_s[2] = d0; 
    }

    // check y-sort...
    
    assert(x0_s[1] <= x1_s[1]);
    assert(x1_s[1] <= x2_s[1]);

    // the sorting has divided the tri into 2 vertical pieces...

    const float pixel_eps = 1.0E-6f;

    // these can be equal, but we skip this case...
    
    if (x0_s[1] < x1_s[1]) {
      const int j0_plus = max(0,(int)ceil(x0_s[1]-pixel_eps));
      const int j1_minus = min(ny-1,(int)floor(x1_s[1]+pixel_eps));
      for (int j = j0_plus; j <= j1_minus; ++j) {
	// get the x01 as a linear weight on the x0_s->x1_s line...
	const float w01 = max(0.f,min(1.f,(x1_s[1]-float(j))/(x1_s[1] - x0_s[1])));
	const float x01 = w01*x0_s[0] + (1.0f-w01)*x1_s[0];
	const float w02 = max(0.f,min(1.f,(x2_s[1]-float(j))/(x2_s[1] - x0_s[1])));
	const float x02 = w02*x0_s[0] + (1.0f-w02)*x2_s[0];
	// the x values can be in either order...
	if (x01 < x02) {
	  const int i_f = max(0,(int)ceil(x01-pixel_eps));
	  const int i_l = min(nx-1,(int)floor(x02+pixel_eps));
	  if (i_f <= i_l) {
	    const float d01 = w01*x0_s[2] + (1.0f-w01)*x1_s[2];
	    const float d02 = w02*x0_s[2] + (1.0f-w02)*x2_s[2];
	    for (int i = i_f; i <= i_l; ++i) {
	      const float w = max(0.f,min(1.f,(x02 - float(i))/(x02 - x01)));
	      const float d = w*d01 + (1.0f-w)*d02;
	      if (d <= 0.f) {
		const int ij = CALC_PIXEL_IJ(i,j);
		if (d > pixelDataArray[ij].depth) {
		  pixelDataArray[ij].depth = d;
		  pixelDataArray[ij].value = p;
		}
	      }
	    }
	  }
	}
	else if (x02 < x01) {
	  const int i_f = max(0,(int)ceil(x02-pixel_eps));
	  const int i_l = min(nx-1,(int)floor(x01+pixel_eps));
	  if (i_f <= i_l) {
	    const float d01 = w01*x0_s[2] + (1.0f-w01)*x1_s[2];
	    const float d02 = w02*x0_s[2] + (1.0f-w02)*x2_s[2];
	    for (int i = i_f; i <= i_l; ++i) {
	      const float w = max(0.f,min(1.f,(x01 - float(i))/(x01 - x02)));
	      const float d = w*d02 + (1.0f-w)*d01;
	      if (d <= 0.f) {
		const int ij = CALC_PIXEL_IJ(i,j);
		if (d > pixelDataArray[ij].depth) {
		  pixelDataArray[ij].depth = d;
		  pixelDataArray[ij].value = p;
		}
	      }
	    }
	  }
	}
      }
    }
    
    if (x1_s[1] < x2_s[1]) {
      const int j1_plus = max(0,(int)ceil(x1_s[1]-pixel_eps));
      const int j2_minus = min(ny-1,(int)floor(x2_s[1]+pixel_eps));
      for (int j = j1_plus; j <= j2_minus; ++j) {
	// get the x12 as a linear weight on the x1_s->x2_s line...
	const float w12 = max(0.f,min(1.f,(x2_s[1]-float(j))/(x2_s[1] - x1_s[1])));
	const float x12 = w12*x1_s[0] + (1.0f-w12)*x2_s[0];
	const float w02 = max(0.f,min(1.f,(x2_s[1]-float(j))/(x2_s[1] - x0_s[1])));
	const float x02 = w02*x0_s[0] + (1.0f-w02)*x2_s[0];
	// the x values can be in either order...
	if (x12 < x02) {
	  const int i_f = max(0,(int)ceil(x12-pixel_eps));
	  const int i_l = min(nx-1,(int)floor(x02+pixel_eps));
	  if (i_f <= i_l) {
	    const float d12 = w12*x1_s[2] + (1.0f-w12)*x2_s[2];
	    const float d02 = w02*x0_s[2] + (1.0f-w02)*x2_s[2];
	    for (int i = i_f; i <= i_l; ++i) {
	      const float w = max(0.f,min(1.f,(x02 - float(i))/(x02 - x12)));
	      const float d = w*d12 + (1.0f-w)*d02;
	      if (d <= 0.f) {
		const int ij = CALC_PIXEL_IJ(i,j);
		if (d > pixelDataArray[ij].depth) {
		  pixelDataArray[ij].depth = d;
		  pixelDataArray[ij].value = p;
		}
	      }
	    }
	  }
	}
	else if (x02 < x12) {
	  const int i_f = max(0,(int)ceil(x02-pixel_eps));
	  const int i_l = min(nx-1,(int)floor(x12+pixel_eps));
	  if (i_f <= i_l) {
	    const float d12 = w12*x1_s[2] + (1.0f-w12)*x2_s[2];
	    const float d02 = w02*x0_s[2] + (1.0f-w02)*x2_s[2];
	    for (int i = i_f; i <= i_l; ++i) {
	      const float w = max(0.f,min(1.f,(x12 - float(i))/(x12 - x02)));
	      const float d = w*d02 + (1.0f-w)*d12;
	      if (d <= 0.f) {
		const int ij = CALC_PIXEL_IJ(i,j);
		if (d > pixelDataArray[ij].depth) {
		  pixelDataArray[ij].depth = d;
		  pixelDataArray[ij].value = p;
		}
	      }
	    }
	  }
	}
      }
    }
   
  }

  unsigned char (*cbuf_full)[3] = new unsigned char[nx*ny][3];
  for (int ij = 0; ij < nx*ny; ++ij) {
    if (pixelDataArray[ij].depth == -65535.f) {
      // famous blue...
      cbuf_full[ij][0] = 73;
      cbuf_full[ij][1] = 175;
      cbuf_full[ij][2] = 205;
    }
    else if (pixelDataArray[ij].value >= 0.0) {
      // surface gold...
      cbuf_full[ij][0] = max(0,min(255,(int)(pixelDataArray[ij].value*256.0)));
      cbuf_full[ij][1] = max(0,min(255,(int)(0.93*pixelDataArray[ij].value*256.0)));
      cbuf_full[ij][2] = max(0,min(255,(int)(0.72*pixelDataArray[ij].value*256.0)));
    }
    else {
      // interior fluid-size grey, but darker...
      cbuf_full[ij][0] = max(0,min(127,(int)(-pixelDataArray[ij].value*128.0)));
      cbuf_full[ij][1] = max(0,min(127,(int)(-pixelDataArray[ij].value*128.0)));
      cbuf_full[ij][2] = max(0,min(127,(int)(-pixelDataArray[ij].value*128.0)));
    }
  }
  delete[] pixelDataArray;

  // particle stuff...

  {

    const float base3[3] = { 0.99f, 0.96f, 0.89f }; // * color
    const float base2[3] = { 0.92f, 0.91f, 0.83f };
    const float base00[3] = { 0.40f, 0.48f, 0.51f };
  
    const float light1[3] = { 0.0f, 0.0f, 1.0f };
    const float light2[3] = { -0.57f, -0.57f, 0.57f };
  
    const float rp = 2; // particle radius in pixels
    for (int ip = 0; ip < nxd; ++ip) {
      const float ic = CALC_PIXEL_I(xd[ip]);
      if ((ic+rp > 0)&&(ic-rp < nx)) {
	const float jc = CALC_PIXEL_J(xd[ip]);
	if ((jc+rp > 0)&&(jc-rp < ny)) {
	  const float d = CALC_PIXEL_DEPTH(xd[ip]);
	  const int i0 = max(0,(int)ceil(ic-rp));
	  const int i1 = min(nx-1,(int)floor(ic+rp));
	  const int j0 = max(0,(int)ceil(jc-rp));
	  const int j1 = min(ny-1,(int)floor(jc+rp));
	  for (int i = i0; i <= i1; ++i) {
	    const float di = float(i)-ic;
	    for (int j = j0; j <= j1; ++j) {
	      const float dj = float(j)-jc;
	      const float dz2 = rp*rp - di*di - dj*dj;
	      if (dz2 > 0.0) {
		// the normal...
		const float dz = sqrtf(dz2);
		float normal[3] = { di, dj, dz };
		const float mag = sqrtf( normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2] );
		assert(mag > 0.0f);
		normal[0] /= mag;
		normal[1] /= mag;
		normal[2] /= mag;

		// lighting model...
	      
		const float a = DOT_PRODUCT(normal,light1);
		const float b = DOT_PRODUCT(normal,light2);
	      
		const double p =
		  (a*base2[0] + (1.0-a)*base00[0])*0.5 +
		  (b*base3[0] + (1.0-b)*base00[0])*0.5;
	      
		const int ij = CALC_PIXEL_IJ(i,j);
		cbuf_full[ij][0] = max(0,min(255,(int)(p*256.0)));
		cbuf_full[ij][1] = cbuf_full[ij][0];
		cbuf_full[ij][2] = cbuf_full[ij][0];
	      }
	    }
	  }
	}
      }
    }

  }
  

  PngImage png(nx,ny,0,&cbuf_full[0][0]); // what is precision?

  char filename[128];
  sprintf(filename,"lsp.%08d.%04d.png",index,mpi_rank);
  png.write(filename);

  //delete[] cbuf_full; // can't do this
  
  /*
    cout << "writing file..." << endl;
    FILE * fp = fopen("pixel.dat","w");
    for (int j = 0; j < ny; ++j) {
    for (int i = 0; i < nx; ++i) {
    const int ij = CALC_PIXEL_IJ(i,j);
    if (pixelDataArray[ij].depth > -65535.f)
    fprintf(fp,"%d %d %18.15e\n",i+1,j+1,pixelDataArray[ij].value);
    else
    fprintf(fp,"%d %d %18.15e\n",i+1,j+1,0.0);
    }
    }
    fclose(fp);
  */
  
}


	      // =============
	      // make sure the line segment between the particle xp and icv_min's center
	      // does not cross any of our (i.e. icv's) geometry. If it does, we stay and 
	      // we are done...
	      
	      for (int soc = stocv_i[icv]; soc != stocv_i[icv+1]; ++soc) {
		const int ist = stocv_v[soc];
		// the corner coords of this surface tri are...
		const double * const x0 = surface->xp[surface->spost[ist][0]];
		const double * const x1 = surface->xp[surface->spost[ist][1]];
		const double * const x2 = surface->xp[surface->spost[ist][2]];
		// did we cross this tri?...
		const double st_normal[3] = TRI_NORMAL_2(x0,x1,x2); // should be an outward-pointing normal (wrt flow)
		// get the side associated with both points...
		const double d0 = 
		  (xp[0]-x0[0])*st_normal[0] + 
		  (xp[1]-x0[1])*st_normal[1] + 
		  (xp[2]-x0[2])*st_normal[2];
		const double d1 = 
		  (x_cv[icv_min][0]-x0[0])*st_normal[0] + 
		  (x_cv[icv_min][1]-x0[1])*st_normal[1] + 
		  (x_cv[icv_min][2]-x0[2])*st_normal[2];
		// NOTE: this requires tolerance
		if ((d0 <= 0.0)&&(d1 > 0.0)) {
		  // we are done...
		  lspVec[ip].icv = -lspVec[ip].icv-1;
		  break;
		}
	      }
	      // ===============



		  
		  
	      // this is a crossing!...
	      //if (debug) cout << "GOT POTENTIAL CROSSING! icv: " << icv << " d0: " << d0 << " d1: " << d1 << " st_normal: " << COUT_VEC(st_normal) << " xp: " << COUT_VEC(xp) << endl;
	      // compute xi...
	      double xi[3]; FOR_I3 xi[i] = (d1*xp0[i] - d0*xp[i])/(d1-d0);
	      //if (debug) cout << "got xi: " << COUT_VEC(xi) << endl;
	      const double n01[3] = TRI_NORMAL_2(x0,x1,xi);
	      if (DOT_PRODUCT(st_normal,n01) >= 0.0) {
		const double n12[3] = TRI_NORMAL_2(x1,x2,xi);
		if (DOT_PRODUCT(st_normal,n12) >= 0.0) {
		  const double n20[3] = TRI_NORMAL_2(x2,x0,xi);
		  if (DOT_PRODUCT(st_normal,n20) >= 0.0) {
		    // xi is inside the tri...
		    // we want the point that is closes to xp0 -- i.e. the starting point of the particle. 
		    const double d2 = DIST2(xp0,xi);
		    //if (debug) cout << "THIS WAS AN ACTUAL CROSSING with dist: " << sqrt(d2) << endl;
		    if ((ist_closest == -1)||(d2 < d2_closest)) {
		      d2_closest = d2;
		      ist_closest = ist;
		      FOR_I3 xi_closest[i] = xi[i];
		      FOR_I3 st_normal_closest[i] = st_normal[i];







	    {
		double (*xd)[4] = new double[6][4];
		FOR_I3 {
		  FOR_J3 xd[i][j] = surface->xp[surface->spost[ist_closest][i]][j] + st_normal_closest[j];
		}
		FOR_J3 xd[3][j] = xi_closest[j];
		FOR_J3 xd[4][j] = xp0[j];
		FOR_J3 xd[5][j] = xp[j];
				  
		double xp[3] = { 0.0, 0.0, 0.0 };
		double np[3] = { 0.0, 1.0, 0.0 };
		// and the particles you want to render...
		buildSurfaceImageTest(0,surface,xd,6,xp,np,3.0,1500,1500);
	      }
				
	      getchar();
	    }





/*

    ncv = ncv_g = 0;
    x_cv = NULL;
    vol_cv = NULL;
    
    nfa_i = nfa = 0;
    faocv_i = NULL;
    faocv_v = NULL;
    cvofa = NULL;

    fa = NULL;
    
    nbf = 0;
    bfocv_i = NULL;
    bfocv_v = NULL;
    cvobf = NULL;
    
    bf = NULL;

*/



#ifdef JUNKJUNK

void VoronoiPart::buildGrid(int * send_count,int * send_disp,int * recv_count,int * recv_disp) {
  
  COUT1("buildGrid()");
  
  /*
    writeFullCvTecplot(1849,points->xp[1849]);
    writeFullCvTecplot(1867,points->xp[1867]);
    getchar();
  */

  // here we assume that the VD's are all built and we are reconstructing faces
  // (and volumes?). Note that faces are not necessarily the vdArray[ip].nfa,
  // because these are just individual face loops. At this point, all face loops (on
  // the main or orphan cvs) are treated as one face...

  const double boundary_face_crease_angle = 175.0;
  
  map<const uint8,int> rbiMap;
  
  set<pair<int,int> > internalFaceSet;
  vector<InternalFaceData> ifdVec;
  map<const pair<int,int>,int> internalFaceMap;

  ncv = points->np;
  ncv_g = ncv; // number of ghost cvs...
  assert(x_cv == NULL); x_cv = new double[ncv][3];
  assert(vol_cv == NULL); vol_cv = new double[ncv];
  for (int icv = 0; icv < ncv; ++icv) {
    FOR_I3 x_cv[icv][i] = 0.0;
    vol_cv[icv] = 0.0;
  }
  
  assert(faocv_i == NULL); faocv_i = new int[ncv+1];
  faocv_i[0] = 0;

  double my_buf[2] = { 0.0, 0.0 };
  int * fa_flag = NULL;
  FOR_RANK send_count[rank] = 0;

  for (int cycle = 0; cycle < 2; ++cycle) {

    if (cycle == 0) {
      nfa_i = 0;
      nfa = 0;
    }
    else {
      // now use nfa_i,nfa as counters offset properly...
      nfa = nfa_i;
      nfa_i = 0;
    }
    
    for (int ip = 0; ip < points->np; ++ip) {

      assert(vdArray[ip].checkStatusBits(VD_BUILT_AND_MATCHED_BIT));
      if (cycle == 0) {
	// first time through we count faces. Note that we can use a 
	// set here to combine multiple faces/face loops that are shared with the 
	// same neighbor. In the final grid there is at most ONE face with any RBI nbr.
	assert(internalFaceSet.empty());
      }
      else {
	// second time through we build everything... 
	assert(ifdVec.empty());
	assert(internalFaceMap.empty());
      }
      
      for (int ied = 0; ied < vdArray[ip].getNedMain(); ++ied) {
	FOR_I2 {
	  const int ifa = vdArray[ip].getFaoed(ied,i);
	  // consider internal faces only at this point...
	  if (ifa < 0) {
	    // recall vdArray[ip] uses -1 indexing for faces...
	    assert((-ifa-1 >= 0)&&(-ifa-1 < vdArray[ip].getNfa()));
	    // confirm that this is a group0 face. It has to be because
	    // we are looping on group0 edges...
	    // recall that faces have been paired in Step2, and active faces are paired faces where 
	    // neither face is a "zero" face (i.e. its area is below a certain tolerance)...
	    if (vdArray[ip].faceIsActive(-ifa-1)) {
	      // an active face can still be connected to a non-zero group -- this would be an
	      // open face, and should not be included in the normal...
	      int group_nbr,ifa_nbr; 
	      vdArray[ip].setGiForFaceNbr(group_nbr,ifa_nbr,-ifa-1);
	      if (group_nbr == 0) {
		// we have an active face connected to another main group, i.e. NOT open, so include this...
		int group,rank,bits,index;
		vdArray[ip].setGrbiForFace(group,rank,bits,index,-ifa-1);
		assert(bits == 0); // can be periodic in the future
		assert(group == 0); // must be group 0 -- this is a check.
		const pair<int,int> rbiHash = pair<int,int>(BitUtils::packRankBitsNew(rank,bits),index);
		if (cycle == 0) {
		  internalFaceSet.insert(rbiHash);
		}
		else {
		  map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
		  if (iter == internalFaceMap.end()) {
		    internalFaceMap[rbiHash] = ifdVec.size();
		    ifdVec.push_back(InternalFaceData(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i))));
		  }
		  else {
		    const int ifd = iter->second;
		    const double * const x1 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
		    const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
		    if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		      const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		      const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		      vol_cv[ip] += this_vol;
		      ifdVec[ifd].area += this_vol;
		      FOR_J3 {
			const double tmp = this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]);
			ifdVec[ifd].xc[j] += tmp;
			x_cv[ip][j] += tmp;
			ifdVec[ifd].normal[j] += this_n[j];
		      }
		    }
		    else {
		      // face loop should be 1-directional...
		      assert(ifdVec[ifd].x0 == x2);
		    }
		  }
		}
	      }
	    }
	  }
	}
      }
      
      // =============================================================
      // any orphan chunks?...
      // =============================================================
    
      int next = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
      while (next != -1) {
	// edge loop on ocdVec[next]...
	for (int ied = 0; ied < ocdVec[next].getNed(); ++ied) {
	  FOR_I2 {
	    const int ifa = ocdVec[next].getFaoed(ied,i);
	    if (ifa <= -ORPHAN_FACE_OFFSET) {
	      // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	      // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	      // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	      // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	      assert((-ifa-ORPHAN_FACE_OFFSET >= 0)&&(-ifa-ORPHAN_FACE_OFFSET < ocdVec[next].getNfa()));
	      const pair<int,int> rbiHash = pair<int,int>(ocdVec[next].getRankBitsForFace(-ifa-ORPHAN_FACE_OFFSET),ocdVec[next].getIndexForFace(-ifa-ORPHAN_FACE_OFFSET));
	      if (cycle == 0) {
		internalFaceSet.insert(rbiHash);
	      }
	      else {
		map<const pair<int,int>,int>::iterator iter = internalFaceMap.find(rbiHash);
		if (iter == internalFaceMap.end()) {
		  //cout << "XXXXXXXXXXXXXXXXXX Warning: new internal face introduced by orphan chunk XXXXXXXXXXXXXXXXXXX" << endl;
		  internalFaceMap[rbiHash] = ifdVec.size();
		  ifdVec.push_back(InternalFaceData(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i))));
		}
		else {
		  const int ifd = iter->second;
		  const double * const x1 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
		  const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
		  if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		    const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		    const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		    vol_cv[ip] += this_vol;
		    ifdVec[ifd].area += this_vol;
		    FOR_J3 {
		      const double tmp = this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]); 
		      ifdVec[ifd].xc[j] += tmp;
		      x_cv[ip][j] += tmp;
		      ifdVec[ifd].normal[j] += this_n[j];
		    }
		  }
		  else {
		    // face loop should be 1-directional...
		    assert(ifdVec[ifd].x0 == x2);
		  }
		}
	      }
	    }
	  }
	}
	next = ocdVec[next].next; 
      }

      if (cycle == 0) {
	
	// use the set to count how many there are... 

	faocv_i[ip+1] = faocv_i[ip] + internalFaceSet.size();
	
	for (set<pair<int,int> >::const_iterator iter = internalFaceSet.begin(); iter != internalFaceSet.end(); ++iter) {
	  int rank,bits;
	  BitUtils::unpackRankBitsNew(rank,bits,iter->first);
	  const int index = iter->second;
	  assert(bits == 0);
	  if ((rank == mpi_rank)&&(bits == 0)) {
	    assert(index != ip);
	    if (index > ip) // only count a new internal face when its index (i.e. ip_nbr) > ip
	      ++nfa_i;
	  }
	  else {
	    assert(bits == 0); // could count periodic faces separately here
	    ++nfa;
	  }
	}
	
	internalFaceSet.clear();

      }
      else {
	
	int foc = faocv_i[ip];
	for (map<const pair<int,int>,int>::const_iterator iter = internalFaceMap.begin(); iter != internalFaceMap.end(); ++iter) {
	  int rank,bits;
	  BitUtils::unpackRankBitsNew(rank,bits,iter->first.first);
	  const int index = iter->first.second;
	  const int ifd = iter->second;
	  if ((rank == mpi_rank)&&(bits == 0)) {
	    assert(index != ip);
	    if (index > ip) {
	      // create a new face...
	      const int ifa = nfa_i++;
	      // set cvofa...
	      assert(cvofa[ifa][0] == -1);
	      cvofa[ifa][0] = ip;
	      assert(cvofa[ifa][1] == -1);
	      cvofa[ifa][1] = index;
	      // faocv_v...
	      assert(faocv_v[foc] == -1);
	      faocv_v[foc++] = ifa;
	      // set geometry...
	      FOR_I3 fa[ifa].unit_n[i] = 0.5*ifdVec[ifd].normal[i]; // ifdVec[ifd].normal is actually twice the normal
	      assert(fa[ifa].area == 0.0); // leave area-weighted normal for now
	      FOR_I3 fa[ifa].x[i] = ifdVec[ifd].xc[i]/(3.0*ifdVec[ifd].area) + points->xp[ip][i];
	      // and touch the flag...
	      assert(fa_flag[ifa] == 0);
	      fa_flag[ifa] = 1;
	    }
	    else {
	      // this face already lives with a previous cv...
	      int ifa = -1;
	      int foc_nbr;
	      for (foc_nbr = faocv_i[index]; foc_nbr != faocv_i[index+1]; ++foc_nbr) {
		ifa = faocv_v[foc_nbr]; assert(ifa >= 0);
		if (cvofa[ifa][0] == index) {
		  if (cvofa[ifa][1] == ip) {
		    // got the match...
		    break;
		  }
		}
		else {
		  assert(cvofa[ifa][1] == index);
		  // cannot be this one...
		}
	      }
	      // ensure we broke out above - if we did not find one, then 
	      // there is a face match problem...
	      assert(foc_nbr != faocv_i[index+1]);
	      assert(ifa != -1);
	      // touch the flag...
	      assert(fa_flag[ifa] == 1);
	      fa_flag[ifa] = 2;
	      // add the face to faocv_v...
	      faocv_v[foc++] = ifa;
	      // average the geometry...
	      const double this_dn[3] = { 
		fa[ifa].unit_n[0] + 0.5*ifdVec[ifd].normal[0],
		fa[ifa].unit_n[1] + 0.5*ifdVec[ifd].normal[1],
		fa[ifa].unit_n[2] + 0.5*ifdVec[ifd].normal[2] };
	      my_buf[0] = max(my_buf[0],DOT_PRODUCT(this_dn,this_dn)); // no nomalization?
	      FOR_I3 fa[ifa].unit_n[i] = 0.5*( fa[ifa].unit_n[i] - 0.5*ifdVec[ifd].normal[i] );
	      // and the distance...
	      double this_x_fa[3]; FOR_I3 this_x_fa[i] = ifdVec[ifd].xc[i]/(3.0*ifdVec[ifd].area) + points->xp[ip][i];
	      my_buf[1] = max(my_buf[1],DIST2(this_x_fa,fa[ifa].x));
	      FOR_I3 fa[ifa].x[i] = 0.5*(fa[ifa].x[i]+this_x_fa[i]);
	    }
	  }
	  else {
	    assert(bits == 0); // could count periodic faces separately here
	    assert(rank != mpi_rank); // for now
	    send_count[rank] += 3; // ip, rank-bits_nbr, index_nbr...  
	    const int ifa = nfa++;
	    // set cvofa...
	    assert(cvofa[ifa][0] == -1);
	    cvofa[ifa][0] = ip;
	    assert(cvofa[ifa][1] == -1);
	    // look for a ghost cv...
	    const uint8 rbiHash = BitUtils::packRankBitsIndex(rank,bits,index);
	    map<const uint8,int>::const_iterator iter = rbiMap.find(rbiHash);
	    if (iter == rbiMap.end()) {
	      rbiMap[rbiHash] = cvofa[ifa][1] = ncv_g++;
	    }
	    else {
	      cvofa[ifa][1] = iter->second;
	    }
	    // faocv_v...
	    assert(faocv_v[foc] == -1);
	    faocv_v[foc++] = ifa;
	    // set geometry - we will average out of this loop...
	    FOR_I3 fa[ifa].unit_n[i] = 0.5*ifdVec[ifd].normal[i];
	    assert(fa[ifa].area == 0.0); // leave area-weighted normal for now
	    FOR_I3 fa[ifa].x[i] = ifdVec[ifd].xc[i]/(3.0*ifdVec[ifd].area) + points->xp[ip][i];
	    // and touch the flag...
	    assert(fa_flag[ifa] == 0);
	    fa_flag[ifa] = 1;
	  }
	}
	assert(foc == faocv_i[ip+1]);

	// and clear...

	ifdVec.clear();
	internalFaceMap.clear();
	
      }
    
    } // for ip

    // ===============================================
    // memory allocation
    // ===============================================

    if (cycle == 0) {
      
      assert(faocv_v == NULL);
      const int faocv_s = faocv_i[ncv];
      if (!(faocv_s == 2*nfa_i + nfa))
	cout << "rank: " << mpi_rank << " faocv_s: " << faocv_s << " 2*nfa_i + nfa: " << 2*nfa_i + nfa << endl;
      assert(faocv_s == 2*nfa_i + nfa);
      faocv_v = new int[faocv_s];
      for (int foc = 0; foc < faocv_s; ++foc)
	faocv_v[foc] = -1;
      
      // the local number of faces will be nfa_i+nfa...
      
      nfa += nfa_i;
      assert(fa == NULL); fa = new FaBase[nfa];
      assert(cvofa == NULL); cvofa = new int[nfa][2];
      for (int ifa = 0; ifa < nfa; ++ifa)
	cvofa[ifa][0] = cvofa[ifa][1] = -1;

      // and the flags are used for counting...
      assert(fa_flag == NULL); fa_flag = new int[nfa];
      for (int ifa = 0; ifa < nfa; ++ifa)
	fa_flag[ifa] = 0;

      // reduce global face count for checking... 
      
      int8 my_nfa2_global = nfa + nfa_i; // add nfa_i again. This means all faces are double-counted.
      int8 nfa2_global;
      MPI_Reduce(&my_nfa2_global,&nfa2_global,1,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
	assert(nfa2_global%2 == 0); // should be even
	cout << " > nfa_global: " << nfa2_global/2 << endl; // divide by zero
      }
      
    }
    
  }
  
  // check it was all set as expected so far...
  
  for (int foc = 0; foc < faocv_i[ncv]; ++foc)
    assert(faocv_v[foc] >= 0);
  
  for (int ifa = 0; ifa < nfa_i; ++ifa) {
    assert((cvofa[ifa][0] >= 0)&&(cvofa[ifa][0] < ncv));
    assert((cvofa[ifa][1] >= 0)&&(cvofa[ifa][1] < ncv));
    assert(fa_flag[ifa] == 2);
  }

  // the second range of faces we check and pack at the same time below... 

  // reorder ghost data in rank/bits/index order...

  assert(rbiMap.size() == ncv_g-ncv);
  int * cv_flag_g = new int[ncv_g-ncv];
  uint8 * rbi_g = new uint8[ncv_g-ncv];
  int ig = 0;
  for (map<const uint8,int>::const_iterator iter = rbiMap.begin(); iter != rbiMap.end(); ++iter) {
    rbi_g[ig] = iter->first;
    cv_flag_g[iter->second-ncv] = ig++;
  }
  rbiMap.clear();
  
  // inter-processor faces...

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  assert((nfa-nfa_i)*3 == send_disp[mpi_size-1] + send_count[mpi_size-1]);
  
  int * send_buf_int = new int[(nfa-nfa_i)*3];
  double * send_buf_double = new double[(nfa-nfa_i)*6];

  for (int ifa = nfa_i; ifa < nfa; ++ifa) {
    assert((cvofa[ifa][0] >= 0)&&(cvofa[ifa][0] < ncv));
    assert((cvofa[ifa][1] >= ncv)&&(cvofa[ifa][1] < ncv_g));
    assert(fa_flag[ifa] == 1); // touched once so far
    const int icv_old = cvofa[ifa][1];
    cvofa[ifa][1] = ncv + cv_flag_g[icv_old-ncv];
    assert((cvofa[ifa][1] >= ncv)&&(cvofa[ifa][1] < ncv_g));
    // pack this face...
    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[cvofa[ifa][1]-ncv]);
    assert(rank != mpi_rank);
    assert(bits == 0);
    const int inverse_bits = 0;
    send_buf_int[send_disp[rank]]   = index;
    send_buf_int[send_disp[rank]+1] = BitUtils::packRankBitsNew(mpi_rank,inverse_bits);
    send_buf_int[send_disp[rank]+2] = cvofa[ifa][0];
    FOR_I3 send_buf_double[send_disp[rank]*2+i] = fa[ifa].unit_n[i]; // not a unit vector yet
    FOR_I3 send_buf_double[send_disp[rank]*2+3+i] = fa[ifa].x[i];
    send_disp[rank] += 3;
  }
  delete[] cv_flag_g; 
  
  // reset send_disp...
  
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
  
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
	
  int * recv_buf_int = new int[recv_count_sum];
  MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
  delete[] send_buf_int;   
  
  FOR_RANK {
    send_count[rank] *= 2;
    send_disp[rank] *= 2;
    recv_count[rank] *= 2;
    recv_disp[rank] *= 2;
  }

  double * recv_buf_double = new double[recv_count_sum*2];
  MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  delete[] send_buf_double;   
  
  for (int irecv = 0; irecv < recv_count_sum; irecv += 3) {
    const int icv = recv_buf_int[irecv];
    assert((icv >= 0)&&(icv < ncv));
    int rank,bits;
    BitUtils::unpackRankBitsNew(rank,bits,recv_buf_int[irecv+1]);
    int index = recv_buf_int[irecv+2];
    const uint8 rbiHash = BitUtils::packRankBitsIndex(rank,bits,index);
    int ifa = -1;
    int foc;
    for (foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
      ifa = faocv_v[foc];
      if (cvofa[ifa][1] >= ncv) {
	assert(ifa >= nfa_i);
	if (rbi_g[cvofa[ifa][1]-ncv] == rbiHash)
	  break;
      }
    }
    assert(foc != faocv_i[icv+1]);
    assert(ifa != -1);
    assert(fa_flag[ifa] == 1);
    fa_flag[ifa] = 2;
    // the normal is in the first part of the recv_buf_double...
    double this_dn[3] = { 
      fa[ifa].unit_n[0] + recv_buf_double[irecv*2  ],
      fa[ifa].unit_n[1] + recv_buf_double[irecv*2+1],
      fa[ifa].unit_n[2] + recv_buf_double[irecv*2+2] };
    my_buf[0] = max(my_buf[0],DOT_PRODUCT(this_dn,this_dn));
    FOR_I3 fa[ifa].unit_n[i] = 0.5*( fa[ifa].unit_n[i] - recv_buf_double[irecv*2+i] );
    // and the distance...
    double this_x_fa[3]; FOR_I3 this_x_fa[i] = recv_buf_double[irecv*2+3+i];
    my_buf[1] = max(my_buf[1],DIST2(this_x_fa,fa[ifa].x));
    FOR_I3 fa[ifa].x[i] = 0.5*(fa[ifa].x[i]+this_x_fa[i]);
  }
  delete[] recv_buf_int;
  delete[] recv_buf_double;

  // confirm inter-processor faces have been visited twice...

  for (int ifa = nfa_i; ifa < nfa; ++ifa) {
    assert(fa_flag[ifa] == 2);
  }
  
  // reduce/report the tol data...
  
  double buf[2];
  MPI_Reduce(my_buf,buf,2,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
  if (mpi_rank == 0)
    cout << " > internal face area mismatch: " << sqrt(buf[0]) << ", internal face centroid mismatch: " << sqrt(buf[1]) << endl;
  
  // ================================================
  // ================================================
  // ================================================
  // ================================================
  // now boundary faces...
  // ================================================
  // ================================================
  // ================================================
  // ================================================

  vector<double> bfDoubleVec;
  vector<int> bfIntVec;
  assert(bfocv_i == NULL); bfocv_i = new int[ncv+1];
  
  map<const int,int> boundaryFaceMap;
  set<pair<int,int> > stLinkSet; // surface tri link
  
  bfocv_i[0] = 0;
  for (int ip = 0; ip < points->np; ++ip) {
    if (vdArray[ip].checkStatusBits(VD_HAS_BOUNDARY_BIT)) {
      
      assert(ifdVec.empty());
      assert(boundaryFaceMap.empty());
      assert(stLinkSet.empty());

      for (int ied = 0; ied < vdArray[ip].getNedMain(); ++ied) {
	
	// stLinkSet first...

	if ((vdArray[ip].getFaoed(ied,0) >= 0)&&(vdArray[ip].getFaoed(ied,1) >= 0)) {
	  const int ist0 = vdArray[ip].getFaoed(ied,0);
	  const int ist1 = vdArray[ip].getFaoed(ied,1);
	  assert(ist0 != ist1);
	  const int izone0 = surface->getZnost(ist0); assert(izone0 >= 0);
	  const int izone1 = surface->getZnost(ist1); assert(izone1 >= 0);
	  if (izone0 == izone1) {
	    if (surface->checkCoplanar(ist0,ist1,boundary_face_crease_angle)) {
	      stLinkSet.insert(pair<int,int>(min(ist0,ist1),max(ist0,ist1)));
	    }
	  }
	}
	
	// now just loop on edges...

	FOR_I2 {
	  const int ifa = vdArray[ip].getFaoed(ied,i);
	  // consider boundary faces only at this point...
	  if (ifa >= 0) {
	    map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	    if (iter == boundaryFaceMap.end()) {
	      boundaryFaceMap[ifa] = ifdVec.size();
	      ifdVec.push_back(InternalFaceData(vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i))));
	    }
	    else {
	      const int ifd = iter->second;
	      const double * const x1 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,i));
	      const double * const x2 = vdArray[ip].getXnoPtr(vdArray[ip].getNooed(ied,1-i)); 
	      if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		const double this_area = MAG(this_n);
		const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		ifdVec[ifd].area += this_area;
		vol_cv[ip] += this_vol;
		FOR_J3 {
		  ifdVec[ifd].xc[j] += this_area*(ifdVec[ifd].x0[j]+x1[j]+x2[j]);
		  x_cv[ip][j] += this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]);
		  ifdVec[ifd].normal[j] += this_n[j];
		}
	      }
	      else {
		// face loop should be 1-directional...
		assert(ifdVec[ifd].x0 == x2);
	      }
	    }
	  }
	}
      }
      
      // any orphan chunks?...
      
      int next = vdArray[ip].orphan_chunk_data; // -1 or the index in the ocdVec of our first orphan chunk
      while (next != -1) {
	// edge loop on ocdVec[next]...
	for (int ied = 0; ied < ocdVec[next].getNed(); ++ied) {
	  
	  // stLinkSet first...

	  if ((ocdVec[next].getFaoed(ied,0) >= 0)&&(ocdVec[next].getFaoed(ied,1) >= 0)) {
	    const int ist0 = ocdVec[next].getFaoed(ied,0);
	    const int ist1 = ocdVec[next].getFaoed(ied,1);
	    assert(ist0 != ist1);
	    const int izone0 = surface->getZnost(ist0); assert(izone0 >= 0);
	    const int izone1 = surface->getZnost(ist1); assert(izone1 >= 0);
	    if (izone0 == izone1) {
	      if (surface->checkCoplanar(ist0,ist1,boundary_face_crease_angle)) {
		stLinkSet.insert(pair<int,int>(min(ist0,ist1),max(ist0,ist1)));
	      }
	    }
	  }

	  // then face geometry...
	  
	  FOR_I2 {
	    const int ifa = ocdVec[next].getFaoed(ied,i);
	    if (ifa >= 0) {
	      // note that the first -ve faces (up to but not including -ORPHAN_FACE_OFFSET) should be open faces in the opposite 
	      // direction as the skipped group_nbr != 0 faces in the main above, or perhaps open faces on other orphans. For 
	      // some pathological cases (Cartesian?), some of the open orphan faces may not be matched by other open faces. We
	      // should detect this in an earlier phase if this is an issue. It should be evident in the final GCL.
	      map<const int,int>::iterator iter = boundaryFaceMap.find(ifa);
	      if (iter == boundaryFaceMap.end()) {
		boundaryFaceMap[ifa] = ifdVec.size();
		ifdVec.push_back(InternalFaceData(ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i))));
	      }
	      else {
		const int ifd = iter->second;
		const double * const x1 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,i));
		const double * const x2 = ocdVec[next].getXnoPtr(ocdVec[next].getNooed(ied,1-i));
		if ((ifdVec[ifd].x0 != x1)&&(ifdVec[ifd].x0 != x2)) {
		  const double this_n[3] = TRI_NORMAL_2(ifdVec[ifd].x0,x1,x2);
		  const double this_area = MAG(this_n);
		  const double this_vol = DOT_PRODUCT(ifdVec[ifd].x0,this_n);
		  ifdVec[ifd].area += this_area;
		  vol_cv[ip] += this_vol;
		  FOR_J3 {
		    ifdVec[ifd].xc[j] += this_area*(ifdVec[ifd].x0[j]+x1[j]+x2[j]); 
		    x_cv[ip][j] += this_vol*(ifdVec[ifd].x0[j]+x1[j]+x2[j]); 
		    ifdVec[ifd].normal[j] += this_n[j];
		  }
		}
		else {
		  // face loop should be 1-directional...
		  assert(ifdVec[ifd].x0 == x2);
		}
	      }
	    }
	  }
	}
	next = ocdVec[next].next; 
      }

      // at this point, the boundaryFaceMap links to the surface tris. Now combine surface tris to 
      // form the final set of boundary faces. In the future we can return here and build more 
      // boundary face data if required, or build the set of tris associated with each boundary face...
      
      assert(!boundaryFaceMap.empty());
      assert(boundaryFaceMap.size() == ifdVec.size());
      const int nbf_full = boundaryFaceMap.size(); 
      int * bf_flag = new int[nbf_full];
      for (int ibf = 0; ibf < nbf_full; ++ibf)
	bf_flag[ibf] = ibf;
      
      // now use stLinkSet to combine faces...
      
      for (set<pair<int,int> >::const_iterator iter = stLinkSet.begin(); iter != stLinkSet.end(); ++iter) {
	// find the bf indices associated with these faces...
	map<const int,int>::const_iterator iter0 = boundaryFaceMap.find(iter->first);
	assert(iter0 != boundaryFaceMap.end());
	map<const int,int>::const_iterator iter1 = boundaryFaceMap.find(iter->second);
	assert(iter1 != boundaryFaceMap.end());
	int ibf0 = iter0->second; assert((ibf0 >= 0)&&(ibf0 < nbf_full));
	while(bf_flag[ibf0] != ibf0)
	  ibf0 = bf_flag[ibf0];
	int ibf1 = iter1->second; assert((ibf1 >= 0)&&(ibf1 < nbf_full));
	while(bf_flag[ibf1] != ibf1)
	  ibf1 = bf_flag[ibf1];
	bf_flag[ibf0] = bf_flag[ibf1] = min(ibf0,ibf1);
      }
      stLinkSet.clear();
      
      // now count the final boundaries...
      int nbf = 0;
      for (int ibf = 0; ibf < nbf_full; ++ibf) {
	if (bf_flag[ibf] == ibf) {
	  ++nbf;
	  bf_flag[ibf] = -nbf;
	}
	else {
	  int ibf_ = bf_flag[ibf];
	  while (ibf_ >= 0)
	    ibf_ = bf_flag[ibf_];
	  bf_flag[ibf] = ibf_;
	}
      }
      
      // bf_flag should now contain the final ibf in -1 indexing...

      assert(nbf >= 1);
      int ibf_offset = bfIntVec.size();
      bfIntVec.resize(ibf_offset+nbf);
      assert(bfDoubleVec.size() == ibf_offset*6);
      bfDoubleVec.resize((ibf_offset+nbf)*6);
      double * bf_area = new double[nbf];
      for (int ibf = 0; ibf < nbf; ++ibf) {
	bfIntVec[ibf_offset+ibf] = -1;
	FOR_I6 bfDoubleVec[(ibf_offset+ibf)*6+i] = 0.0;
	bf_area[ibf] = 0.0;
      }

      // condense the boundary face stuff...
      
      for (int ibf_full = 0; ibf_full < nbf_full; ++ibf_full) {
	const int ibf = -bf_flag[ibf_full]-1;
	assert((ibf >= 0)&&(ibf < nbf));
	FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+i] += ifdVec[ibf_full].normal[i];
	FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+3+i] += ifdVec[ibf_full].xc[i];
	bf_area[ibf] += ifdVec[ibf_full].area;
      }

      // and set the zone...

      for (map<const int,int>::const_iterator iter = boundaryFaceMap.begin(); iter != boundaryFaceMap.end(); ++iter) {
	const int ist = iter->first;
	const int ibf_full = iter->second; assert((ibf_full >= 0)&&(ibf_full < nbf_full));
	const int ibf = -bf_flag[ibf_full]-1;
	const int izone = surface->getZnost(ist); assert(izone >= 0);
	if (bfIntVec[ibf_offset+ibf] == -1)
	  bfIntVec[ibf_offset+ibf] = izone;
	else {
	  assert(bfIntVec[ibf_offset+ibf] == izone);
	}
      }

      // and normalize the data. Remove any zeros...
      
      for (int ibf = 0; ibf < nbf; ++ibf) {
	assert(bfIntVec[ibf_offset+ibf] >= 0);
	FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+i] *= 0.5;
	assert(bf_area[ibf] > 0.0);
	FOR_I3 bfDoubleVec[(ibf_offset+ibf)*6+3+i] = bfDoubleVec[(ibf_offset+ibf)*6+3+i]/(3.0*bf_area[ibf]) + points->xp[ip][i];
      }
      
      delete[] bf_flag;
      delete[] bf_area;
      
      /*
      {
	FILE * fp = fopen("bf.dat","w");
	for (int ibf = 0; ibf < nbf; ++ibf) {
	  fprintf(fp,"%18.15le %18.15le %18.15le\n",
		  bfDoubleVec[(ibf_offset+ibf)*6+3+0],
		  bfDoubleVec[(ibf_offset+ibf)*6+3+1],
		  bfDoubleVec[(ibf_offset+ibf)*6+3+2]);
	}
	fclose(fp);
	double x0[3] = { 0.0, 0.0, 0.0 };
	writeFullCvTecplot(0,x0);
	getchar();
      }
      */

      // cleanup...
      
      boundaryFaceMap.clear();
      ifdVec.clear();
      
    }
    
    // set the bfocv_i...
    bfocv_i[ip+1] = bfIntVec.size();
  
    // =======================================================================
    // use this ip loop to also adjust centroid and volume...
    // =======================================================================
	
    assert(vol_cv[ip] > 0.0);
    FOR_I3 x_cv[ip][i] /= 4.0*vol_cv[ip];
    vol_cv[ip] /= 6.0;

  } // for (int ip...
  
  // report the volume...
  
  double my_vol_sum = 0.0;
  FOR_ICV my_vol_sum += vol_cv[icv];
  double vol_sum;
  MPI_Reduce(&my_vol_sum,&vol_sum,1,MPI_DOUBLE,MPI_SUM,0,mpi_comm);
  if (mpi_rank == 0)
    cout << " > Voronoi volume: " << vol_sum << endl;

  // finally the boundary faces...

  int * zone_count = new int[surface->zoneVec.size()];
  for (int izone = 0; izone < surface->zoneVec.size(); ++izone)
    zone_count[izone] = 0;
  
  for (int ii = 0; ii < bfIntVec.size(); ++ii) {
    const int izone = bfIntVec[ii];
    assert((izone >= 0)&&(izone < surface->zoneVec.size()));
    ++zone_count[izone];
  }
  
  // temporarily use zone_disp to hold the global ibf count. Here we use just an 
  // int. Hopefully no zone has more than 2B faces, right ;)
  
  int * zone_disp = new int[surface->zoneVec.size()];
  MPI_Allreduce(zone_count,zone_disp,surface->zoneVec.size(),MPI_INT,MPI_SUM,mpi_comm);
  
  assert(bfZoneVec.empty());
  nbf = 0;
  for (int izone = 0; izone < surface->zoneVec.size(); ++izone) {
    // if ANYONE has this zone, we ALL get this zone, even if our local ibf count is empty...
    if (zone_disp[izone] > 0) {
      bfZoneVec.push_back(BfZone(surface->zoneVec[izone].getName(),nbf,nbf+zone_count[izone]));
      nbf += zone_count[izone];
    }
  }
  assert(nbf == bfIntVec.size());
  
  // switch zone_disp to a disp...
  zone_disp[0] = 0;
  for (int izone = 1; izone < surface->zoneVec.size(); ++izone)
    zone_disp[izone] = zone_disp[izone-1] + zone_count[izone-1];
  assert(zone_disp[surface->zoneVec.size()-1] + zone_count[surface->zoneVec.size()-1] == bfIntVec.size());
  
  // and now allocate and populate the boundary face data structure...
  
  assert(bf == NULL); bf = new BfBase[nbf];
  assert(bfocv_v == NULL); bfocv_v = new int[nbf];
  
  for (int ibf = 0; ibf < bfIntVec.size(); ++ibf) {
    const int izone = bfIntVec[ibf];
    const int ibf_new = zone_disp[izone]++;
    // store the new index in bfocv_v...
    bfocv_v[ibf] = ibf_new;
    // and set the bf data...
    FOR_I3 bf[ibf_new].unit_n[i] = bfDoubleVec[ibf*6+i]; // still area-weighted
    assert(bf[ibf_new].area == 0.0);
    FOR_I3 bf[ibf_new].x[i] = bfDoubleVec[ibf*6+3+i];
  }
  
  assert(cvobf == NULL); cvobf = new int[nbf];
  for (int ibf = 0; ibf < nbf; ++ibf)
    cvobf[ibf] = -1;
  
  for (int icv = 0; icv < ncv; ++icv) {
    for (int boc = bfocv_i[icv]; boc != bfocv_i[icv+1]; ++boc) {
      const int ibf = bfocv_v[boc];
      assert(cvobf[ibf] == -1);
      cvobf[ibf] = icv;
    }
  }
  
  for (int ibf = 0; ibf < nbf; ++ibf)
    assert(cvobf[ibf] >= 0);
  
  delete[] zone_count;
  delete[] zone_disp;
  
  // cleanup...
  
  delete[] rbi_g;

  // check the volume/divergence relationship...
  
  double (*gcl)[3] = new double[ncv][3];
  double my_vd_max = 0.0;
  double my_gcl_max = 0.0;
  for (int icv = 0; icv < ncv; ++icv) {
    double vtest = 0.0;
    FOR_I3 gcl[icv][i] = 0.0;
    // internal faces first....
    for (int foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
      const int ifa = faocv_v[foc];
      if (cvofa[ifa][0] == icv) {
	// outward-pointing face...
	vtest += DOT_PRODUCT(fa[ifa].unit_n,fa[ifa].x); // recall face normal is not unit yet
	FOR_I3 gcl[icv][i] += fa[ifa].unit_n[i];
      }
      else {
	// inward-pointing face...
	assert(cvofa[ifa][1] == icv);
	vtest -= DOT_PRODUCT(fa[ifa].unit_n,fa[ifa].x);
	FOR_I3 gcl[icv][i] -= fa[ifa].unit_n[i];
      }
    }
    // all boundaries are outward-pointing...
    for (int boc = bfocv_i[icv]; boc != bfocv_i[icv+1]; ++boc) {
      const int ibf = bfocv_v[boc];
      vtest += DOT_PRODUCT(bf[ibf].unit_n,bf[ibf].x); // once again, normal is not unit yet
      FOR_I3 gcl[icv][i] += bf[ibf].unit_n[i];
    }
    my_vd_max = max(my_vd_max,fabs((vtest-3.0*vol_cv[icv])/vol_cv[icv]));
  }
  double vd_max;
  MPI_Reduce(&my_vd_max,&vd_max,1,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
  if (mpi_rank == 0)
    cout << " > volume/divergence test (should be small): " << vd_max << endl;
  
  dumpRange(gcl,ncv,"GCL (should be small)");
  delete[] gcl;

  MPI_Pause("HOW WAS THAT?");
  
}

#endif




/*
  void mkdir_collective(const string& fulldir) {
  
  // should only call this from one rank...
  
  if (mpi_rank == 0) {
    
  string dir;
  int err = 0;
  size_t pos_ = 0;
  for (int i=0,n=std::count(fulldir.begin(),fulldir.end(),'/'); i < n; ++i) {
  size_t pos = fulldir.find('/',pos_);
  pos_ = pos+1;
  dir = fulldir.substr(0,pos);
  if (pos != 0) err = mkdir(dir.c_str(),0777);
  }
    
  // it is possible that the passed directory did not terminate in a slash...
  if (pos_ < fulldir.length())
  err = mkdir(fulldir.c_str(),0777);
    
  if ((err != 0) && (errno != EEXIST))
  cout << "Warning: unable to create directory: " << fulldir << endl;
    
  }
  MPI_Barrier(mpi_comm);
  
  }
*/





	cout << "nnbr: " << internalFaceSet.size() << endl;
	FILE * fp = fopen("nbr.dat","w");
	fprintf(fp,"%18.15le %18.15le %18.15le\n",points->xp[ip][0],points->xp[ip][1],points->xp[ip][2]);
	
	  &&() {
	    
	  assert(rank == mpi_rank);
	  assert(index != ip);
	  fprintf(fp,"%18.15le %18.15le %18.15le\n",points->xp[index][0],points->xp[index][1],points->xp[index][2]);
	}

	fclose(fp);







  MPI_Pause("send_count and recv_count match!");
  return;

  assert(0);

#ifdef JUNKJUNK

	
  for (int ifa = 0; ifa < vdArray[ip].nfa; ++ifa) {
    r2_fa[ifa] = 0.0;
    n_fa[ifa][0] = 0.0;
    n_fa[ifa][1] = 0.0;
    n_fa[ifa][2] = 0.0;
    ino0_fa[ifa] = -1; // some node of the face required to build the normal
  }
  // now loop through edges and update r2_fa, n_fa...
  for (int ied = 0; ied < vdArray[ip].ned; ++ied) {
    FOR_I2 {
      if (vdArray[ip].nofaoed[ied][2+i] < 0) {
	// an internal face uses a negative indexing convention. Positive
	// values here would refer to a surface tri (not considered yet)...
	const int ifa = -vdArray[ip].nofaoed[ied][2+i]-1;
	assert((ifa >= 0)&&(ifa < vdArray[ip].nfa));
	FOR_J2 {
	  const int ino = vdArray[ip].nofaoed[ied][j];
	  r2_fa[ifa] = max(r2_fa[ifa],DOT_PRODUCT(vdArray[ip].x_no[ino],vdArray[ip].x_no[ino]));
	}
	if (ino0_fa[ifa] == -1) {
	  ino0_fa[ifa] = vdArray[ip].nofaoed[ied][0];
	}
	else if ((ino0_fa[ifa] != vdArray[ip].nofaoed[ied][0])&&(ino0_fa[ifa] != vdArray[ip].nofaoed[ied][1])) {
	  // note order of these nodes depends on "i", i.e. which side of the edge...
	  const int ino0 = vdArray[ip].nofaoed[ied][i];
	  const int ino1 = vdArray[ip].nofaoed[ied][1-i];
	  assert(ino0 != ino1);
	  const double this_n[3] = TRI_NORMAL_2(vdArray[ip].x_no[ino0_fa[ifa]],vdArray[ip].x_no[ino0],vdArray[ip].x_no[ino1]);
	  n_fa[ifa][0] += 0.5*this_n[0];
	  n_fa[ifa][1] += 0.5*this_n[1];
	  n_fa[ifa][2] += 0.5*this_n[2];
	}
      }
    }
  }
  // and perform matching...
  for (int ifa = 0; ifa < vdArray[ip].nfa; ++ifa) {
    assert(r2_fa[ifa] <= 0.25*points->delta[ip]*points->delta[ip]); // check r2_fa makes sense...
    // also, there should be no local bits set yet. That is what we are about to do...
    assert(!(vdArray[ip].grbisofa[ifa][2] & (ZERO_LOCAL_FACE_BIT|NEAR_ZERO_LOCAL_FACE_BIT|VALID_LOCAL_FACE_BIT)));
    area2_fa[ifa] = DOT_PRODUCT(n_fa[ifa],n_fa[ifa]);
    // ==========================================
    // set the *_LOCAL_FACE_BIT stuff...
    // ==========================================
    const double area2_ratio = area2_fa[ifa]/(r2_fa[ifa]*r2_fa[ifa]);
    int local_status;
    if (area2_ratio < area2_ratio_zero) {
      vdArray[ip].grbisofa[ifa][2] |= ZERO_LOCAL_FACE_BIT;
      // confirm that either the *_NBR_FACE_BIT has not been set, or they are set consistent with this local bit...
      assert( (!(vdArray[ip].grbisofa[ifa][2] & (NO_NBR_FACE_BIT|ZERO_NBR_FACE_BIT|NEAR_ZERO_NBR_FACE_BIT|VALID_NBR_FACE_BIT))) ||
	      (vdArray[ip].grbisofa[ifa][2] & (NO_NBR_FACE_BIT|ZERO_NBR_FACE_BIT|NEAR_ZERO_NBR_FACE_BIT)) );
      local_status = ZERO_FACE;
    }
    else if (area2_ratio < 2.0*area2_ratio_zero) {
      vdArray[ip].grbisofa[ifa][2] |= NEAR_ZERO_LOCAL_FACE_BIT;
      // confirm that either the *_NBR_FACE_BIT has not been set, or they are set consistent with this local bit...
      assert( (!(vdArray[ip].grbisofa[ifa][2] & (NO_NBR_FACE_BIT|ZERO_NBR_FACE_BIT|NEAR_ZERO_NBR_FACE_BIT|VALID_NBR_FACE_BIT))) ||
	      (vdArray[ip].grbisofa[ifa][2] & (ZERO_NBR_FACE_BIT|NEAR_ZERO_NBR_FACE_BIT|VALID_NBR_FACE_BIT)) );
      local_status = NEAR_ZERO_FACE;
    }
    else {
      vdArray[ip].grbisofa[ifa][2] |= VALID_LOCAL_FACE_BIT;
      // confirm that either the *_NBR_FACE_BIT has not been set, or they are set consistent with this local bit...
      assert( (!(vdArray[ip].grbisofa[ifa][2] & (NO_NBR_FACE_BIT|ZERO_NBR_FACE_BIT|NEAR_ZERO_NBR_FACE_BIT|VALID_NBR_FACE_BIT))) ||
	      (vdArray[ip].grbisofa[ifa][2] & (NEAR_ZERO_NBR_FACE_BIT|VALID_NBR_FACE_BIT)) );
      local_status = VALID_FACE;
    }
    // ==========================================
    // and then match to the nbr face...
    // ==========================================
    // the rank/bits/index for this nbr is...
    int group,rank,bits,index;
    vdArray[ip].setGrbiForFace(group,rank,bits,index,ifa);
    assert(bits == 0);
    if (rank == mpi_rank) {
      // a local nbr can match and process immediately...
      assert((index >= 0)&&(index < points->np));
      const int status = matchFaceNew(index,mpi_rank,0,ip,local_status,r2_fa[ifa]);
      //if (status == 0)
      //  cout << " area2_fa[ifa]/(r2_fa[ifa]*r2_fa[ifa]): " << area2_fa[ifa]/(r2_fa[ifa]*r2_fa[ifa]) << endl;
      processStatusNew(status,ip,ifa);
    }
    else {
      send_buf_int[send_disp[rank]*4  ] = index;
      assert(bits == 0); // NOTE: combine rank and bits here in the future
      send_buf_int[send_disp[rank]*4+1] = mpi_rank;
      send_buf_int[send_disp[rank]*4+2] = ip;
      send_buf_int[send_disp[rank]*4+3] = local_status;
      send_buf_double[send_disp[rank]]  = r2_fa[ifa];
      send_disp[rank] += 1;
    }
  }
}
}

delete[] r2_fa;
delete[] n_fa;
delete[] ino0_fa;
delete[] area2_fa;
  
}

// reset send_disp...
  
send_disp[0] = 0;
for (int rank = 1; rank < mpi_size; ++rank)
  send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

// and exchange...
  
MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
  
recv_disp[0] = 0;
for (int rank = 1; rank < mpi_size; ++rank)
  recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
  
double * recv_buf_double = new double[recv_count_sum];
MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
	      recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
delete[] send_buf_double; send_buf_double = NULL;

FOR_RANK {
  send_count[rank] *= 4;
  send_disp[rank] *= 4;
  recv_count[rank] *= 4;
  recv_disp[rank] *= 4;
}
  
int * recv_buf_int = new int[recv_count_sum*4];
MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
	      recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);

// keep send_buf_int, although it is 4x too big...
// unpack on the recv side and call matchFaceNew to set the status...
  
for (int irecv = 0; irecv < recv_count_sum; ++irecv) {
  const int ip = recv_buf_int[irecv*4  ];
  assert((ip >= 0)&&(ip < points->np));
  const int rank = recv_buf_int[irecv*4+1];
  const int bits = 0; // NOTE: pull from "rb" above when periodic data considered
  const int index = recv_buf_int[irecv*4+2];
  const int local_status_fa = recv_buf_int[irecv*4+3];
  const double this_r2_fa = recv_buf_double[irecv];
  // put the status back in recv_buf_int: stride 1...
  recv_buf_int[irecv] = matchFaceNew(ip,rank,bits,index,local_status_fa,this_r2_fa);
 }
delete[] recv_buf_double;
  
FOR_RANK {
  send_count[rank] /= 4;
  send_disp[rank] /= 4;
  recv_count[rank] /= 4;
  recv_disp[rank] /= 4;
}
  
MPI_Alltoallv(recv_buf_int,recv_count,recv_disp,MPI_INT,
	      send_buf_int,send_count,send_disp,MPI_INT,
	      mpi_comm);
delete[] recv_buf_int;

// now back on the send side, process the status...
  
for (int ip = 0; ip < points->np; ++ip) {
  if (vdArray[ip].status_bits & VD_JUST_BUILT_BIT) {
    // this must be a just new VD...
    for (int ifa = 0; ifa < vdArray[ip].nfa; ++ifa) {
      // the rank/bits/index for this nbr is...
      int group,rank,bits,index;
      vdArray[ip].setGrbiForFace(group,rank,bits,index,ifa);
      assert(bits == 0);
      if (rank != mpi_rank) {
	processStatusNew(send_buf_int[send_disp[rank]],ip,ifa);
	send_disp[rank] += 1;
      }
    }
  }
 }
delete[] send_buf_int;

#endif
  








#ifdef fshdjkhjl

  
  
    
    // reverse check of the above...
    
    if (r2_fa > 0.25*delta_nbr*delta_nbr) {
      cout << "**** REVERSE TRIGGERED REBUILD **********************: rank,ip: " << mpi_rank << " " << ip << endl;
    }
    
    /*
    if (!(fabs(r2_fa-r2_fa_nbr) < 1.0E-12*(r2_fa+r2_fa_nbr))) {
      cout << "warning: r2_fa and r2_fa_nbr differ significantly: " << max(r2_fa,r2_fa_nbr)/min(r2_fa,r2_fa_nbr) << " rank,ip: " << mpi_rank << " " << ip << " and nbr: " << rank << " " << index << endl;
      for (int ifa_ = ifa_f; ifa_ < ifa; ++ifa_) {
	if (vdArray[ip].getFaceBits(ifa_) & ZERO_LOCAL_FACE_BIT) cout << " ZERO_LOCAL_FACE_BIT " << endl;
	else if (vdArray[ip].getFaceBits(ifa_) & NEAR_ZERO_LOCAL_FACE_BIT) cout << " NEAR_ZERO_LOCAL_FACE_BIT " << endl;
	else {
	  assert(vdArray[ip].getFaceBits(ifa_) & VALID_LOCAL_FACE_BIT);
	  cout << " VALID_LOCAL_FACE_BIT " << endl;
	}
      }
    }
    */

    // if this fails, consider sending delta and doing the reverse of the above r2_fa_nbr check 
    
    // can combine this loop with the above...
    
    for (int igr = 0; igr < ngr; ++igr) {
      // check area2 and confirm the passed face is zero...
      if (ibuf_return[2*igr] == -1) {
	// this face was unmatched. It should be zero...
	if (dbuf[id+igr*4] > area2_ratio_zero*r2_fa_nbr*r2_fa_nbr) {
	  cout << "large, unmatched face area 2: " << dbuf[id+igr*4]/(r2_fa_nbr*r2_fa_nbr) << endl;
	  //assert(0);
	}
      }
    }
    
  }

#endif

  return ngr;

  /*

  if (ngr > 1) {
  cout << "got ngr = " << ngr << " ifa_l-ifa_f+1: " << ifa_l-ifa_f+1 << endl;
  for (int igr = 0; igr < ngr; ++igr) {
  cout << " nbr group: " << ibuf[ii+igr] << " area2: " << dbuf[id+igr*4] << " x_fa: " << 
  dbuf[id+igr*4+1]+(xp_nbr[0]-points->xp[ip][0]) << " " << 
  dbuf[id+igr*4+2]+(xp_nbr[1]-points->xp[ip][1]) << " " << 
  dbuf[id+igr*4+3]+(xp_nbr[2]-points->xp[ip][2]) << endl; 
  }

  for (int ifa = ifa_f; ifa <= ifa_l; ++ifa) {
  vdArray[ip].setGrbiForFace(group_,rank_,bits_,index_,ifa);
  assert(rank_ == rank);
  assert(bits_ == bits);
  assert(index_ == index);
  cout << " nbr group: " << group_ << " area2: " << vdArray[ip].fa_data[ifa][1] << " x_fa: " << vdArray[ip].fa_data[ifa][2] << " " << vdArray[ip].fa_data[ifa][3] << " " << vdArray[ip].fa_data[ifa][4] << endl; 
  for (int igr = 0; igr < ngr; ++igr) {
  cout << " ---> dist to nbr group: " << ibuf[ii+igr] << " ";
  double d2 = 0;
  FOR_I3 {
  const double dx = (dbuf[id+igr*4+1+i]-vdArray[ip].fa_data[ifa][2+i])+(xp_nbr[i]-points->xp[ip][i]);
  d2 += dx*dx;
  }
  cout << d2 << endl;
  }
  }
  getchar();
  }
  
  */
  
	
	if (d2 < d2_ratio_zero*r2_fa_nbr) {
	  // we got a match! 
	  assert(ibuf_return[2*igr+1] == -1);
	  ibuf_return[2*igr+1] = packGroupIndexNew(group_,ifa); // recall we are returning status and group-face pair...
	  assert(vdArray[ip].nbrGroupFaceIsUnset(ifa));
	  vdArray[ip].setNbrGroupFace(ibuf[ii+igr],ifa);
	  // and decide how to set this ifa's nbr bits...
	  if (dbuf[id+igr*4] < area2_ratio_zero*r2_fa_nbr*r2_fa_nbr) {
	    vdArray[ip].setFaceBits(ZERO_NBR_FACE_BIT,ifa);
	    if (vdArray[ip].checkFaceBit(ZERO_LOCAL_FACE_BIT,ifa))
	      ibuf_return[2*igr] = 1;
	    else if (vdArray[ip].checkFaceBit(NEAR_ZERO_LOCAL_FACE_BIT,ifa))
	      ibuf_return[2*igr] = 2;
	    else {
	      assert(vdArray[ip].checkFaceBit(VALID_LOCAL_FACE_BIT,ifa));
	      ibuf_return[2*igr] = 3;
	    }
	  }
	  else if (dbuf[id+igr*4] < 2.0*area2_ratio_zero*r2_fa_nbr*r2_fa_nbr) {
	    vdArray[ip].setFaceBits(NEAR_ZERO_NBR_FACE_BIT,ifa);
	    if (vdArray[ip].checkFaceBit(ZERO_LOCAL_FACE_BIT,ifa))
	      ibuf_return[2*igr] = 1;
	    else if (vdArray[ip].checkFaceBit(NEAR_ZERO_LOCAL_FACE_BIT,ifa))
	      ibuf_return[2*igr] = 2;
	    else {
	      assert(vdArray[ip].checkFaceBit(VALID_LOCAL_FACE_BIT,ifa));
	      ibuf_return[2*igr] = 3;
	    }
	  }
	  else {
	    vdArray[ip].setFaceBits(VALID_NBR_FACE_BIT,ifa);
	    if (vdArray[ip].checkFaceBit(ZERO_LOCAL_FACE_BIT,ifa))
	      ibuf_return[2*igr] = 1;
	    else if (vdArray[ip].checkFaceBit(NEAR_ZERO_LOCAL_FACE_BIT,ifa))
	      ibuf_return[2*igr] = 2;
	    else {
	      assert(vdArray[ip].checkFaceBit(VALID_LOCAL_FACE_BIT,ifa));
	      ibuf_return[2*igr] = 3;
	    }
	  }
	}
      }
      // it is possible that this face did not match any group to
      // the specified tolerance. This is OK so long as it is a 
      // local ZERO face...
      if (vdArray[ip].nbrGroupFaceIsUnset(ifa)) {
	if (!(vdArray[ip].getFaceBits(ifa) & ZERO_LOCAL_FACE_BIT)) {
	  cout << "unexpected unmatched face: rank,ip: " << mpi_rank << " " << ip << " and nbr " << rank << " " << index << endl;
	  for (int igr = 0; igr < ngr; ++igr) {
	    double d2 = 0;
	    FOR_I3 {
	      const double dx = (dbuf[id+igr*4+1+i]-vdArray[ip].fa_data[ifa][2+i])+(xp_nbr[i]-points->xp[ip][i]);
	      d2 += dx*dx;
	    }
	    cout << " > compare to igr: " << igr << " out of " << ngr << " d2: " << d2 << endl;
	  }
	  //assert(0);
	}
	vdArray[ip].setFaceBits(NO_NBR_FACE_BIT,ifa);
	// nothing to return
      }
    }
    else if (ifa_f != -1)
      break; // because the faces are contiguous in rbi, we can exit...


#endif












  
#ifdef JUNJJUNJ

  

  while (irecv_int < recv_count_int_sum) {
    const int rank = recv_buf_int[irecv_int++];
    const int ip   = recv_buf_int[irecv_int++];
    const int nst  = recv_buf_int[irecv_int++];
    const int nnbr = recv_buf_int[irecv_int++];
    double xp[3];
    FOR_I3 xp[i] = recv_buf_double[irecv_double++];
    const double delta = recv_buf_double[irecv_double++];
    cvd.clear();
    nodeMap.clear();
    edgeMap.clear();
    int noost[3];
    assert(cvd.nno == 0);
    assert(cvd.ned == 0);
    for (int ii = 0; ii < nst; ++ii) {
      const int ist  = recv_buf_int[irecv_int++];
      const int bits  = recv_buf_int[irecv_int++]; assert(bits == 0);
      // everyone has access to the full surface, so grab and assemble tris directly...
      FOR_I3 {
	const int isp = surface->spost[ist][i];
	map<const int,int>::iterator iter = nodeMap.find(isp); // needs to be pbi eventually
	if (iter == nodeMap.end()) {
          const int ino = cvd.new_node();
	  nodeMap[isp] = ino;
          FOR_J3 cvd.x_no[ino][j] = surface->xp[isp][j] - xp[j];
	  noost[i] = ino;
	}
	else {
	  noost[i] = iter->second;
	}
      }
      FOR_I3 {
	const int ino0 = noost[i];
	const int ino1 = noost[(i+1)%3];
	map<const pair<int,int>,int>::iterator iter = edgeMap.find(pair<int,int>(ino1,ino0));
	if (iter == edgeMap.end()) {
          const int ied = cvd.new_edge();
          edgeMap[pair<int,int>(ino0,ino1)] = ied;
          cvd.nooed[ied][0] = ino0;
          cvd.nooed[ied][1] = ino1;
          cvd.faoed[ied][0] = ist;
          cvd.faoed[ied][1] = -1;
	}
	else {
          const int ied = iter->second;
	  edgeMap.erase(iter);	  
	  assert(cvd.faoed[ied][1] == -1);
	  cvd.faoed[ied][1] = ist;
	}
      }
    }
    // ================================================
    // now cut surface patch wrt corners...
    // this introduces new edges around the surface boundary
    // that have their faoed[ied][1] linked to a surface face,
    // and their faoed[ied][0] linked to a cut surface indicated
    // by -2,-3,-4,-5,-6,-7 for -x,+x,-y,+y,etc...
    // ================================================
    if (cvd.ned > 0) {
      // -2 == x0
      const double n[3] = { -0.505*delta, 0.0, 0.0 };
      cvd.cut_surf(n,-2);
      if (cvd.ned > 0) {
	// -3 == x1
	const double n[3] = { 0.505*delta, 0.0, 0.0 };
	cvd.cut_surf(n,-3);
	if (cvd.ned > 0) {
	  // -4 == y0
	  const double n[3] = { 0.0, -0.505*delta, 0.0 };
	  cvd.cut_surf(n,-4);
	  if (cvd.ned > 0) {
	    // -5 == y1
	    const double n[3] = { 0.0, 0.505*delta, 0.0 };
	    cvd.cut_surf(n,-5);
	    if (cvd.ned > 0) {
	      // -6 == z0
	      const double n[3] = { 0.0, 0.0, -0.505*delta };
	      cvd.cut_surf(n,-6);
	      if (cvd.ned > 0) {
		// -7 == z1
		const double n[3] = { 0.0, 0.0, 0.505*delta };
		cvd.cut_surf(n,-7);
		if (cvd.ned > 0) {
		  // check: if we still have stuff left, all cvd.faoed[ied][1] 
		  // that were -1 should have been cut off...
		  for (int ied = 0; ied < cvd.ned; ++ied)
		    assert(cvd.faoed[ied][1] != -1);
		}
	      }
	    }
	  }
	}
      }
    }
    // at this point, we may have zero elements in the cvd because there were 
    // none to start with, OR they were all cut away...
    if (cvd.ned == 0) {
      cvd.addCube(0.505*delta);
    }
    else {
      cvd.completeCube(0.505*delta);
    }
    // this helps to limit nbrs...
    cvd.setD2Max();
    cvd.check();
    // now assemble nbrs and start cutting....
    nbrVec.clear();
    for (int ii = 0; ii < nnbr; ++ii) {
      const int ip_nbr = recv_buf_int[irecv_int++]; // on rank, bits are zero
      double dx[3]; FOR_I3 dx[i] = recv_buf_double[irecv_double++] - xp[i];
      const double d2 = DOT_PRODUCT(dx,dx); assert(sqrt(d2) < delta*1.00000001);
      nbrVec.push_back(pair<double,int>(d2,irecv_double-3));
    }
    // now sort. It would be great if the reference index here were some sort of
    // global so the sorted order were always the same...
    sort(nbrVec.begin(),nbrVec.end());
    // and cut the cvd in sorted order...
    //HEREHERE
    
    
    // debug...
    //cvd.writeTecplot(1,xp);
    //MPI_Pause("dshjksdhjklasf");
    // and the nbrs are next...

  }
  assert(irecv_int == recv_count_int_sum);
  assert(irecv_double == recv_count_double_sum);

#endif  

  MPI_Pause("LOOOOOOKS GOOOOOOOOOD end of buildVoronoiNew()");





  // note that we leave the sgs in the appearing cvs as zer at this point. These appearing
  // cvs are upwinded in the first timestep they appear, so this is a small error...
  
  
  double * tmp = new double[ncv_dg]; // also used in smoothing loop for now (need implicit update)

  for (int icv = 0; icv < ncv_dg; ++icv)
    tmp[icv] = cv[icv].mu_sgs;
  dumpRange(tmp,ncv_dg,"MU_SGS before smoothing");

  // at this points we have a reasonable state in all [0:ncv_d) cvs, except the sgs
  // model stuff is not set in appearing cvs. We cannot compute it because
  // we do not have good estimates for the velocity field in these cvs yet
  // so we are going to smooth it in. update everything first...


  // now smooth...

  if (sgs_model != SGS_NONE) {

    double * mu_sgs_imp = new double[ncv_imp_g];
    for (int icv_imp = 0; icv_imp < ncv_imp_g; ++icv_imp) {
      const int icv = cvocv_imp[icv_imp]; assert((icv >= 0)&&(icv < ncv_dg));
      mu_sgs_imp[icv_imp] = cv[icv].mu_sgs;
    }

    for (int icv_imp = 0; icv_imp < ncv_imp_a; ++icv_imp)
      assert(mu_sgs_imp[icv_imp] == 0.0);

    for (int icv_imp = ncv_imp_a; icv_imp < ncv_imp; ++icv_imp)
      assert(mu_sgs_imp[icv_imp] > 0.0); // fails if no sgs model, or sgs model returned zero - just a check

    double *wgt_imp_a = new double[ncv_imp_a];
    double *mu_sgs_imp_a = new double[ncv_imp_a];

    int iter = 0;
    int done = 0;
    while (done == 0) {

      ++iter;

      for (int icv_imp = 0; icv_imp < ncv_imp_a; ++icv_imp) {
	wgt_imp_a[icv_imp]    = 0.0;
	mu_sgs_imp_a[icv_imp] = 0.0;
      }

      // since it is appearing only, just consider the new mesh connectivity...

      for (int ifa = 0; ifa < nfa_imp; ++ifa) {
	const int icv0_imp = cvofa_imp[ifa][0]; assert(cvocv_imp[icv0_imp] == cvofa[ifa][0]);
	const int icv1_imp = cvofa_imp[ifa][1]; assert(cvocv_imp[icv1_imp] == cvofa[ifa][1]);
	const double area = MAG(fa[ifa].n);
	if (icv0_imp < ncv_imp_a) {
	  wgt_imp_a[icv0_imp] += area;
	  mu_sgs_imp_a[icv0_imp] += area*mu_sgs_imp[icv1_imp];
	}
	if (icv1_imp < ncv_imp_a) {
	  wgt_imp_a[icv1_imp] += area;
	  mu_sgs_imp_a[icv1_imp] += area*mu_sgs_imp[icv0_imp];
	}
      }

      double my_zero = 0.0;
      for (int icv_imp = 0; icv_imp < ncv_imp_a; ++icv_imp) {
	assert(wgt_imp_a[icv_imp] > 0.0);
	const double dmu = mu_sgs_imp_a[icv_imp]/wgt_imp_a[icv_imp] - mu_sgs_imp[icv_imp];
	mu_sgs_imp[icv_imp] += dmu;
	if (mu_sgs_imp[icv_imp] > 0.0)
	  my_zero = max(my_zero,fabs(dmu)/mu_sgs_imp[icv_imp]);
      }

      // HACK -- rewrite this more efficiently some day. It should not require the cv-based one...
      updateCvDataImplicit(mu_sgs_imp,tmp);

      double zero;
      MPI_Reduce(&my_zero,&zero,1,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
      if (mpi_rank == 0) {
	cout << " > filter mu_sgs: iter: " << iter << " zero: " << zero << endl;
	if (zero < 1.0E-6)
	  done = 1;
      }
      MPI_Bcast(&done,1,MPI_INT,0,mpi_comm);

    }

    // now put back on mu_sgs...

    for (int icv_imp = 0; icv_imp < ncv_imp_g; ++icv_imp) {
      const int icv = cvocv_imp[icv_imp]; assert((icv >= 0)&&(icv < ncv_dg));
      cv[icv].mu_sgs = mu_sgs_imp[icv_imp];
    }


    delete[] mu_sgs_imp_a;
    delete[] wgt_imp_a;
    delete[] mu_sgs_imp;

  }


  for (int icv = 0; icv < ncv_dg; ++icv)
    tmp[icv] = cv[icv].mu_sgs;
  dumpRange(tmp,ncv_dg,"MU_SGS after smoothing");

  for (int icv = 0; icv < ncv_dg; ++icv)
    tmp[icv] = cv[icv].rho - rho_ref;
  dumpRange(tmp,ncv_dg,"rho-rho_ref");

  delete[] tmp;
  







void VoronoiPart::buildInternalFaceStuff() {

  assert(0);

  // internal faces ifa (as distinct from boundary faces ibf) are organized in the 
  // following ranges...
  //
  // [0:nfa_e) internal explicit only
  // [nfa_e:nfa_ei) internal implicit (both cvs implicit)
  // [nfa_ei:nfa_eii) internal implicit (first cv implicit)
  // [nfa_eii:nfa_eiie) inter-processor explicit (local cv explicit)
  // [nfa_eiie:nfa) inter-processor implicit (local cv implicit)

  // the current ncv,ncv_d should be set external to this routine
  
  assert(ncv == points->np);
  assert(ncv_d >= ncv);
  
  // HACK -- get rid of this stuff...
  const int ncv_e = ncv; 

  assert(nfa_e == 0);
  assert(nfa_ei == 0);
  assert(nfa_eii == 0);
  assert(nfa_eiie == 0);
  assert(nfa == 0);
  
  int * send_count = new int[mpi_size];
  FOR_RANK send_count[rank] = 0;

  assert(faocv_i == NULL);
  faocv_i = new int[ncv+1];
  FOR_ICV faocv_i[icv+1] = 0;
  
  for (int ip = 0; ip < points->np; ++ip) {
    for (int ifa_ = 0; ifa_ < cvdVec[ip].getNfa(); ++ifa_) {
      if ( (cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && 
	   (cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	const int ip_nbr =  cvdVec[ip].getNbofa(ifa_);
	assert(ip != ip_nbr); // no self-connections
	if (ip_nbr < points->np) {
	  // the face nbr should be matched and valid as well...
	  const int ifa_nbr_ = cvdVec[ip].ifa_nbr[ifa_];
	  assert((ifa_nbr_ >= 0)&&(ifa_nbr_ < cvdVec[ip_nbr].getNfa()));
	  assert( cvdVec[ip_nbr].getNbofa(ifa_nbr_) == ip );
	  assert( (cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && 
		  (cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) );
	  assert(cvdVec[ip_nbr].ifa_nbr[ifa_nbr_] == ifa_);
	  if (ip < ip_nbr) {
	    ++faocv_i[ip+1];
	    ++faocv_i[ip_nbr+1];
	    if ((ip >= ncv_e)&&(ip_nbr >= ncv_e)) {
	      // both are implicit. count this face once when
	      // ip < ip_nbr...
	      ++nfa_ei;
	    }
	    else if ((ip >= ncv_e)||(ip_nbr >= ncv_e)) {
	      // one is implicit. count this face once when
	      // ip < ip_nbr...
	      ++nfa_eii;
	    }
	    else {
	      assert((ip < ncv_e)&&(ip_nbr < ncv_e));
	      // both are explicit, so add face once when
	      // ip < ip_nbr...
	      ++nfa_e;
	    }
	  }
	}
	else {
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbiGhostVec[ip_nbr-points->np]);
	  assert((rank != mpi_rank)||(bits != 0));
	  ++faocv_i[ip+1];
	  send_count[rank] += 3;
	  if (ip >= ncv_e) {
	    ++nfa; // inter-processor implicit
	  }
	  else  {
	    ++nfa_eiie; // inter-processor explicit
	  }
	}
      }
    }
  }
  
  nfa_ei   += nfa_e;
  nfa_eii  += nfa_ei;
  nfa_eiie += nfa_eii;
  nfa      += nfa_eiie;

  /*
    cout << "XXXXX mpi_rank: " << mpi_rank << " nfa_e, nfa_ei, nfa_eii, nfa_eiie, nfa: " << 
    nfa_e << " " <<
    nfa_ei << " " <<
    nfa_eii << " " <<
    nfa_eiie << " " <<
    nfa << endl;
  */
  
  faocv_i[0] = 0;
  FOR_ICV faocv_i[icv+1] += faocv_i[icv];
  assert(faocv_v == NULL);
  faocv_v = new int[faocv_i[ncv]];
  
  assert(cvofa == NULL);
  cvofa = new int[nfa][2];
  
  assert(n_fa == NULL);
  n_fa = new double[nfa][3];
  
  assert(c_fa == NULL);
  c_fa = new double[nfa][3];
  
  int * send_disp = new int[mpi_size];
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  const int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
  
  int *send_buf_int = new int[send_count_sum];
  double *send_buf_double = new double[send_count_sum*2];
  
  int ifa_e = 0;
  int ifa_ei = nfa_e;
  int ifa_eii = nfa_ei;
  int ifa_eiie = nfa_eii;
  int ifa = nfa_eiie;
  for (int ip = 0; ip < points->np; ++ip) {
    for (int ifa_ = 0; ifa_ < cvdVec[ip].getNfa(); ++ifa_) {
      if ( (cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && 
	   (cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	const int ip_nbr =  cvdVec[ip].getNbofa(ifa_);
	assert(ip != ip_nbr); // no self-connections
	if (ip_nbr < points->np) {
	  // the face nbr should be matched and valid as well...
	  const int ifa_nbr_ = cvdVec[ip].ifa_nbr[ifa_];
	  assert((ifa_nbr_ >= 0)&&(ifa_nbr_ < cvdVec[ip_nbr].getNfa()));
	  assert( (cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && 
		  (cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) );
	  assert( cvdVec[ip_nbr].getNbofa(ifa_nbr_) == ip );
	  assert( cvdVec[ip_nbr].ifa_nbr[ifa_nbr_] == ifa_ );
	  if (ip < ip_nbr) {
	    int this_ifa;
	    double sgn;
	    if ((ip >= ncv_e)&&(ip_nbr >= ncv_e)) {
	      // both are implicit. count this face once when
	      // ip < ip_nbr...
	      this_ifa = ifa_ei++;
	      sgn = 1.0;
	      cvofa[this_ifa][0] = ip;
	      cvofa[this_ifa][1] = ip_nbr;
	    }
	    else if ((ip >= ncv_e)||(ip_nbr >= ncv_e)) {
	      // one is implicit. count this face once when
	      // ip < ip_nbr...
	      this_ifa = ifa_eii++;
	      if (ip >= ncv_e) {
		sgn = 1.0;	
		cvofa[this_ifa][0] = ip;
		cvofa[this_ifa][1] = ip_nbr;
	      }
	      else {
		assert(ip_nbr >= ncv_e);
		sgn = -1.0;
		cvofa[this_ifa][1] = ip;
		cvofa[this_ifa][0] = ip_nbr;
	      }
	    }
	    else {
	      assert((ip < ncv_e)&&(ip_nbr < ncv_e));
	      // both are explicit, so add face once when
	      // ip < ip_nbr...
	      this_ifa = ifa_e++;
	      sgn = 1.0;
	      cvofa[this_ifa][0] = ip;
	      cvofa[this_ifa][1] = ip_nbr;
	    }
	    faocv_v[faocv_i[ip]++] = this_ifa;
	    faocv_v[faocv_i[ip_nbr]++] = this_ifa;
	    FOR_I3 n_fa[this_ifa][i] = sgn*0.5*(cvdVec[ip].n_fa[ifa_][i] - cvdVec[ip_nbr].n_fa[ifa_nbr_][i]);
	    FOR_I3 c_fa[this_ifa][i] = 0.5*(cvdVec[ip].x_fa[ifa_][i] + cvdVec[ip_nbr].x_fa[ifa_nbr_][i]); // recall x_fa is in the vor reference frame 
	  }
	}
	else {
	  int this_ifa;
	  if (ip >= ncv_e) {
	    this_ifa = ifa++; // inter-processor implicit
	  }
	  else  {
	    this_ifa = ifa_eiie++; // inter-processor explicit
	  }
	  cvofa[this_ifa][0] = ip;
	  cvofa[this_ifa][1] = ip_nbr;
	  faocv_v[faocv_i[ip]++] = this_ifa;
	  const int ig = ip_nbr-points->np;
	  FOR_I3 n_fa[this_ifa][i] = 0.5*cvdVec[ip].n_fa[ifa_][i];
	  FOR_I3 c_fa[this_ifa][i] = 0.5*( cvdVec[ip].x_fa[ifa_][i] + 0.5*( points->xp[ip][i] - xpGhostVec[ig].x[i] ) );
	  int rank,bits,index;
	  BitUtils::unpackRankBitsIndex(rank,bits,index,rbiGhostVec[ip_nbr-points->np]);
	  assert((rank != mpi_rank)||(bits != 0));
	  send_buf_int[send_disp[rank]  ] = index;
	  send_buf_int[send_disp[rank]+1] = ip;
	  if (bits == 0) 
	    send_buf_int[send_disp[rank]+2] = 0;
	  else
	    send_buf_int[send_disp[rank]+2] = BitUtils::flipPeriodicBits(bits);
	  // and the n_fa and c_fa...
	  send_buf_double[send_disp[rank]*2  ] = n_fa[this_ifa][0];
	  send_buf_double[send_disp[rank]*2+1] = n_fa[this_ifa][1];
	  send_buf_double[send_disp[rank]*2+2] = n_fa[this_ifa][2];
	  send_buf_double[send_disp[rank]*2+3] = c_fa[this_ifa][0];
	  send_buf_double[send_disp[rank]*2+4] = c_fa[this_ifa][1];
	  send_buf_double[send_disp[rank]*2+5] = c_fa[this_ifa][2];
	  // apply periodic transform to both the passed n_fa and c_fa if req'd...
	  if (bits) {
	    assert(0);
	  }
	  send_disp[rank] += 3;
	}
      }
    }
  }
  
  // rewind send_disp...

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

  assert(ifa_e == nfa_e);
  assert(ifa_ei == nfa_ei);
  assert(ifa_eii == nfa_eii);
  assert(ifa_eiie == nfa_eiie);
  assert(ifa == nfa);

  MPI_Pause("================== OKOK =====================");

  int * recv_count = new int[mpi_size];
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);

  int * recv_disp = new int[mpi_size];
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];

  int * recv_buf_int = new int[recv_count_sum];
  MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
  delete[] send_buf_int;

  FOR_RANK {
    send_count[rank] *= 2;
    send_disp[rank] *= 2;
    recv_count[rank] *= 2;
    recv_disp[rank] *= 2;
  }

  double * recv_buf_double = new double[recv_count_sum*2];
  MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  delete[] send_buf_double;
  
  // loop on recv'd data and complete n_fa, c_fa, etc...
  
  
  
  
  


  MPI_Pause("======================================= OOKOK");
  
  delete[] recv_buf_int;
  delete[] recv_buf_double;
  
  delete[] send_count;
  delete[] send_disp;
  delete[] recv_count;
  delete[] recv_disp;
  
}


#define T Surface::MixedTri
# include "Mmap_Munmap.hpp"
#undef T

#define T Surface::MixedSphere
# include "Mmap_Munmap.hpp"
#undef T

#define T Surface::BloatedSurfaceTri
# include "Mmap_Munmap.hpp"
#undef T

  class VoronoiVertex {
  public:
    double x[3];
    double delta;
    int level;
    VoronoiVertex() {}
    VoronoiVertex(const double x[3],const double delta,const int level) {
      this->x[0] = x[0];
      this->x[1] = x[1];
      this->x[2] = x[2];
      this->delta = delta;
      this->level = level;
    }
  };

  //#include "initHcpPoints.hpp"
  void initHcpPoints() {

    // TODO: somehow for this routine we need to build a global indexing that is
    // independent of partitioning. The cyclic nature of how the x-lines are
    // traced through the domain makes this challenging right now.

    assert(points == NULL);
    assert(hcpDelta > 0.0);

    COUT1(getName() << ": initMeshHcp()");
    MPI_Sync("initMeshHcp()");

    // an Hcp mesh requires the surface on all processors...

    assert(surface->status == SHM_SURFACE);

    // we should all have the surface now. To raytrace the surface, we need to
    // convert it to an integer pair...

    const double grid_factor = 0.5*sqrt(3.0);
    const double offset_factor = 1.0;

    // for cart...
    // grid_factor = 1.0; // or 1 for cart
    // offset_factor = 0.0;

    // get the middle point and use for int conversion...
    if (!got_hcp_x0) 
      FOR_I3 hcp_x0[i] = 0.5*(surface->bbmin[i]+surface->bbmax[i]);
    const double delta_max = max(surface->bbmax[0]-surface->bbmin[0],
				 max(surface->bbmax[1]-surface->bbmin[1],
				     surface->bbmax[2]-surface->bbmin[2]));
    const int Nbase = int( log(hcpDelta*grid_factor/delta_max)/log(2.0) + HCP_BIT_MAX );
    const double dxp = double(1<<Nbase)/(hcpDelta*grid_factor); // actually dj/dy == dk/dz

    // convert everything to int tri's in (y,z)...

    Surface::MixedTri * mixedTriVec = NULL;
    CTI_Mmap(mixedTriVec,surface->nst);

    // only mpi_rank_shared == 0 need to set the tris and compute the bbox's...

    int bbmin0[2],bbmax0[2]; // these will get populated by a Bcast from the root process on each node

    int (*bbmin)[2] = NULL;
    int (*bbmax)[2] = NULL;
    if (mpi_rank_shared == 0) {

      FOR_J2 bbmin0[j] = (1<<HCP_BIT_MAX);
      FOR_J2 bbmax0[j] = -(1<<HCP_BIT_MAX);

      // allocate bbox's on each node's rank 0. Does not need to be shared...
      bbmin = new int[surface->nst][2];
      bbmax = new int[surface->nst][2];

      for (int ist = 0; ist < surface->nst; ++ist) {
	mixedTriVec[ist].init(surface->xp[surface->spost[ist][0]],
			      surface->xp[surface->spost[ist][1]],
			      surface->xp[surface->spost[ist][2]],
			      hcp_x0,dxp);
	mixedTriVec[ist].setBboxJK(bbmin[ist],bbmax[ist]);
	// modify global bbox0...
	FOR_J2 bbmin0[j] = min(bbmin0[j],bbmin[ist][j]);
	FOR_J2 bbmax0[j] = max(bbmax0[j],bbmax[ist][j]);
      }

    }

    // Bcast the calculated bbmin0/bbmax0 to all...

    MPI_Bcast(bbmin0,2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(bbmax0,2,MPI_INT,0,mpi_comm_shared);

    // we need a shared-mem adt to find these points...
    // note that bbmin and bbmax are only declared on mpi_rank_shared == 0...

    Adt2dShm<int> adt0(surface->nst,bbmin,bbmax);

    if (mpi_rank_shared == 0) {
      delete[] bbmin; bbmin = NULL;
      delete[] bbmax; bbmax = NULL;
    }

    // because it is easier to expand a vec, do this on (mpi_rank_shared == 0) processes
    // first. Note that here we use a size of MAX_LEVEL, with the index == level-1 (no
    // zero is required)...

    vector<Surface::MixedSphere> * mixedSphereVecArray = NULL;
    vector<Surface::MixedTri> * mixedTriVecArray = NULL;
    vector<Surface::BloatedSurfaceTri> * bloatedSurfaceTriVecArray = NULL;
    int mixedSphereCount[HCP_LEVEL_MAX+1]; // add one for error management
    int mixedTriCount[HCP_LEVEL_MAX];
    int bloatedSurfaceTriCount[HCP_LEVEL_MAX];

    if (mpi_rank_shared == 0) {

      // needed on mpi_rank_shared == 0 only...

      mixedSphereVecArray       = new vector<Surface::MixedSphere>[HCP_LEVEL_MAX];
      mixedTriVecArray          = new vector<Surface::MixedTri>[HCP_LEVEL_MAX];
      bloatedSurfaceTriVecArray = new vector<Surface::BloatedSurfaceTri>[HCP_LEVEL_MAX];
      
      mixedSphereCount[HCP_LEVEL_MAX] = 0; // used for error checking...

      try {

	// the classes derived from hcpWindow knows how to add relevant spheres and tris, given
	// the hcp_x0 and dxp...
	COUT1(" > processing " << hcpWindowVec.size() << " windows:");
	for (int iw = 0; iw < hcpWindowVec.size(); ++iw) {
	  hcpWindowVec[iw]->printInfo();
	  hcpWindowVec[iw]->addElements(mixedSphereVecArray,mixedTriVecArray,hcp_x0,dxp);
	}

	// go back to separate parameter parsing version...
	
	FOR_PARAM_MATCHING("HCP_WINDOW") {
	  int iarg = 0;
	  string token = param->getString(iarg++);
	  COUT1("WORKING on HCP_WINDOW: " << token);
	  if (token == "FAZONE") {
	    token = param->getString(iarg++); // expect comma-limited zone names...
	    surface->clearSelectedFaces();
	    surface->selectFacesOfCsvZones(token);
	    assert(param->getString(iarg++) == "LEVEL");
	    const int level = param->getInt(iarg++);
	    assert(param->getString(iarg++) == "NLAYERS");
	    const int nlayers = param->getInt(iarg++);
	    for (int ist = 0; ist < surface->nst; ++ist) {
	      if (surface->getSelectedFace(ist)) {
		for (int this_level = 1; this_level <= level; ++this_level) {
		  const double delta = hcpDelta*double(nlayers)/double(1<<this_level);
		  bloatedSurfaceTriVecArray[this_level-1].push_back(Surface::BloatedSurfaceTri());
		  bloatedSurfaceTriVecArray[this_level-1].back().init(ist,delta);
		}
	      }
	    }
	  }
	  else {
	    CERR("unsupported HCP_WINDOW: " << token);
	  }
	}
	
      }
      catch (...) {

	mixedSphereCount[HCP_LEVEL_MAX] = -1;
	
      }

      // now count the elements...
      for (int level = 0; level < HCP_LEVEL_MAX; ++level) {
	mixedSphereCount[level]       = mixedSphereVecArray[level].size();
	mixedTriCount[level]          = mixedTriVecArray[level].size();
	bloatedSurfaceTriCount[level] = bloatedSurfaceTriVecArray[level].size();
      }
      
    }
    
    // =====================================================================
    // and bcast the sphere counts. recall we use one more than 
    // the number of levels here for error handling...
    // =====================================================================
    MPI_Bcast(mixedSphereCount,HCP_LEVEL_MAX+1,MPI_INT,0,mpi_comm_shared); // include error checking...
    
    if (mixedSphereCount[HCP_LEVEL_MAX] == -1)
      throw(0);

    Surface::MixedSphere * mixedSpherePtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * mixedSphereAdt[HCP_LEVEL_MAX];
    int mixedSphereBbmin[HCP_LEVEL_MAX][2];
    int mixedSphereBbmax[HCP_LEVEL_MAX][2];

    int level_max = 0;
    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      mixedSpherePtr[level-1] = NULL;
      mixedSphereAdt[level-1] = NULL;
      FOR_J2 mixedSphereBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 mixedSphereBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      if (mixedSphereCount[level-1] > 0) {
	const int nms = mixedSphereCount[level-1];
	//if (mpi_rank == 0)
	//  cout << " > level: " << level << " nms: " << nms << endl;
	level_max = level;
	// everyone maps the shared memory...
	CTI_Mmap(mixedSpherePtr[level-1],nms);
	// rank 0 on each node copies their vector data, and then clears...
	if (mpi_rank_shared == 0) {
	  assert(mixedSphereVecArray[level-1].size() == nms);
	  for (int ist = 0; ist < nms; ist++)
	    mixedSpherePtr[level-1][ist] = mixedSphereVecArray[level-1][ist];
	  mixedSphereVecArray[level-1].clear();
	}
	// and the bbox...
	assert(bbmin == NULL);
	assert(bbmax == NULL);
	if (mpi_rank_shared == 0) {
	  bbmin = new int[nms][2];
	  bbmax = new int[nms][2];
	  for (int ist = 0; ist < nms; ist++) {
	    mixedSpherePtr[level-1][ist].setBboxJK(bbmin[ist],bbmax[ist]);
	    // and adjust the level bbox...
	    FOR_J2 mixedSphereBbmin[level-1][j] = min(mixedSphereBbmin[level-1][j],bbmin[ist][j]);
	    FOR_J2 mixedSphereBbmax[level-1][j] = max(mixedSphereBbmax[level-1][j],bbmax[ist][j]);
	  }
	}
	mixedSphereAdt[level-1] = new Adt2dShm<int>(nms,bbmin,bbmax);
	if (mpi_rank_shared == 0) {
	  delete[] bbmin; bbmin = NULL;
	  delete[] bbmax; bbmax = NULL;
	}
      }
    }

    if (mpi_rank_shared == 0)
      delete[] mixedSphereVecArray;

    // and Bcast the global bbox...
    if (checkParam("VERBOSE")) COUT1(" > mixedSpheres bounding box");
    MPI_Bcast(mixedSphereBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(mixedSphereBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    // the raytracing algorithm needs to trace rays through all levels equal or
    // above the level of the ray. i.e. even if the geometry contains just one level 3
    // sphere, we still need to trace all level 1,2 AND 3 lines through the sphere...

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      // include bbox of all higher levels...
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 mixedSphereBbmin[level-1][j] = min(mixedSphereBbmin[level-1][j],mixedSphereBbmin[level][j]);
	FOR_J2 mixedSphereBbmax[level-1][j] = max(mixedSphereBbmax[level-1][j],mixedSphereBbmax[level][j]);
      }
      // and clip against the global bbox...
      FOR_J2 mixedSphereBbmin[level-1][j] = max(mixedSphereBbmin[level-1][j],bbmin0[j]);
      FOR_J2 mixedSphereBbmax[level-1][j] = min(mixedSphereBbmax[level-1][j],bbmax0[j]);
    }

    // ==============================================================
    // and then mixed tris...
    // ==============================================================
    MPI_Bcast(mixedTriCount,HCP_LEVEL_MAX,MPI_INT,0,mpi_comm_shared);

    Surface::MixedTri * mixedTriPtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * mixedTriAdt[HCP_LEVEL_MAX];
    int mixedTriBbmin[HCP_LEVEL_MAX][2];
    int mixedTriBbmax[HCP_LEVEL_MAX][2];

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      mixedTriPtr[level-1] = NULL;
      mixedTriAdt[level-1] = NULL;
      FOR_J2 mixedTriBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 mixedTriBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      if (mixedTriCount[level-1] > 0) {
	const int nmt = mixedTriCount[level-1];
	//if (mpi_rank == 0)
	//  cout << " > level: " << level << " nmt: " << nmt << endl;
	level_max = max(level_max,level);
	// everyone maps the shared memory...
	CTI_Mmap(mixedTriPtr[level-1],nmt);
	// rank 0 on each node copies their vector data, and then clears...
	if (mpi_rank_shared == 0) {
	  assert(mixedTriVecArray[level-1].size() == nmt);
	  for (int imt = 0; imt < nmt; ++imt)
	    mixedTriPtr[level-1][imt] = mixedTriVecArray[level-1][imt];
	  mixedTriVecArray[level-1].clear();
	}
	// and the bbox...
	assert(bbmin == NULL);
	assert(bbmax == NULL);
	if (mpi_rank_shared == 0) {
	  bbmin = new int[nmt][2];
	  bbmax = new int[nmt][2];
	  for (int imt = 0; imt < nmt; ++imt) {
	    mixedTriPtr[level-1][imt].setBboxJK(bbmin[imt],bbmax[imt]);
	    // and adjust the level bbox...
	    FOR_J2 mixedTriBbmin[level-1][j] = min(mixedTriBbmin[level-1][j],bbmin[imt][j]);
	    FOR_J2 mixedTriBbmax[level-1][j] = max(mixedTriBbmax[level-1][j],bbmax[imt][j]);
	  }
	}
	mixedTriAdt[level-1] = new Adt2dShm<int>(nmt,bbmin,bbmax);
	if (mpi_rank_shared == 0) {
	  delete[] bbmin; bbmin = NULL;
	  delete[] bbmax; bbmax = NULL;
	}
      }
    }

    if (mpi_rank_shared == 0)
      delete[] mixedTriVecArray;

    // and Bcast the global bbox...
    if (checkParam("VERBOSE")) COUT1(" > mixedTris bounding box");
    MPI_Bcast(mixedTriBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(mixedTriBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    // the raytracing algorithm needs to trace rays through all levels equal or
    // above the level of the ray. i.e. even if the geometry contains just one level 3
    // tri, we still need to trace all level 1,2 AND 3 lines through the tri...

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      // include bbox of all higher levels...
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 mixedTriBbmin[level-1][j] = min(mixedTriBbmin[level-1][j],mixedTriBbmin[level][j]);
	FOR_J2 mixedTriBbmax[level-1][j] = max(mixedTriBbmax[level-1][j],mixedTriBbmax[level][j]);
      }
      // and clip against the global bbox...
      FOR_J2 mixedTriBbmin[level-1][j] = max(mixedTriBbmin[level-1][j],bbmin0[j]);
      FOR_J2 mixedTriBbmax[level-1][j] = min(mixedTriBbmax[level-1][j],bbmax0[j]);
    }

    // ==============================================================
    // and then bloated surface tris...
    // ==============================================================
    MPI_Bcast(bloatedSurfaceTriCount,HCP_LEVEL_MAX,MPI_INT,0,mpi_comm_shared);
    
    Surface::BloatedSurfaceTri * bloatedSurfaceTriPtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * bloatedSurfaceTriAdt[HCP_LEVEL_MAX];
    int bloatedSurfaceTriBbmin[HCP_LEVEL_MAX][2];
    int bloatedSurfaceTriBbmax[HCP_LEVEL_MAX][2];

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      bloatedSurfaceTriPtr[level-1] = NULL;
      bloatedSurfaceTriAdt[level-1] = NULL;
      FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      if (bloatedSurfaceTriCount[level-1] > 0) {
	const int nbst = bloatedSurfaceTriCount[level-1];
	//if (mpi_rank == 0)
	//  cout << " > level: " << level << " nbst: " << nbst << endl;
	level_max = max(level_max,level);
	// everyone maps the shared memory...
	CTI_Mmap(bloatedSurfaceTriPtr[level-1],nbst);
	// rank 0 on each node copies their vector data, and then clears...
	if (mpi_rank_shared == 0) {
	  assert(bloatedSurfaceTriVecArray[level-1].size() == nbst);
	  for (int ibst = 0; ibst < nbst; ++ibst)
	    bloatedSurfaceTriPtr[level-1][ibst] = bloatedSurfaceTriVecArray[level-1][ibst];
	  bloatedSurfaceTriVecArray[level-1].clear();
	}
	// and the bbox...
	assert(bbmin == NULL);
	assert(bbmax == NULL);
	if (mpi_rank_shared == 0) {
	  bbmin = new int[nbst][2];
	  bbmax = new int[nbst][2];
	  for (int ibst = 0; ibst < nbst; ++ibst) {
	    bloatedSurfaceTriPtr[level-1][ibst].setBboxJK(bbmin[ibst],bbmax[ibst],surface,hcp_x0,dxp);
	    // and adjust the level bbox...
	    FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = min(bloatedSurfaceTriBbmin[level-1][j],bbmin[ibst][j]);
	    FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = max(bloatedSurfaceTriBbmax[level-1][j],bbmax[ibst][j]);
	  }
	}
	bloatedSurfaceTriAdt[level-1] = new Adt2dShm<int>(nbst,bbmin,bbmax);
	if (mpi_rank_shared == 0) {
	  delete[] bbmin; bbmin = NULL;
	  delete[] bbmax; bbmax = NULL;
	}
      }
    }

    if (mpi_rank_shared == 0)
      delete[] bloatedSurfaceTriVecArray;

    // and Bcast the global bbox...
    if (checkParam("VERBOSE")) COUT1(" > bloatedSurfaceTris bounding box");
    MPI_Bcast(bloatedSurfaceTriBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(bloatedSurfaceTriBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    // the raytracing algorithm needs to trace rays through all levels equal or
    // above the level of the ray. i.e. even if the geometry contains just one level 3
    // tri, we still need to trace all level 1,2 AND 3 lines through the tri...

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      // include bbox of all higher levels...
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = min(bloatedSurfaceTriBbmin[level-1][j],bloatedSurfaceTriBbmin[level][j]);
	FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = max(bloatedSurfaceTriBbmax[level-1][j],bloatedSurfaceTriBbmax[level][j]);
      }
      // and clip against the global bbox...
      FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = max(bloatedSurfaceTriBbmin[level-1][j],bbmin0[j]);
      FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = min(bloatedSurfaceTriBbmax[level-1][j],bbmax0[j]);
    }

    // Ok -- we have the the mixed tris's in mixedTriVec (shared mem) and
    // we have a shared mem adt2d that can lookup ray intersections fast. Now
    // loop on ray limits for each level...

    int cycle = mpi_rank; // used for sequence-based parallelization...
    vector<Surface::XpIntersection> xpIntersectionVec;

    MPI_Sync("done refinement windows");

    // ===================================================================================
    // Point generation.
    // =================
    // loop through the levels, and trace all potential j,k rays at each level. Note that
    // we avoid double- (or triple-, etc.) tracing of rays with the check:
    //
    // if ((level == 0)||(j%(2*djk) != 0)||(k%(2*djk) != 0)) {
    //
    // which skips nested rays that have already been traced.
    // ===================================================================================

    if (mpi_rank == 0) {
      cout << " > level_max: " << level_max << endl;
      for (int level = 0; level <= level_max; ++level)
	cout << " > level: " << level << " delta: " << hcpDelta/double(1<<level) << endl;
    }

    // generate the points into vertexVec, then copy into the xv,deltav buffer below...

    vector<VoronoiVertex> vertexVec;

    // debugging...
    int j_debug;

    for (int level = 0; level <= level_max; ++level) {

      // as a first step, determine the bbox for this level...

      int bbminL[2] = { (1<<HCP_BIT_MAX), (1<<HCP_BIT_MAX) };
      int bbmaxL[2] = { -(1<<HCP_BIT_MAX), -(1<<HCP_BIT_MAX) };

      if (level == 0) {
	// the level 0 case gets the full bounding box...
	FOR_J2 bbminL[j] = bbmin0[j];
	FOR_J2 bbmaxL[j] = bbmax0[j];
      }
      else {
	// otherwise, the bbox that includes all refinement objects at level and above...
	FOR_J2 bbminL[j] = min( mixedSphereBbmin[level-1][j], min( mixedTriBbmin[level-1][j], bloatedSurfaceTriBbmin[level-1][j]) );
	FOR_J2 bbmaxL[j] = max( mixedSphereBbmax[level-1][j], max( mixedTriBbmax[level-1][j], bloatedSurfaceTriBbmax[level-1][j]) );
      }

      // now loop rays and start building points...

      const int djk = (1<<(Nbase-level));
      int jmin = ( bbminL[0] < 0 ? bbminL[0]-(bbminL[0]%djk) : bbminL[0]-(bbminL[0]%djk)+djk );  assert(jmin > bbminL[0]);
      int jmax = ( bbmaxL[0] < 0 ? bbmaxL[0]-(bbmaxL[0]%djk)-djk : bbmaxL[0]-(bbmaxL[0]%djk) );  assert(jmax <= bbmaxL[0]); // added == because zero is possible
      int kmin = ( bbminL[1] < 0 ? bbminL[1]-(bbminL[1]%djk) : bbminL[1]-(bbminL[1]%djk)+djk );  assert(kmin > bbminL[1]);
      int kmax = ( bbmaxL[1] < 0 ? bbmaxL[1]-(bbmaxL[1]%djk)-djk : bbmaxL[1]-(bbmaxL[1]%djk) );  assert(kmax <= bbmaxL[1]);

      if (checkParam("YMIN_DEBUG")) {
	if (level == 0)
	  j_debug = jmin;
	jmin = jmax = j_debug;
      }
      if (checkParam("YMID_DEBUG")) {
	jmin = jmax = 0;
      }
      if (checkParam("ZMID_DEBUG")) {
	kmin = kmax = 0;
      }

      // checking...
      if (mpi_rank == 0)
	cout << " > working on level " << level;
      int jcheck = jmin;
      int djcheck = (jmax-jmin)/8;

      for (int j = jmin; j <= jmax; j += djk) {

	// reporting...
	if ((mpi_rank == 0)&&(j >= jcheck)) {
	  cout << ".";
	  cout.flush();
	  jcheck += djcheck;
	}

	for (int k = kmin; k <= kmax; k += djk) {
	  if ((level == 0)||(j%(2*djk) != 0)||(k%(2*djk) != 0)) {
	    // ====================================================================
	    // the cycle int is used to decide which rank takes this (j,k) ray...
	    // it gets updated below...
	    // ====================================================================
	    if (cycle == 0) {
	      //if (true) { // HACK -- all do the same
	      assert(xpIntersectionVec.empty());
	      // add level0 intersections first...
	      surface->addXpIntersections(xpIntersectionVec,j,k,&adt0,mixedTriVec,0);
	      // only continue if there are level0 intersections...
	      if (!xpIntersectionVec.empty()) {
		// add intersections for all levels >= level...
		for (int sphere_level = max(level,1); sphere_level <= level_max; ++sphere_level) {
		  if (mixedSphereCount[sphere_level-1] > 0) {
		    assert(mixedSphereAdt[sphere_level-1] != NULL);
		    assert(mixedSpherePtr[sphere_level-1] != NULL);
		    surface->addXpIntersections(xpIntersectionVec,j,k,mixedSphereAdt[sphere_level-1],mixedSpherePtr[sphere_level-1],sphere_level,dxp); // dxp needed for conversion back to real
		  }
		}
		for (int tri_level = max(level,1); tri_level <= level_max; ++tri_level) {
		  if (mixedTriCount[tri_level-1] > 0) {
		    assert(mixedTriAdt[tri_level-1] != NULL);
		    assert(mixedTriPtr[tri_level-1] != NULL);
		    surface->addXpIntersections(xpIntersectionVec,j,k,mixedTriAdt[tri_level-1],mixedTriPtr[tri_level-1],tri_level);
		  }
		}
		for (int bst_level = max(level,1); bst_level <= level_max; ++bst_level) {
		  if (bloatedSurfaceTriCount[bst_level-1] > 0) {
		    assert(bloatedSurfaceTriAdt[bst_level-1] != NULL);
		    assert(bloatedSurfaceTriPtr[bst_level-1] != NULL);
		    surface->addXpIntersections(xpIntersectionVec,j,k,bloatedSurfaceTriAdt[bst_level-1],bloatedSurfaceTriPtr[bst_level-1],bst_level,hcp_x0,dxp); // hcp_x0 and dxp needed for conversion back to real
		  }
		}
		// sort along xp...
		sort(xpIntersectionVec.begin(),xpIntersectionVec.end());
		// process intersections...
		int level_count[level_max+1];
		for (int ilevel = 0; ilevel <= level_max; ++ilevel)
		  level_count[ilevel] = 0;
		double xp_end = 0.0;
		for (int ii = 0; ii < xpIntersectionVec.size(); ++ii) {
		  const double xp_start = xp_end;
		  xp_end = xpIntersectionVec[ii].xp;
		  // add points in this gap as appropriate...
		  // to start, find the highest level where we have a positive count...
		  int ilevel;
		  for (ilevel = level_max; ilevel > 0; --ilevel)
		    if (level_count[ilevel] > 0)
		      break;
		  if ((level_count[0] > 0)&&(ilevel >= level)) {
		    int i0 = int( ( (xp_start - hcp_x0[0] + offset_factor*double(j-k)/(dxp*sqrt(3.0)))*(dxp*grid_factor) ) );
		    if (i0%2 == 0) {
		      if (i0<0)
			i0 += 1;
		      else
			i0 += 1;
		    }
		    int i1 = int( ( (xp_end - hcp_x0[0] + offset_factor*double(j-k)/(dxp*sqrt(3.0)))*(dxp*grid_factor) ) );
		    if (i1%2 == 0) i1 += 1;
		    assert(i1 >= i0);
		    // now build the imin/imax values for this level...
		    const int di = (1<<(Nbase-ilevel));
		    const int imin = ( i0 < 0 ? i0-(i0%di) : i0-(i0%di)+di );  assert(imin > i0);
		    const int imax = ( i1 < 0 ? i1-(i1%di)-di : i1-(i1%di) );  assert(imax < i1);
		    assert(imin%di == 0);
		    assert(imax%di == 0);
		    for (int i = imin; i <= imax; i += di) {
		      double xp[3];
		      xp[0] = hcp_x0[0] - offset_factor*double(j-k)/(dxp*sqrt(3.0)) + double(i)/(dxp*grid_factor);
		      xp[1] = hcp_x0[1] + double(j)/dxp;
		      xp[2] = hcp_x0[2] + double(k)/dxp;
		      // HACK -- convert back from xp eventually...
		      vertexVec.push_back(VoronoiVertex(xp,hcpDelta/pow(2.0,ilevel)*1.5,ilevel));
		    }
		  }
		  // and update the level count...
		  assert(xpIntersectionVec[ii].level <= level_max);
		  level_count[xpIntersectionVec[ii].level] += xpIntersectionVec[ii].sign;
		}
		// check that level_count has been returned to 0...
		for (int ilevel = 0; ilevel <= level_max; ++ilevel) {
		  if (!(level_count[ilevel] == 0))
		    cout << "warning: got level_count[" << ilevel << "] = " << level_count[ilevel] << " for j,k: " << j << " " << k << endl;
		  assert(level_count[ilevel] == 0);
		}
		// and clear the vec for the next ray...
		xpIntersectionVec.clear();
	      }
	    }
	    // update the cycle int...
	    ++cycle;
	    if (cycle == mpi_size)
	      cycle = 0;
	  }
	}
      }

      if (mpi_rank == 0)
	cout << "OK" << endl;

      // DEBUG
      //throw(0);

    }

    // clean up...

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      if (mixedSphereCount[level-1] > 0) {
	assert(mixedSpherePtr[level-1] != NULL);
	CTI_Munmap(mixedSpherePtr[level-1],mixedSphereCount[level-1]);
	assert(mixedSphereAdt[level-1] != NULL);
	delete mixedSphereAdt[level-1];
      }
      else {
	assert(mixedSpherePtr[level-1] == NULL);
	assert(mixedSphereAdt[level-1] == NULL);
      }
      if (mixedTriCount[level-1] > 0) {
	assert(mixedTriPtr[level-1] != NULL);
	CTI_Munmap(mixedTriPtr[level-1],mixedTriCount[level-1]);
	assert(mixedTriAdt[level-1] != NULL);
	delete mixedTriAdt[level-1];
      }
      else {
	assert(mixedTriPtr[level-1] == NULL);
	assert(mixedTriAdt[level-1] == NULL);
      }
      if (bloatedSurfaceTriCount[level-1] > 0) {
	assert(bloatedSurfaceTriPtr[level-1] != NULL);
	CTI_Munmap(bloatedSurfaceTriPtr[level-1],bloatedSurfaceTriCount[level-1]);
	assert(bloatedSurfaceTriAdt[level-1] != NULL);
	delete bloatedSurfaceTriAdt[level-1];
      }
      else {
	assert(bloatedSurfaceTriPtr[level-1] == NULL);
	assert(bloatedSurfaceTriAdt[level-1] == NULL);
      }
    }

    CTI_Munmap(mixedTriVec,surface->nst);
    // adt clears itself...

    assert(points == NULL);
    points = new Points();

    // finally, all mesh routines must set the global count...
    assert( vertexVec.size() < TWO_BILLION );
    points->np = vertexVec.size();

    assert(points->np_global == -1);
    int8 np_int8 = (int8)points->np;
    MPI_Allreduce(&np_int8,&(points->np_global),1,MPI_INT8,MPI_SUM,mpi_comm);

    if (mpi_rank == 0)
      cout << " > total hcp point count: " << points->getNpGlobal() << endl;

    assert(points->xp == NULL);
    points->xp = new double[points->np][3];
    assert(points->delta == NULL);
    points->delta = new double[points->np];
    for (int ip = 0; ip < points->np; ++ip) {
      FOR_I3 points->xp[ip][i] = vertexVec[ip].x[i];
      points->delta[ip]        = vertexVec[ip].delta;
    }

  }


	

	
	token = part_param->getString(iarg++);
	if (token == "SPHERE") {
	  // ========================================================
	  // HCP_WINDOW SPHERE <x> <y> <z> <r> LEVEL=<l> [DXOUT=<dx>]
	  // ========================================================
	  SphereHcpWindow * window = new SphereHcpWindow();
	  hcpWindowVec.push_back(window);
	  window->x[0]  = part_param->getDouble(iarg++);
	  window->x[1]  = part_param->getDouble(iarg++);
	  window->x[2]  = part_param->getDouble(iarg++);
	  window->r     = part_param->getDouble(iarg++);
	  assert(part_param->getString(iarg++) == "LEVEL");
	  window->level = part_param->getInt(iarg++);
	  assert((window->level >= 1)&&(window->level <= HCP_LEVEL_MAX));
	  if (iarg < part_param->size()) {
	    if (part_param->getString(iarg) == "DXOUT") {
	      ++iarg;
	      window->dxout = part_param->getDouble(iarg++);
	    }
	    else if (part_param->getString(iarg) == "NLAYERS") {
	      // make sure we have HCP_DELTA...
	      if (hcpDelta == 0.0) {
		CERR("please specify HCP_DELTA before HCP_WINDOW tokens in PART " << name);
	      }
	      ++iarg;
	      const int nlayers = part_param->getInt(iarg++);
	      double window_r = window->r; 
	      for (int level = window->level-1; level >= 1; --level) {
		SphereHcpWindow * window2 = new SphereHcpWindow();
		hcpWindowVec.push_back(window2);
		window2->level = level;
		window2->x[0]  = window->x[0];
		window2->x[1]  = window->x[1];
		window2->x[2]  = window->x[2];
		window_r += hcpDelta*nlayers/pow(2.0,level);
		window2->r     = window_r;
	      }
	    }
	  }
	}
	else if (token == "BOX") {
	  // ========================================================
	  // HCP_WINDOW BOX <x0> <x1> <y0> <y1> <z0> <z1> LEVEL=<l> [DXOUT=<dx>]
	  // ========================================================
	  BoxHcpWindow * window = new BoxHcpWindow();
	  hcpWindowVec.push_back(window);
	  window->x0[0]  = part_param->getDouble(iarg++);
	  window->x1[0]  = part_param->getDouble(iarg++);
	  window->x0[1]  = part_param->getDouble(iarg++);
	  window->x1[1]  = part_param->getDouble(iarg++);
	  window->x0[2]  = part_param->getDouble(iarg++);
	  window->x1[2]  = part_param->getDouble(iarg++);
	  assert(part_param->getString(iarg++) == "LEVEL");
	  window->level = part_param->getInt(iarg++);
	  assert((window->level >= 1)&&(window->level <= HCP_LEVEL_MAX));
	  if ((iarg < part_param->size())&&(part_param->getString(iarg) == "DXOUT")) {
	    ++iarg;
	    window->dxout = part_param->getDouble(iarg++);
	  }
	}
	else if (token == "TCONE") {
	  // ========================================================
	  // HCP_WINDOW TCONE <x0> <y0> <z0> <r0> <x1> <y1> <z1> <r1> LEVEL=<l> [DXOUT=<dx>]
	  // ========================================================
	  TConeHcpWindow * window = new TConeHcpWindow();
	  hcpWindowVec.push_back(window);
	  window->x0[0] = part_param->getDouble(iarg++);
	  window->x0[1] = part_param->getDouble(iarg++);
	  window->x0[2] = part_param->getDouble(iarg++);
	  window->r0 = part_param->getDouble(iarg++);
	  window->x1[0] = part_param->getDouble(iarg++);
	  window->x1[1] = part_param->getDouble(iarg++);
	  window->x1[2] = part_param->getDouble(iarg++);
	  window->r1 = part_param->getDouble(iarg++);
	  //if radius of zero specied, adjust so has small finite value
	  window->r0 = max(1.0e-8,window->r0);
	  window->r1 = max(1.0e-8,window->r1);
	  assert(part_param->getString(iarg++) == "LEVEL");
	  window->level = part_param->getInt(iarg++);
	  assert((window->level >= 1)&&(window->level <= HCP_LEVEL_MAX));
	  if ((iarg < part_param->size())&&(part_param->getString(iarg) == "DXOUT")) {
	    ++iarg;
	    window->dxout = part_param->getDouble(iarg++);
	  }
	}
	else if (token == "FAZONE") {
	  // ==========================================================================
	  // HCP_WINDOW FAZONE <zone1> [<zone2> ...] LEVEL=<l> NLAYERS=<n> [DXOUT=<dx>]
	  // ==========================================================================
	  assert(hcpDelta > 0.0);
	  FazoneHcpWindow * window = new FazoneHcpWindow(surface,hcpDelta);
	  hcpWindowVec.push_back(window);
	  token = part_param->getString(iarg++);
	  assert(token != "LEVEL");
	  while (token != "LEVEL") {
	    // must be a zone...
	    window->addFazone(token);
	    token = part_param->getString(iarg++);
	  }
	  window->level = part_param->getInt(iarg++);
	  assert((window->level >= 1)&&(window->level <= HCP_LEVEL_MAX));
	  assert(part_param->getString(iarg++) == "NLAYERS");
	  window->nlayers = part_param->getInt(iarg++);
	  if ((iarg < part_param->size())&&(part_param->getString(iarg) == "DXOUT")) {
	    ++iarg;
	    window->dxout = part_param->getDouble(iarg++);
	  }
	}
	else {
	  CERR("unrecognized HCP_WINDOW token: " << token);
	}





// =================================================================================
// =================================================================================
// =================================================================================

#ifdef JUNKJUNKJUNK

#define HCP_BIT_MAX 28  // do not go above 30
#define HCP_LEVEL_MAX 24

// ============================================================
// HcpWindows add mixed spheres and tris (mixed in the sense that
// they contain both real and integer data) to the passed arrays
// to support hcp point insertion.
// ============================================================

class HcpWindow {
public:
  virtual ~HcpWindow() {}
  virtual void addElements(vector<Surface::MixedSphere> *&mixedSphereVecArray,vector<Surface::MixedTri> *&mixedTriVecArray,const double xp0[3],const double dxp) = 0;
  virtual void printInfo() const = 0;
};

class SphereHcpWindow : public HcpWindow {
public:
  double x[3],r,dxout;
  int level;
  SphereHcpWindow() {
    dxout = 0.0;
  }
  void addElements(vector<Surface::MixedSphere> *&mixedSphereVecArray,vector<Surface::MixedTri> *&mixedTriVecArray,const double xp0[3],const double dxp) {
    assert((level >= 1)&&(level <= HCP_LEVEL_MAX));
    const int isp = mixedSphereVecArray[level-1].size();
    mixedSphereVecArray[level-1].resize(isp+1);
    mixedSphereVecArray[level-1][isp].init(x,r,dxout,xp0,dxp);
  }
  void printInfo() const {
    if (mpi_rank == 0) {
      cout << " > SPHERE center: " << x[0] << " " << x[1] << " " << x[2];
      cout << " radius: " <<  r << " level: " << level;
      if (dxout != 0.0) cout << " dxout: " << dxout;
      cout << endl;
    }
  }
};


class BoxHcpWindow : public HcpWindow {
public:
  double x0[3],x1[3],dxout;
  int level;
  BoxHcpWindow() {
    dxout = 0.0;
  }
  void addElements(vector<Surface::MixedSphere> *&mixedSphereVecArray,vector<Surface::MixedTri> *&mixedTriVecArray,const double xp0[3],const double dxp) {
    assert((level >= 1)&&(level <= HCP_LEVEL_MAX));
    // build the corners of the box...
    const double x000[3] = { x0[0], x0[1], x0[2] };
    const double x001[3] = { x0[0], x0[1], x1[2] };
    const double x010[3] = { x0[0], x1[1], x0[2] };
    const double x011[3] = { x0[0], x1[1], x1[2] };
    const double x100[3] = { x1[0], x0[1], x0[2] };
    const double x101[3] = { x1[0], x0[1], x1[2] };
    const double x110[3] = { x1[0], x1[1], x0[2] };
    const double x111[3] = { x1[0], x1[1], x1[2] };

    int imt = mixedTriVecArray[level-1].size();
    mixedTriVecArray[level-1].resize(imt+12);
    mixedTriVecArray[level-1][imt++].init(x000,x001,x011,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x000,x011,x010,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x000,x100,x101,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x000,x101,x001,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x001,x101,x111,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x001,x111,x011,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x011,x111,x110,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x011,x110,x010,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x000,x010,x110,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x000,x110,x100,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x100,x110,x111,xp0,dxp);
    mixedTriVecArray[level-1][imt++].init(x100,x111,x101,xp0,dxp);
    assert(imt == mixedTriVecArray[level-1].size());
  }
  void printInfo() const {
    if (mpi_rank == 0) {
      cout << " level: " << level;
      if (dxout != 0.0) cout << " dxout: " << dxout;
      cout << endl;
    }
  }
};

class TConeHcpWindow : public HcpWindow {
public:
  double x0[3],x1[3],r0,r1,dxout;
  double axis[3];
  int level;
  TConeHcpWindow() {
    dxout = 0.0;
  }
  void addElements(vector<Surface::MixedSphere> *&mixedSphereVecArray,vector<Surface::MixedTri> *&mixedTriVecArray,const double xp0[3],const double dxp) {
    assert((level >= 1)&&(level <= HCP_LEVEL_MAX));

    // build the corners of the box...
    const int n = 48; // how many segments?
    int imt = mixedTriVecArray[level-1].size();
    mixedTriVecArray[level-1].resize(imt+4*n);
    FOR_I3 { axis[i] = x1[i] - x0[i]; };
    int dir1Index = 0;
    if ( ( std::abs(axis[1]) <= std::abs(axis[0]) ) && ( std::abs(axis[1]) <= std::abs(axis[2]) ) ) {
      dir1Index = 1;
    }
    if ( ( std::abs(axis[2]) <= std::abs(axis[0]) ) && ( std::abs(axis[2]) <= std::abs(axis[1]) ) ) {
      dir1Index = 2;
    }
    double dir1[3];
    if ( dir1Index == 0 ) { dir1[0] = 1.0; dir1[1] = 0.0; dir1[2] = 0.0; };
    if ( dir1Index == 1 ) { dir1[0] = 0.0; dir1[1] = 1.0; dir1[2] = 0.0; };
    if ( dir1Index == 2 ) { dir1[0] = 0.0; dir1[1] = 0.0; dir1[2] = 1.0; };
    double radDir1[3] = CROSS_PRODUCT( axis , dir1 );
    double mag = DOT_PRODUCT( radDir1 , radDir1 );
    FOR_I3 { radDir1[i] /= sqrt( mag ); };
    double radDir2[3] = CROSS_PRODUCT( radDir1 , axis );
    mag = DOT_PRODUCT( radDir2 , radDir2 );
    FOR_I3 { radDir2[i] /= - sqrt( mag ); };
    double theta1 = double(n)/double(n)*2.0*M_PI;
    for (int i = 0; i < n; ++i) {
      const double theta0 = theta1;
      theta1 = double(i+1)/double(n)*2.0*M_PI;
      double x0t0[3];
      FOR_J3 {
	x0t0[j] = x0[j] + r0 * radDir1[j] * cos(theta0) + r0 * radDir2[j] * sin(theta0);
      }
      double x0t1[3];
      FOR_J3 {
	x0t1[j] = x0[j] + r0 * radDir1[j] * cos(theta1) + r0 * radDir2[j] * sin(theta1);
      };
      double x1t0[3];
      FOR_J3 {
	x1t0[j] = x1[j] + r1 * radDir1[j] * cos(theta0) + r1 * radDir2[j] * sin(theta0);
      };
      double x1t1[3];
      FOR_J3 {
	x1t1[j] = x1[j] + r1 * radDir1[j] * cos(theta1) + r1 * radDir2[j] * sin(theta1);
      }
      mixedTriVecArray[level-1][imt++].init(x0 ,x0t1,x0t0,xp0,dxp);
      mixedTriVecArray[level-1][imt++].init(x0t1,x1t1,x1t0,xp0,dxp);
      mixedTriVecArray[level-1][imt++].init(x0t1,x1t0,x0t0,xp0,dxp);
      mixedTriVecArray[level-1][imt++].init(x1 ,x1t0,x1t1,xp0,dxp);
    }
    assert(imt == mixedTriVecArray[level-1].size());
  }
  void printInfo() const {
    if (mpi_rank == 0) {
      cout << "> TCONE axis = " << COUT_VEC( axis ) << endl;
      cout << " level: " << level;
      if (dxout != 0.0) cout << " dxout: " << dxout;
      cout << endl;
    }
  }
};

class FazoneHcpWindow : public HcpWindow {
public:
  Surface ** surface_ptr;
  double hcpDelta;
  double dxout;
  int nlayers,level;
  vector<string> nameVec;
  FazoneHcpWindow(Surface *&surface,const double hcpDelta) {
    assert(0); // get rid of this eventually -- too expensive when lots of spheres are used
    assert(surface == NULL);
    surface_ptr = &surface;
    this->hcpDelta = hcpDelta;
    dxout = 0.0;
  }
  void addFazone(const string& name) {
    if (mpi_rank == 0)
      cout << "addFazone \"" << name << "\"" << endl;
    nameVec.push_back(name);
  }
  void addElements(vector<Surface::MixedSphere> *&mixedSphereVecArray,vector<Surface::MixedTri> *&mixedTriVecArray,const double xp0[3],const double dxp) {
    assert((*surface_ptr) != NULL);
    // the zone_flag has 1 for each named zone...
    int zone_flag[(*surface_ptr)->zoneVec.size()];
    for (int izone = 0; izone < (*surface_ptr)->zoneVec.size(); ++izone)
      zone_flag[izone] = 0;
    for (int ii = 0; ii < nameVec.size(); ++ii) {
      if (nameVec[ii] == "ALL") {
	// flag ALL boundary zones of the surface...
	for (int izone = 0; izone < (*surface_ptr)->zoneVec.size(); ++izone)
	  if ((*surface_ptr)->zoneVec[izone].isBoundary())
	    zone_flag[izone] = 1;
      }
      else {
	// could use a map here, but the number of zones is normally small...
	int izone;
	for (izone = 0; izone < (*surface_ptr)->zoneVec.size(); ++izone) {
	  if ((*surface_ptr)->zoneVec[izone].getName() == nameVec[ii]) {
	    zone_flag[izone] = 1;
	    break;
	  }
	}
	if (izone == (*surface_ptr)->zoneVec.size()) {
	  if (mpi_rank == 0) {
	    cout << "FazoneHcpWindow::addElements: cannot find zone named \"" << nameVec[ii] << "\"\nValid fazone names are:" << endl;
	    for (izone = 0; izone < (*surface_ptr)->zoneVec.size(); ++izone)
	      cout << " > " << (*surface_ptr)->zoneVec[izone].getName() << endl;
	  }
	  //throw(0);
	}
      }
    }
    
    //MPI_Pause("OKOKOKOKO");
    
    // use a flag at the surface points to make sure we only do each tri corner once...
    int * sp_flag = new int[(*surface_ptr)->nsp];
    // nest layers...
    double factor;
    if (Param *param = getParam("HCP_FAZONE_FACTOR"))
      factor = param->getDouble();
    else
      factor = 0.4;
    for (int this_level = 1; this_level <= level; ++this_level) {
      const double delta = hcpDelta*double(nlayers)/double(1<<this_level);
      // cycle through ALL tris and put a sphere in each...
      for (int isp = 0; isp < (*surface_ptr)->nsp; ++isp)
	sp_flag[isp] = 0;
      for (int ist = 0; ist < (*surface_ptr)->nst; ++ist) {
	if (zone_flag[(*surface_ptr)->znost[ist]]) {
	  // XXXXX revisit this later -- it introduces more spheres than necessary...
	  const int isp0 = (*surface_ptr)->spost[ist][0];
	  const int isp1 = (*surface_ptr)->spost[ist][1];
	  const int isp2 = (*surface_ptr)->spost[ist][2];
	  double d2_max = DIST2((*surface_ptr)->xp[isp0],(*surface_ptr)->xp[isp1]);
	  d2_max = max(d2_max,DIST2((*surface_ptr)->xp[isp1],(*surface_ptr)->xp[isp2]));
	  d2_max = max(d2_max,DIST2((*surface_ptr)->xp[isp2],(*surface_ptr)->xp[isp0]));
	  if (d2_max > factor*factor*delta*delta) {
	    // populate the tri with many sphere...
	    //cout << "XXXXX: " << surfacePointVec[isp2].x[0] << " " << surfacePointVec[isp2].x[1] << " " << surfacePointVec[isp2].x[2] << " " << delta << endl;
	    //cout << "XXXXX: " << surfacePointVec[isp0].x[0] << " " << surfacePointVec[isp0].x[1] << " " << surfacePointVec[isp0].x[2] << " " << delta << endl;
	    //cout << "XXXXX: " << surfacePointVec[isp1].x[0] << " " << surfacePointVec[isp1].x[1] << " " << surfacePointVec[isp1].x[2] << " " << delta << endl;
	    //cout << "XXXXX: " << surfacePointVec[isp2].x[0] << " " << surfacePointVec[isp2].x[1] << " " << surfacePointVec[isp2].x[2] << " " << delta << endl;
	    const int n = int(sqrt(d2_max)/(factor*delta))+1;
	    for (int i = 0; i <= 2*n; i += 1) {
	      const double wgt0 = double(i)/double(2*n);
	      for (int j = 0; j <= 2*n-i; j += 1) {
		const double wgt1 = double(j)/double(2*n);
		double xp[3];
		FOR_K3 xp[k] = wgt0*(*surface_ptr)->xp[isp0][k] + wgt1*(*surface_ptr)->xp[isp1][k] + (1.0-wgt0-wgt1)*(*surface_ptr)->xp[isp2][k];
		const int ims = mixedSphereVecArray[this_level-1].size(); // for the spheres, use this_level-1 as the index (no this_level-zero spheres)...
		mixedSphereVecArray[this_level-1].resize(ims+1);
		mixedSphereVecArray[this_level-1][ims].init(xp,delta,dxout,xp0,dxp);
	      }
	    }
	  }
	  else {
	    // just do the corners, some of which may already be done...
	    FOR_I3 {
	      const int isp = (*surface_ptr)->spost[ist][i];
	      if (sp_flag[isp] == 0) {
		sp_flag[isp] = 1;
		const int ims = mixedSphereVecArray[this_level-1].size(); // for the spheres, use this_level-1 as the index (no this_level-zero spheres)...
		mixedSphereVecArray[this_level-1].resize(ims+1);
		mixedSphereVecArray[this_level-1][ims].init((*surface_ptr)->xp[isp],delta,dxout,xp0,dxp);
	      }
	    }
	  }
	}
      }
    }
    delete[] sp_flag;
  }
  void printInfo() const {
    if (mpi_rank == 0) {
      cout << " > FAZONE zones:";
      for (int i = 0; i<nameVec.size(); i++) {
	cout << " " << nameVec[i];
      }
      cout << " level: " << level;
      cout << " layers: " << nlayers;
      if (dxout != 0.0) cout << " dxout: " << dxout;
      cout << endl;
    }
  }
};

#endif

// =================================================================================
// =================================================================================
// =================================================================================
























#ifdef JUNK



// do a FAZONE_GROUP check...

FOR_PARAM_MATCHING("FAZONE_GROUP") {
  COUT1("checking FAZONE_GROUP: " << param->getString());
  int iarg;
  for (int iarg = 1; iarg < param->size(); ++iarg) {
    const string zonename = param->getString(iarg);
    COUT1(" > " << zonename);
    int izone;
    for (izone = 0; izone < surface->zoneVec.size(); ++izone) {
      if (surface->zoneVec[izone].getName() == zonename) {
	break;
      }
    }
    if (izone == surface->zoneVec.size())
      CERR("FAZONE_GROUP " << param->getString() << " contains unknown zone: " << zonename);
  }
}


















case SPHERE_HCP_WINDOW:
{
  assert((window->level >= 1)&&(window->level <= HCP_LEVEL_MAX));
  mixedSphereCount[window->level-1] += 1; // for the spheres, use level-1 as the index (no level-zero spheres)...
  const int isp = mixedSphereVecArray[window->level-1].size();
  mixedSphereVecArray[level-1].resize(isp+1);
  mixedSphereVecArray[level-1][isp].x     = window->x[0];
  mixedSphereVecArray[level-1][isp].dxout = window->dxout;
  mixedSphereVecArray[level-1][isp].j     = int( (xp[1] - xp0[1])*dxp ); // odd or even -- does not matter
  mixedSphereVecArray[level-1][isp].k     = int( (xp[2] - xp0[2])*dxp );
  mixedSphereVecArray[level-1][isp].r     = int( r*dxp );
}
break;

case
 else if (name == "SURFACE") {
   // ===========================================================================
   // HCP_WINDOW SURFACE FAZONE <name1> [<name2...>] LEVEL=<l> N=<n> [DXOUT=<dx>]
   // ===========================================================================
   int this_level = -1;
   int n = -1; // number of layers
   //double delta = -1.0;
   double dxout = 0.0;
   bool fazone_mode = false;
   bool fazone_group_mode = false;
   int zone_flag[surface->zoneVec.size()];
   for (int izone = 0; izone < surface->zoneVec.size(); ++izone)
     zone_flag[izone] = 0;
   int iarg = 1;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       assert(this_level == -1);
       this_level = param->getInt(iarg++);
       fazone_mode = false;
       fazone_group_mode = false;
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
       fazone_mode = false;
       fazone_group_mode = false;
     }
     else if (token == "N") {
       // the user has requested n layers...
       assert(n == -1);
       n = param->getInt(iarg++);
       assert(n >= 1);
       fazone_mode = false;
       fazone_group_mode = false;
     }
     else if (token == "DELTA") {
       // the user has requested a target length scale...
       const double delta = param->getDouble(iarg++);
       assert(this_level == -1);
       this_level = 0;
       while (hcpDelta/double(1<<this_level) > delta)
	 ++this_level;
       fazone_mode = false;
       fazone_group_mode = false;
     }
     else if (token == "FAZONE") {
       // assume this is a zone name...
       fazone_mode = true;
       fazone_group_mode = false;
     }
     else if (token == "FAZONE_GROUP") {
       // assume this is a zone name...
       fazone_group_mode = true;
       fazone_mode = false;
     }
     else if (fazone_mode) {
       if (token == "ALL") {
	 for (int izone = 0; izone < surface->zoneVec.size(); ++izone)
	   zone_flag[izone] = 1;
       }
       else {
	 int izone;
	 for (izone = 0; izone < surface->zoneVec.size(); ++izone) {
	   if (surface->zoneVec[izone].getName() == token) {
	     zone_flag[izone] = 1;
	     break;
	   }
	 }
	 if (izone == surface->zoneVec.size()) {
	   COUT1("Available face zones ");
	   for (izone = 0; izone < surface->zoneVec.size(); ++izone) {
	     COUT1(" -- " << surface->zoneVec[izone].getName());
	   }
	   COUT1("HCP_WINDOW SURFACE: did not find FAZONE with name: " << token << " - skipping");
	 }
       }
     }
     else if (fazone_group_mode) {
       FOR_PARAM_MATCHING("FAZONE_GROUP") {
	 if (token == param->getString(0)) {
	   for (int iarg = 1; iarg < param->size(); ++iarg) {
	     const string zonename = param->getString(iarg);
	     int izone;
	     for (izone = 0; izone < surface->zoneVec.size(); ++izone) {
	       if (surface->zoneVec[izone].getName() == zonename) {
		 zone_flag[izone] = 1;
		 break;
	       }
	     }
	     if (izone == surface->zoneVec.size())
	       COUT1("FAZONE_GROUP " << token << " contains unknown zone: " << zonename << " - skipping");
	   }
	 }
       }
     }
     else {
       CERR("unrecognized SURFACE token: " << token);
     }
   }
   if (!((this_level >= 0)&&(this_level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW SURFACE: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   if (n == -1)
     CERR("HCP_WINDOW SURFACE: missing valid number of layers N");
   // nest layers...
   const double factor = 0.4; // how far apart spheres can be before other spheres are introduced...
   for (int level = 1; level <= this_level; ++level) {
     const double delta = hcpDelta*double(n)/double(1<<level);
     // cycle through ALL tris and put a sphere in each...
     for (int isp = 0; isp < surface->nsp; ++isp)
       sp_flag[isp] = 0;
     for (int ist = 0; ist < surface->nst; ++ist) {
       if (zone_flag[surface->znost[ist]]) {
	 // XXXXX revisit this later -- it introduces more spheres than necessary...
	 const int isp0 = surface->spost[ist][0];
	 const int isp1 = surface->spost[ist][1];
	 const int isp2 = surface->spost[ist][2];
	 double d2_max = DIST2(surface->xp[isp0],surface->xp[isp1]);
	 d2_max = max(d2_max,DIST2(surface->xp[isp1],surface->xp[isp2]));
	 d2_max = max(d2_max,DIST2(surface->xp[isp2],surface->xp[isp0]));
	 if (d2_max > factor*factor*delta*delta) {
	   // populate the tri with many sphere...
	   //cout << "XXXXX: " << surfacePointVec[isp2].x[0] << " " << surfacePointVec[isp2].x[1] << " " << surfacePointVec[isp2].x[2] << " " << delta << endl;
	   //cout << "XXXXX: " << surfacePointVec[isp0].x[0] << " " << surfacePointVec[isp0].x[1] << " " << surfacePointVec[isp0].x[2] << " " << delta << endl;
	   //cout << "XXXXX: " << surfacePointVec[isp1].x[0] << " " << surfacePointVec[isp1].x[1] << " " << surfacePointVec[isp1].x[2] << " " << delta << endl;
	   //cout << "XXXXX: " << surfacePointVec[isp2].x[0] << " " << surfacePointVec[isp2].x[1] << " " << surfacePointVec[isp2].x[2] << " " << delta << endl;
	   const int n = int(sqrt(d2_max)/(factor*delta))+1;
	   for (int i = 0; i <= 2*n; i += 1) {
	     const double wgt0 = double(i)/double(2*n);
	     for (int j = 0; j <= 2*n-i; j += 1) {
	       const double wgt1 = double(j)/double(2*n);
	       //cout << " wgt0: " << wgt0 << " wgt1: " << wgt1 << " 1-wgt-wgt1: " << 1.0-wgt0-wgt1 << endl;
	       double xp[3];
	       FOR_K3 xp[k] = wgt0*surface->xp[isp0][k] + wgt1*surface->xp[isp1][k] + (1.0-wgt0-wgt1)*surface->xp[isp2][k];
	       //cout << "XXXXX: " << xp[0] << " " << xp[1] << " " << xp[2] << " " << delta << " " << level << endl;
	       mixedSphereCount[level-1] += 1;
	       const int ims = mixedSphereVecArray[level-1].size(); // for the spheres, use level-1 as the index (no level-zero spheres)...
	       mixedSphereVecArray[level-1].resize(ims+1);
	       mixedSphereVecArray[level-1][ims].x     = xp[0];
	       mixedSphereVecArray[level-1][ims].dxout = dxout;
	       mixedSphereVecArray[level-1][ims].j     = int( (xp[1] - xp0[1])*dxp ); // odd or even -- does not matter
	       mixedSphereVecArray[level-1][ims].k     = int( (xp[2] - xp0[2])*dxp );
	       mixedSphereVecArray[level-1][ims].r     = int( delta*dxp );
	     }
	   }
	 }
	 else {
	   // just do the corners, some of which may already be done...
	   FOR_I3 {
	     const int isp = surface->spost[ist][i];
	     if (sp_flag[isp] == 0) {
	       sp_flag[isp] = 1;
	       mixedSphereCount[level-1] += 1;
	       const int ims = mixedSphereVecArray[level-1].size(); // for the spheres, use level-1 as the index (no level-zero spheres)...
	       mixedSphereVecArray[level-1].resize(ims+1);
	       mixedSphereVecArray[level-1][ims].x     = surface->xp[isp][0];
	       mixedSphereVecArray[level-1][ims].dxout = dxout;
	       mixedSphereVecArray[level-1][ims].j     = int( (surface->xp[isp][1] - xp0[1])*dxp ); // odd or even -- does not matter
	       mixedSphereVecArray[level-1][ims].k     = int( (surface->xp[isp][2] - xp0[2])*dxp );
	       mixedSphereVecArray[level-1][ims].r     = int( delta*dxp );
	     }
	   }
	 }
       }
     }
   }
 }







 else if (name == "RECT_X") {
   // ========================================================
   // HCP_WINDOW RECT_X <x0> <Ly0> <Lz0> <x1> <Ly1> <Lz1> LEVEL=<l> [DXOUT=<dx>]
   // ========================================================
   int iarg = 1;
   const double x0 = param->getDouble(iarg++);
   const double Ly0 = param->getDouble(iarg++);
   const double Lz0 = param->getDouble(iarg++);
   const double x1 = param->getDouble(iarg++);
   const double Ly1 = param->getDouble(iarg++);
   const double Lz1 = param->getDouble(iarg++);
   int level = -1;
   double dxout = 0.0;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       level = param->getInt(iarg++);
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
     }
     else {
       CERR("unrecognized RECT_X token: " << token);
     }
   }
   if (!((level >= 1)&&(level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW RECT_X: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   // build the corners of the box...
   const double x000[3] = { x0, -0.5*Ly0, -0.5*Lz0 };
   const double x001[3] = { x0, -0.5*Ly0, 0.5*Lz0 };
   const double x010[3] = { x0, 0.5*Ly0, -0.5*Lz0 };
   const double x011[3] = { x0, 0.5*Ly0, 0.5*Lz0 };
   const double x100[3] = { x1, -0.5*Ly1, -0.5*Lz1 };
   const double x101[3] = { x1, -0.5*Ly1, 0.5*Lz1 };
   const double x110[3] = { x1, 0.5*Ly1, -0.5*Lz1 };
   const double x111[3] = { x1, 0.5*Ly1, 0.5*Lz1 };
   // add 12 tris describing a box...
   mixedTriCount[level-1] += 12; // for the tris, use level-1 as the index (no level-zero tris in windows)...
   int imt = mixedTriVecArray[level-1].size();
   mixedTriVecArray[level-1].resize(imt+12);
   mixedTriVecArray[level-1][imt++].init(x000,x001,x011,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x011,x010,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x100,x101,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x101,x001,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x001,x101,x111,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x001,x111,x011,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x011,x111,x110,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x011,x110,x010,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x010,x110,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x110,x100,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x100,x110,x111,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x100,x111,x101,xp0,dxp);
   assert(imt == mixedTriVecArray[level-1].size());
 }
 else if (name == "BOX") {
   // ========================================================
   // HCP_WINDOW BOX <x0> <x1> <y0> <y1> <z0> <z1> LEVEL=<l> [DXOUT=<dx>]
   // ========================================================
   int iarg = 1;
   const double x0 = param->getDouble(iarg++);
   const double x1 = param->getDouble(iarg++);
   const double y0 = param->getDouble(iarg++);
   const double y1 = param->getDouble(iarg++);
   const double z0 = param->getDouble(iarg++);
   const double z1 = param->getDouble(iarg++);
   int level = -1;
   double dxout = 0.0;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       level = param->getInt(iarg++);
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
     }
     else {
       CERR("unrecognized BOX token: " << token);
     }
   }
   if (!((level >= 1)&&(level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW BOX: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   // build the corners of the box...
   const double x000[3] = { x0, y0, z0 };
   const double x001[3] = { x0, y0, z1 };
   const double x010[3] = { x0, y1, z0 };
   const double x011[3] = { x0, y1, z1 };
   const double x100[3] = { x1, y0, z0 };
   const double x101[3] = { x1, y0, z1 };
   const double x110[3] = { x1, y1, z0 };
   const double x111[3] = { x1, y1, z1 };
   // add 12 tris describing a box...
   mixedTriCount[level-1] += 12; // for the tris, use level-1 as the index (no level-zero tris in windows)...
   int imt = mixedTriVecArray[level-1].size();
   mixedTriVecArray[level-1].resize(imt+12);
   mixedTriVecArray[level-1][imt++].init(x000,x001,x011,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x011,x010,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x100,x101,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x101,x001,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x001,x101,x111,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x001,x111,x011,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x011,x111,x110,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x011,x110,x010,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x010,x110,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x000,x110,x100,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x100,x110,x111,xp0,dxp);
   mixedTriVecArray[level-1][imt++].init(x100,x111,x101,xp0,dxp);
   assert(imt == mixedTriVecArray[level-1].size());
 }
 else if (name == "TCONE_ARB") {
   // ========================================================
   // HCP_WINDOW TCONE_ARB <x0> <y0> <z0> <r0> <x1> <y1> <z1> <r1> LEVEL=<l> [DXOUT=<dx>]
   // ========================================================
   int iarg = 1;
   const double x0 = param->getDouble(iarg++);
   const double y0 = param->getDouble(iarg++);
   const double z0 = param->getDouble(iarg++);
   const double r0 = param->getDouble(iarg++);
   const double x1 = param->getDouble(iarg++);
   const double y1 = param->getDouble(iarg++);
   const double z1 = param->getDouble(iarg++);
   const double r1 = param->getDouble(iarg++);
   int level = -1;
   double dxout = 0.0;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       level = param->getInt(iarg++);
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
     }
     else {
       CERR("unrecognized TCONE_ARB token: " << token);
     }
   }
   if (!((level >= 1)&&(level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW TCONE_ARB: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   // build the corners of the box...
   const int n = 48; // how many segments?
   mixedTriCount[level-1] += 4*n; // for the tris, use level-1 as the index (no level-zero tris in windows)...
   int imt = mixedTriVecArray[level-1].size();
   mixedTriVecArray[level-1].resize(imt+4*n);
   const double xc0[3] = { x0, y0, z0 };
   const double xc1[3] = { x1, y1, z1 };
   double axis[3];
   FOR_I3 { axis[i] = xc1[i] - xc0[i]; };
   std::cout << " TCONE_ARB axis = " << COUT_VEC( axis ) << std::endl;
   int dir1Index = 0;
   if ( ( std::abs(axis[1]) <= std::abs(axis[0]) ) && ( std::abs(axis[1]) <= std::abs(axis[2]) ) ) {
     dir1Index = 1;
   }
   if ( ( std::abs(axis[2]) <= std::abs(axis[0]) ) && ( std::abs(axis[2]) <= std::abs(axis[1]) ) ) {
     dir1Index = 2;
   }
   double dir1[3];
   if ( dir1Index == 0 ) { dir1[0] = 1.0; dir1[1] = 0.0; dir1[2] = 0.0; };
   if ( dir1Index == 1 ) { dir1[0] = 0.0; dir1[1] = 1.0; dir1[2] = 0.0; };
   if ( dir1Index == 2 ) { dir1[0] = 0.0; dir1[1] = 0.0; dir1[2] = 1.0; };
   double radDir1[3] = CROSS_PRODUCT( axis , dir1 );
   double mag = DOT_PRODUCT( radDir1 , radDir1 );
   FOR_I3 { radDir1[i] /= sqrt( mag ); };
   std::cout << " TCONE_ARB rad1 = " << COUT_VEC( radDir1 ) << std::endl;
   double radDir2[3] = CROSS_PRODUCT( radDir1 , axis );
   mag = DOT_PRODUCT( radDir2 , radDir2 );
   FOR_I3 { radDir2[i] /= - sqrt( mag ); };
   std::cout << " TCONE_ARB rad2 = " << COUT_VEC( radDir2 ) << std::endl;
   double theta1 = double(n)/double(n)*2.0*M_PI;
   for (int i = 0; i < n; ++i) {
     const double theta0 = theta1;
     theta1 = double(i+1)/double(n)*2.0*M_PI;
     double x0t0[3];
     FOR_J3 {
       x0t0[j] = xc0[j] + r0 * radDir1[j] * cos(theta0) + r0 * radDir2[j] * sin(theta0);
     }
     double x0t1[3];
     FOR_J3 {
       x0t1[j] = xc0[j] + r0 * radDir1[j] * cos(theta1) + r0 * radDir2[j] * sin(theta1);
     };
     double x1t0[3];
     FOR_J3 {
       x1t0[j] = xc1[j] + r1 * radDir1[j] * cos(theta0) + r1 * radDir2[j] * sin(theta0);
     };
     double x1t1[3];
     FOR_J3 {
       x1t1[j] = xc1[j] + r1 * radDir1[j] * cos(theta1) + r1 * radDir2[j] * sin(theta1);
     }
     mixedTriVecArray[level-1][imt++].init(xc0 ,x0t1,x0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0t1,x1t1,x1t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0t1,x1t0,x0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(xc1 ,x1t0,x1t1,xp0,dxp);
   }
   assert(imt == mixedTriVecArray[level-1].size());
 }
 else if (name == "TCONE_X") {
   // ========================================================
   // HCP_WINDOW TCONE_X <x0> <r0> <x1> <r1> LEVEL=<l> [DXOUT=<dx>]
   // ========================================================
   int iarg = 1;
   const double x0 = param->getDouble(iarg++);
   const double r0 = param->getDouble(iarg++);
   const double x1 = param->getDouble(iarg++);
   const double r1 = param->getDouble(iarg++);
   int level = -1;
   double dxout = 0.0;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       level = param->getInt(iarg++);
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
     }
     else {
       CERR("unrecognized TCONE_X token: " << token);
     }
   }
   if (!((level >= 1)&&(level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW TCONE_X: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   // build the corners of the box...
   const int n = 48; // how many segments?
   mixedTriCount[level-1] += 4*n; // for the tris, use level-1 as the index (no level-zero tris in windows)...
   int imt = mixedTriVecArray[level-1].size();
   mixedTriVecArray[level-1].resize(imt+4*n);
   const double xc0[3] = { x0, 0.0, 0.0 };
   const double xc1[3] = { x1, 0.0, 0.0 };
   double theta1 = double(n)/double(n)*2.0*M_PI;
   for (int i = 0; i < n; ++i) {
     const double theta0 = theta1;
     theta1 = double(i+1)/double(n)*2.0*M_PI;
     const double x0t0[3] = { xc0[0], xc0[1]+r0*cos(theta0), xc0[2]+r0*sin(theta0) };
     const double x0t1[3] = { xc0[0], xc0[1]+r0*cos(theta1), xc0[2]+r0*sin(theta1) };
     const double x1t0[3] = { xc1[0], xc1[1]+r1*cos(theta0), xc1[2]+r1*sin(theta0) };
     const double x1t1[3] = { xc1[0], xc1[1]+r1*cos(theta1), xc1[2]+r1*sin(theta1) };
     mixedTriVecArray[level-1][imt++].init(xc0,x0t1,x0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0t1,x1t1,x1t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0t1,x1t0,x0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(xc1,x1t0,x1t1,xp0,dxp);
   }
   assert(imt == mixedTriVecArray[level-1].size());
 }
 else if (name == "TCONE_Z") {         // mod: anand kartha Jun 18 2015
   // ========================================================
   // HCP_WINDOW TCONE_Z <x0> <r0> <x1> <r1> LEVEL=<l> [DXOUT=<dx>]
   // ========================================================
   int iarg = 1;
   const double x0 = param->getDouble(iarg++);
   const double r0 = param->getDouble(iarg++);
   const double x1 = param->getDouble(iarg++);
   const double r1 = param->getDouble(iarg++);
   int level = -1;
   double dxout = 0.0;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       level = param->getInt(iarg++);
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
     }
     else {
       CERR("unrecognized TCONE_Z token: " << token);
     }
   }
   if (!((level >= 1)&&(level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW TCONE_Z: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   // build the corners of the box...
   const int n = 48; // how many segments?
   mixedTriCount[level-1] += 4*n; // for the tris, use level-1 as the index (no level-zero tris in windows)...
   int imt = mixedTriVecArray[level-1].size();
   mixedTriVecArray[level-1].resize(imt+4*n);
   const double xc0[3] = { 0.0, 0.0, x0 };
   const double xc1[3] = { 0.0, 0.0, x1 };
   double theta1 = double(n)/double(n)*2.0*M_PI;
   for (int i = 0; i < n; ++i) {
     const double theta0 = theta1;
     theta1 = double(i+1)/double(n)*2.0*M_PI;
     const double x0t0[3] = { xc0[0]+r0*cos(theta0), xc0[1]+r0*sin(theta0), xc0[2]};
     const double x0t1[3] = { xc0[0]+r0*cos(theta1), xc0[1]+r0*sin(theta1), xc0[2]};
     const double x1t0[3] = { xc1[0]+r1*cos(theta0), xc1[1]+r1*sin(theta0), xc1[2]};
     const double x1t1[3] = { xc1[0]+r1*cos(theta1), xc1[1]+r1*sin(theta1), xc1[2]};
     mixedTriVecArray[level-1][imt++].init(xc0,x0t1,x0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0t1,x1t1,x1t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0t1,x1t0,x0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(xc1,x1t0,x1t1,xp0,dxp);
   }
   assert(imt == mixedTriVecArray[level-1].size());
 }
 else if (name == "ANNULAR_TCONE_X") {
   // ========================================================
   // HCP_WINDOW ANNULAR_TCONE_X <x0> <r00> <r01> <x1> <r10> <r11> LEVEL=<l> [DXOUT=<dx>]
   // ========================================================
   int iarg = 1;
   const double x0 = param->getDouble(iarg++);
   const double r00 = param->getDouble(iarg++);
   const double r01 = param->getDouble(iarg++);
   const double x1 = param->getDouble(iarg++);
   const double r10 = param->getDouble(iarg++);
   const double r11 = param->getDouble(iarg++);
   int level = -1;
   double dxout = 0.0;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       level = param->getInt(iarg++);
     }
     else if (token == "DXOUT") {
       dxout = param->getDouble(iarg++);
     }
     else {
       CERR("unrecognized TCONE_X token: " << token);
     }
   }
   if (!((level >= 1)&&(level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW ANNULAR_TCONE_X: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);
   // build the corners of the box...
   const int n = 48; // how many segments?
   mixedTriCount[level-1] += 8*n; // for the tris, use level-1 as the index (no level-zero tris in windows)...
   int imt = mixedTriVecArray[level-1].size();
   mixedTriVecArray[level-1].resize(imt+8*n);
   const double xc0[3] = { x0, 0.0, 0.0 };
   const double xc1[3] = { x1, 0.0, 0.0 };
   double theta1 = double(n)/double(n)*2.0*M_PI;
   for (int i = 0; i < n; ++i) {
     const double theta0 = theta1;
     theta1 = double(i+1)/double(n)*2.0*M_PI;
     const double x0r0t0[3] = { xc0[0], xc0[1]+r00*cos(theta0), xc0[2]+r00*sin(theta0) };
     const double x0r0t1[3] = { xc0[0], xc0[1]+r00*cos(theta1), xc0[2]+r00*sin(theta1) };
     const double x0r1t0[3] = { xc0[0], xc0[1]+r01*cos(theta0), xc0[2]+r01*sin(theta0) };
     const double x0r1t1[3] = { xc0[0], xc0[1]+r01*cos(theta1), xc0[2]+r01*sin(theta1) };
     const double x1r0t0[3] = { xc1[0], xc1[1]+r10*cos(theta0), xc1[2]+r10*sin(theta0) };
     const double x1r0t1[3] = { xc1[0], xc1[1]+r10*cos(theta1), xc1[2]+r10*sin(theta1) };
     const double x1r1t0[3] = { xc1[0], xc1[1]+r11*cos(theta0), xc1[2]+r11*sin(theta0) };
     const double x1r1t1[3] = { xc1[0], xc1[1]+r11*cos(theta1), xc1[2]+r11*sin(theta1) };
     mixedTriVecArray[level-1][imt++].init(x0r0t1,x0r1t1,x0r1t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0r0t1,x0r1t0,x0r0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0r1t1,x1r1t1,x1r1t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0r1t1,x1r1t0,x0r1t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0r0t1,x0r0t0,x1r0t0,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x0r0t1,x1r0t0,x1r0t1,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x1r0t1,x1r1t0,x1r1t1,xp0,dxp);
     mixedTriVecArray[level-1][imt++].init(x1r0t1,x1r0t0,x1r1t0,xp0,dxp);
   }
   assert(imt == mixedTriVecArray[level-1].size());
 }
 else if (name == "SURFACE_FILE") {
   // ========================================================
   // HCP_WINDOW SURFACE_FILE <refinementType> <type> <filename> LEVEL=<l> [N=<n>]
   // ========================================================
   int iarg = 1;
   const string refType = param->getString(iarg++);
   const string surf_type = param->getString(iarg++);
   const string surf_file = param->getString(iarg++);
   double dxout = 0.0;
   int n = -1;
   int this_level = -1;
   while (iarg < param->size()) {
     const string token = param->getString(iarg++);
     if (token == "LEVEL") {
       assert(this_level == -1);
       this_level = param->getInt(iarg++);
     }
     else if (token == "N") {
       assert(n == -1);
       n = param->getInt(iarg++);
       assert(n >= 1);
     }
     else {
       CERR("unrecognized SURFACE_FILE token: " << token);
     }
   }
   if (!((this_level >= 1)&&(this_level <= HCP_LEVEL_MAX)))
     CERR("HCP_WINDOW SURFACE_FILE: missing refinement LEVEL from 1 to " << HCP_LEVEL_MAX);

   // data required on all mpi_rank_shared=0
   int nst;
   int nsp;
   double (*xp)[3]; xp = NULL;
   int (*spost)[3]; spost = NULL;

   // after init surface should be available to rank0 only - manually broadcast to shared nodes
   if (mpi_rank == 0) {
     Surface hcp_surface;

     if (surf_type == "BIN")
       hcp_surface.readBinary(surf_file,true);
     else if (surf_type == "MSH")
       hcp_surface.initFromMsh(surf_file,true);
     else if (surf_type == "STL")
       hcp_surface.initFromStl(surf_file,false,true);
     else if (surf_type == "STL_FLIP")
       hcp_surface.initFromStl(surf_file,true,true);
     else
       CERR("unsupported SURFACE_FILE type. Valid types:\n\nMSH <surface->msh>\nBIN <surface->bin>\nSTL/STL_FLIP <surface->stl>");


     nsp = hcp_surface.nsp;
     nst = hcp_surface.nst;

     spost = new int[nst][3];
     xp = new double[nsp][3];

     for (int ist = 0; ist < nst; ++ist) {
       FOR_I3 spost[ist][i] = hcp_surface.spost[ist][i];
     }

     for (int isp = 0; isp < nsp; ++isp) {
       FOR_I3 xp[isp][i] = hcp_surface.xp[isp][i];
     }
   }
   //   assert(hcp_surface.status == SHM_SURFACE);

   if (checkParam("VERBOSE")) COUT1(" > broadcasting to nodes (mpi_rank_shared == 0)");
   MPI_Bcast(&nsp,1,MPI_INT,0,mpi_comm_internode);
   MPI_Bcast(&nst,1,MPI_INT,0,mpi_comm_internode);

   if (mpi_rank != 0) {
     spost = new int[nst][3];
     xp = new double[nsp][3];
   }

   MPI_Bcast(spost,nst*3,MPI_INT,0,mpi_comm_internode);
   MPI_Bcast(xp,nsp*3,MPI_DOUBLE,0,mpi_comm_internode);



   if (refType == "VOLUME") {
     if (checkParam("VERBOSE")) COUT1(" > populating mixedTriVecArray with " << nst << " elements");
     mixedTriCount[this_level-1] += nst;
     int imt = mixedTriVecArray[this_level-1].size();
     mixedTriVecArray[this_level-1].resize(imt + nst);

     for (int ist=0; ist < nst; ++ist) {
       int v0 = spost[ist][0];
       int v1 = spost[ist][1];
       int v2 = spost[ist][2];
       mixedTriVecArray[this_level-1][imt++].init(xp[v0],xp[v1],xp[v2],xp0,dxp);
     }
     assert(imt == mixedTriVecArray[this_level-1].size());
   }
   else if (refType == "SHELL") {
     if (checkParam("VERBOSE")) COUT1(" > populating mixedSphereArray");

     int * spHcp_flag = new int[nsp];
     double factor; // how far apart spheres can be before other spheres are introduced...
     if (Param *param = getParam("HCP_FAZONE_FACTOR"))
       factor = param->getDouble();
     else
       factor = 0.4;

     for (int level = 1; level <= this_level; ++level) {
       const double delta = hcpDelta*double(n)/double(1<<level);
       // cycle through ALL tris and put a sphere in each...
       for (int isp = 0; isp < nsp; ++isp)
	 spHcp_flag[isp] = 0;
       for (int ist = 0; ist < nst; ++ist) {
	 // XXXXX revisit this later -- it introduces more spheres than necessary...
	 const int isp0 = spost[ist][0];
	 const int isp1 = spost[ist][1];
	 const int isp2 = spost[ist][2];
	 double d2_max = DIST2(xp[isp0],xp[isp1]);
	 d2_max = max(d2_max,DIST2(xp[isp1],xp[isp2]));
	 d2_max = max(d2_max,DIST2(xp[isp2],xp[isp0]));
	 if (d2_max > factor*factor*delta*delta) {
	   // populate the tri with many sphere...
	   const int n = int(sqrt(d2_max)/(factor*delta))+1;
	   for (int i = 0; i <= 2*n; i += 1) {
	     const double wgt0 = double(i)/double(2*n);
	     for (int j = 0; j <= 2*n-i; j += 1) {
	       const double wgt1 = double(j)/double(2*n);
	       //cout << " wgt0: " << wgt0 << " wgt1: " << wgt1 << " 1-wgt-wgt1: " << 1.0-wgt0-wgt1 << endl;
	       double xp_temp[3];
	       FOR_K3 xp_temp[k] = wgt0*xp[isp0][k] + wgt1*xp[isp1][k] + (1.0-wgt0-wgt1)*xp[isp2][k];
	       //cout << "XXXXX: " << xp[0] << " " << xp[1] << " " << xp[2] << " " << delta << " " << level << endl;
	       mixedSphereCount[level-1] += 1;
	       const int ims = mixedSphereVecArray[level-1].size(); // for the spheres, use level-1 as the index (no level-zero spheres)...
	       mixedSphereVecArray[level-1].resize(ims+1);
	       mixedSphereVecArray[level-1][ims].x     = xp_temp[0];
	       mixedSphereVecArray[level-1][ims].dxout = dxout;
	       mixedSphereVecArray[level-1][ims].j     = int( (xp_temp[1] - xp0[1])*dxp ); // odd or even -- does not matter
	       mixedSphereVecArray[level-1][ims].k     = int( (xp_temp[2] - xp0[2])*dxp );
	       mixedSphereVecArray[level-1][ims].r     = int( delta*dxp );
	     }
	   }
	 }
	 else {
	   // just do the corners, some of which may already be done...
	   FOR_I3 {
	     const int isp = spost[ist][i];
	     if (spHcp_flag[isp] == 0) {
	       spHcp_flag[isp] = 1;
	       mixedSphereCount[level-1] += 1;
	       const int ims = mixedSphereVecArray[level-1].size(); // for the spheres, use level-1 as the index (no level-zero spheres)...
	       mixedSphereVecArray[level-1].resize(ims+1);
	       mixedSphereVecArray[level-1][ims].x     = xp[isp][0];
	       mixedSphereVecArray[level-1][ims].dxout = dxout;
	       mixedSphereVecArray[level-1][ims].j     = int( (xp[isp][1] - xp0[1])*dxp ); // odd or even -- does not matter
	       mixedSphereVecArray[level-1][ims].k     = int( (xp[isp][2] - xp0[2])*dxp );
	       mixedSphereVecArray[level-1][ims].r     = int( delta*dxp );
	     }
	   }
	 }
       }
     }
     delete[] spHcp_flag; spHcp_flag = NULL;
   }
   else {
     CERR("unrecognized refinement type: " << refType);
   }

   delete[] spost; spost = NULL;
   delete[] xp; xp = NULL;
 }
 else {
   CERR("unrecognized HCP_WINDOW: " << name);
 }

}

delete[] sp_flag; sp_flag = NULL;

}
catch(...) {

  // use the count in HCP_LEVEL_MAX to indicate a problem...
  mixedSphereCount[HCP_LEVEL_MAX] = -1;

 }

}
















vector<Surface::MixedSphere> mixedSphereVecArray[HCP_LEVEL_MAX];
vector<Surface::MixedTri> mixedTriVecArray[HCP_LEVEL_MAX];

// and refinement tris...

int mixedTriCount[HCP_LEVEL_MAX+1];
for (int level = 0; level <= HCP_LEVEL_MAX; ++level)
  mixedTriCount[level] = 0;


if (mpi_rank_shared == 0) {
  for (vector<HcpWindow>::iterator window = hcpWindowVec.begin(); window != hcpWindowVec.end(); ++window)
    window->addRefinementStuff(mixedSphereVecArray,mixedTriVecArray,surface);

























  MPI_Pause("OKOK ------ ");



  // from nbr stuff...

  // we need to send 5 doubles for each request: 3 potentially transformed x, and 2 r0 and r1...

  // striv out the local calls: these are handled locally because they will often involve
  // local data that is already available...

  send_count[mpi_rank] = 0;

  int * send_disp = new int[mpi_size];
  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  const int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];

  double * send_buf_double = new double[send_count_sum*5];
  uint * send_buf_bi = new uint[send_count_sum];

  for (int ii = 0; ii < ibrVec.size(); ++ii) {
    const int rank = ibrVec[ii] & (((uint8(1)<<24)-1));
    assert((rank >= 0)&&(rank < mpi_size));
    const int bits = (ibrVec[ii]>>(32-6)) & (((uint8(1)<<6)-1));
    assert((bits >= 0)&&(bits < (1<<6)));
    const int iv   = (ibrVec[ii]>>(32));
    double xv_t[3] = { xv[iv][0], xv[iv][1], xv[iv][2] };
    if (rank == mpi_rank) {
      // the normal request for a resonably divided partition will be
      // local information, so handle differently than info from other processes...
      if (bits == 0) {
	// local, immediate nbrs of us: always available, just need to be added to the list...
	candidateVec.clear();
	xvAdt->buildListForSphericalShell(candidateVec,xv_t,r0[iv],r1[iv]);
	for (int ic = 0; ic < candidateVec.size(); ++ic) {
	  const int iv = candidateVec[ic];
	  assert((iv >= 0)&&(iv < nv));
	  // make with iv most siginificant so sort puts iv in order...
	  ivNbrHashVec.push_back( (uint8(iv)<<32) | uint8(iv) );
	}
      }
      else {
	// local nbrs whose periodic transforms are immediate nbrs of us: not necessarily available...
	surface->periodicTranslate(xv_t,1,bits);
	candidateVec.clear();
	xvAdt->buildListForSphericalShell(candidateVec,xv_t,r0[iv],r1[iv]);
	if (candidateVec.size() > 0) {
	  // these candidates are potentially already in our ghost data, and their
	  // index needs to be found quickly...
	  const int fliv_bits = flivPeriodicBits(bits);
	  for (int ic = 0; ic < candidateVec.size(); ++ic) {
	    const int iv = candidateVec[ic];
	    assert((iv >= 0)&&(iv < nv));
	    uint8 hsh = packRankBitsIndex(mpi_rank,fliv_bits,iv);
	    map<const uint8,int>::iterator it = xgMap.find(hsh);
	    if (it == xgMap.end()) {
	      // not found, so add...
	      const int ig = new_ghost();
	      xgMap[hsh] = ig;
	      FOR_I3 xv[nv+ig][i] = xv[iv][i]; // TODO get rid of xg/ig eventually: manage as nv_g >= nv, and use iv >= nv for ghost: better exvresses reality that xv is being resized
	      surface->periodicTranslate(xv+nv+ig,1,fliv_bits);
	      ivNbrHashVec.push_back( (uint8(iv)<<32) | uint8(nv+ig) );
	      FOR_I3 wv[nv+ig][i] = wv[iv][i];
	      surface->periodicRotate(wv+nv+ig,1,fliv_bits);
	    }
	    else {
	      const int ig = it->second; // see note above
	      ivNbrHashVec.push_back( (uint8(iv)<<32) | uint8(nv+ig) );
	    }
	  }
	}
      }
    }
    else {

      // on another rank...
      // pack and send 5 doubles per iv, and store the bits and iv index in
      // the bi array...

      if (bits == 0) {
	send_buf_bi[send_disp[rank]] = ( uint(iv) );
      }
      else {
	surface->periodicTranslate(xv_t,1,bits);
	send_buf_bi[send_disp[rank]] = ( (uint(bits)<<(32-6)) | uint(iv) );
      }
      send_buf_double[send_disp[rank]*5  ] = xv_t[0];
      send_buf_double[send_disp[rank]*5+1] = xv_t[1];
      send_buf_double[send_disp[rank]*5+2] = xv_t[2];
      send_buf_double[send_disp[rank]*5+3] = r0[iv];
      send_buf_double[send_disp[rank]*5+4] = r1[iv];
      ++send_disp[rank];

    }
  }

  ibrVec.clear();

  // multivly count by 5...

  FOR_RANK send_count[rank] *= 5;

  // reset disp according to this count...

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

  // and exchange doubles...

  int * recv_count = new int[mpi_size];
  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);

  int * recv_disp = new int[mpi_size];
  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];

  // this could be very large in some cases, so report stats before proceeding...
  // this size will depend to some degree on the quality of the partition (i.e.
  // the extent to which the partition bboxes do not overlap). If this becomes the
  // limiting aspect of this algorithm in the future, then we need to rethink
  // the global bbox view that everyone has -- maybe some knn algo or limiting the
  // partition to one that is singly-connected and more isotropic...

  /*
    my_stats[1] = recv_count_sum;
    {
    int stats_min[2]; MPI_Reduce(my_stats,stats_min,2,MPI_INT,MPI_MIN,0,mpi_comm);
    int stats_max[2]; MPI_Reduce(my_stats,stats_max,2,MPI_INT,MPI_MAX,0,mpi_comm);
    int stats_sum[2]; MPI_Reduce(my_stats,stats_sum,2,MPI_INT,MPI_SUM,0,mpi_comm);
    if (mpi_rank == 0) {
    cout << " > getNearbyNbrs: send size: " << stats_sum[0] << " min:avg:max per proc: " << stats_min[0] << ":" << double(stats_sum[0])/double(mpi_size) << ":" << stats_max[0] << endl;
    cout << " > getNearbyNbrs: recv size: " << stats_sum[1] << " min:avg:max per proc: " << stats_min[1] << ":" << double(stats_sum[1])/double(mpi_size) << ":" << stats_max[1] << endl;
    }
    }
    MPI_Barrier(mpi_comm);
  */

  double * recv_buf_double = new double[recv_count_sum];
  MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
  delete[] send_buf_double;

  // reply with one or more indices of matched points...

  FOR_RANK {
    recv_count[rank] /= 5;
    recv_disp[rank] /= 5;
  }

  // on the recv side, we are going to pass back simply the index of the matched points associated with each
  // request. If there are no matched points, we return -1. Here we expand the recv_count to include all
  // matches. Note that we do not pass coordinate information here. On the send process where the main
  // point is actually located we will figure out which coordinates if any we need to ask for and get them
  // in a follow-on request...

  vector<int> recvVec;
  FOR_RANK {
    const int irecv_end = recv_disp[rank]+recv_count[rank];
    for (int irecv = recv_disp[rank]; irecv != irecv_end; ++irecv) {
      assert(rank != mpi_rank); // no self data here
      candidateVec.clear();
      xvAdt->buildListForSphericalShell(candidateVec,recv_buf_double+5*irecv,recv_buf_double[5*irecv+3],recv_buf_double[5*irecv+4]);
      if (candidateVec.empty()) {
	// just -1: no matches...
	recvVec.push_back(-1);
      }
      else {
	recv_count[rank] += candidateVec.size()-1;
	for (int ic = 0; ic < candidateVec.size()-1; ++ic)
	  recvVec.push_back(candidateVec[ic]);
	// make the last one negative...
	recvVec.push_back(-candidateVec.back()-2);
      }
    }
  }
  delete[] recv_buf_double;

  // now push these nbr indices back to the send side, where they can be
  // combined with the known bits and rank and set as nbrs...

  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  assert( recv_disp[mpi_size-1] + recv_count[mpi_size-1] == recvVec.size() );

  MPI_Alltoall(recv_count,1,MPI_INT,send_count,1,MPI_INT,mpi_comm);

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  const int send_count_sum2 = send_disp[mpi_size-1] + send_count[mpi_size-1];

  int * send_buf_int = new int[send_count_sum2];
  MPI_Alltoallv(&recvVec[0],recv_count,recv_disp,MPI_INT,
		send_buf_int,send_count,send_disp,MPI_INT,
		mpi_comm);
  recvVec.clear();

  // note that the new send_buf_int info has portentially been padded with additional
  // info. At the end of each block, however, there is a negative, either a -1 for no data,
  // or -index-2 for an index on rank...

  vector<uint8> rbiHashVec;
  {
    int isend_orig = 0;
    int iv,fliv_bits;
    bool reset_iv_bits = true;
    FOR_RANK {
      assert(reset_iv_bits);
      for (int isend = send_disp[rank]; isend != send_disp[rank]+send_count[rank]; ++isend) {
	assert(rank != mpi_rank); // no self data here
	int index = send_buf_int[isend];
	if (index == -1) {
	  ++isend_orig;
	  continue;
	}
	// the rank and iv associated with this guy are stored in send_buf_bi[isend_orig]...
	if (reset_iv_bits) {
	  reset_iv_bits = false;
	  iv = int(send_buf_bi[isend_orig] & ( (uint(1)<<(32-6))-1 ));
	  assert((iv >= 0)&&(iv < nv));
	  fliv_bits = flivPeriodicBits(int(send_buf_bi[isend_orig]>>(32-6)));
	  assert((fliv_bits >= 0)&&(fliv_bits < (1<<6)));
	}
	if (index < -1) {
	  reset_iv_bits = true;
	  index = -index-2;
	  ++isend_orig;
	}
	// iv needs nbr rank|bits|index...
	uint8 hsh = packRankBitsIndex(rank,fliv_bits,index);
	map<const uint8,int>::iterator it = xgMap.find(hsh);
	if (it == xgMap.end()) {
	  // not found, so add...
	  const int ig = ng + rbiHashVec.size();
	  xgMap[hsh] = ig;
	  rbiHashVec.push_back(hsh);
	  ivNbrHashVec.push_back( (uint8(iv)<<32) | uint8(nv+ig) );
	}
	else {
	  const int ig = it->second;
	  ivNbrHashVec.push_back( (uint8(iv)<<32) | uint8(nv+ig) );
	}
      }
    }
    assert(isend_orig == send_count_sum);
    delete[] send_buf_int;
  }

  delete[] send_buf_bi;

  // now request and recv the untransformed points...

  FOR_RANK send_count[rank] = 0;
  for (int ii = 0; ii < rbiHashVec.size(); ++ii) {
    int rank,bits,index;
    unpackRankBitsIndex(rank,bits,index,rbiHashVec[ii]);
    ++send_count[rank];
  }

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
  const int send_count_sum3 = send_disp[mpi_size-1] + send_count[mpi_size-1];

  send_buf_int = new int[send_count_sum3];

  for (int ii = 0; ii < rbiHashVec.size(); ++ii) {
    int rank,bits,index;
    unpackRankBitsIndex(rank,bits,index,rbiHashVec[ii]);
    send_buf_int[send_disp[rank]++] = index;
  }

  // reset send_disp...

  send_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

  // and exchange doubles...

  MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);

  recv_disp[0] = 0;
  for (int rank = 1; rank < mpi_size; ++rank)
    recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
  const int recv_count_sum3 = recv_disp[mpi_size-1] + recv_count[mpi_size-1];

  int * recv_buf_int = new int[recv_count_sum3];
  MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
  delete[] send_buf_int;

  recv_buf_double = new double[recv_count_sum3*6];
  for (int irecv = 0; irecv != recv_count_sum3; ++irecv) {
    const int iv = recv_buf_int[irecv];
    assert((iv >= 0)&&(iv < nv));
    assert(wv != NULL);
    recv_buf_double[irecv*6  ] = xv[iv][0];
    recv_buf_double[irecv*6+1] = xv[iv][1];
    recv_buf_double[irecv*6+2] = xv[iv][2];
    recv_buf_double[irecv*6+3] = wv[iv][0];
    recv_buf_double[irecv*6+4] = wv[iv][1];
    recv_buf_double[irecv*6+5] = wv[iv][2];
  }
  delete[] recv_buf_int;

  FOR_RANK {
    send_count[rank] *= 6;
    send_disp[rank] *= 6;
    recv_count[rank] *= 6;
    recv_disp[rank] *= 6;
  }

  send_buf_double = new double[send_count_sum3*6];
  MPI_Alltoallv(recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,
		send_buf_double,send_count,send_disp,MPI_DOUBLE,
		mpi_comm);
  delete[] recv_buf_double;
  delete[] recv_count;
  delete[] recv_disp;
  delete[] send_count;

  // increase the size of the ghost data...

  const int ng_orig = ng;
  resize_ng(ng_orig + rbiHashVec.size());
  assert(ng == ng_orig + rbiHashVec.size());

  // and add it...

  for (int ii = 0; ii < rbiHashVec.size(); ++ii) {
    int rank,bits,index;
    unpackRankBitsIndex(rank,bits,index,rbiHashVec[ii]);
    xv[nv+ng_orig+ii][0] = send_buf_double[send_disp[rank]];
    xv[nv+ng_orig+ii][1] = send_buf_double[send_disp[rank]+1];
    xv[nv+ng_orig+ii][2] = send_buf_double[send_disp[rank]+2];
    wv[nv+ng_orig+ii][0] = send_buf_double[send_disp[rank]+3];
    wv[nv+ng_orig+ii][1] = send_buf_double[send_disp[rank]+4];
    wv[nv+ng_orig+ii][2] = send_buf_double[send_disp[rank]+5];
    send_disp[rank] += 6;
    if (bits) {
      surface->periodicTranslate(xv+nv+ng_orig+ii,1,bits);
      surface->periodicRotate(wv+nv+ng_orig+ii,1,bits);
    }
  }
  delete[] send_buf_double;
  delete[] send_disp;

  // and finally check...

  for (int ii = 0; ii < ivNbrHashVec.size(); ++ii) {
    // the nbr is stored in terms of its local index in the lsb...
    const int iv_nbr = int( ivNbrHashVec[ii] & ((uint8(1)<<32)-1) );
    if (!((iv_nbr >= 0)&&(iv_nbr < nv+ng)))
      cout << "iv_nbr: " << iv_nbr << " nv: " << nv << " ng: " << ng << endl;
    assert((iv_nbr >= 0)&&(iv_nbr < nv+ng));
    // and the batch index is in the msb...
    const int iv = int( ivNbrHashVec[ii] >> 32 );
    assert((iv >= 0)&&(iv < nv));
    const double dist = DIST(xv[iv],xv[iv_nbr]);
    // make sure point distance is correct...
    assert((dist >= r0[iv]*0.9999999)&&(dist <= r1[iv]*1.00000001));
  }



#endif







void debugBloatedTri() {
  
  const double x0[3] = { 0.0, 0.0, 0.0 };
  const double x1[3] = { 1.0, 0.2, 0.2 };
  const double x2[3] = { 0.1, 1.2, 0.31 };
  const double r = 0.5;
  
  cout << "SURF=SIMPLE_PIPE " <<
    x0[0] << " " << x0[1] << " " << x0[2] << " " <<
    x1[0] << " " << x1[1] << " " << x1[2] << " " <<
    r << endl;
  cout << "WRITE_TECPLOT cyl01.dat" << endl;
  
  cout << "SURF=SIMPLE_PIPE " <<
    x1[0] << " " << x1[1] << " " << x1[2] << " " <<
    x2[0] << " " << x2[1] << " " << x2[2] << " " <<
    r << endl;
  cout << "WRITE_TECPLOT cyl12.dat" << endl;
  
  cout << "SURF=SIMPLE_PIPE " <<
    x2[0] << " " << x2[1] << " " << x2[2] << " " <<
    x0[0] << " " << x0[1] << " " << x0[2] << " " <<
    r << endl;
  cout << "WRITE_TECPLOT cyl20.dat" << endl;

  const double ymin = min(x0[1],min(x1[1],x2[1]))-r;
  const double ymax = max(x0[1],max(x1[1],x2[1]))+r;
  const double zmin = min(x0[2],min(x1[2],x2[2]))-r;
  const double zmax = max(x0[2],max(x1[2],x2[2]))+r;
  
  //  const int np = getIntParam("NP");
  //for (int ii = 0; ii < np; ++ii) {
  int count;
  while (1) {
    
    ++count;
    if (count%100000 == 0)
      cout << " count: " << count << endl;

    // we need the yz of the ray...
    double yz[2] ;
    yz[0] = ymin + double(rand())/double(RAND_MAX)*(ymax-ymin);
    yz[1] = zmin + double(rand())/double(RAND_MAX)*(zmax-zmin);
    
    double xmp[2];
    if (calcBloatedTriIntersections(xmp,yz,x2,x1,x0,r)) {
      
      //cout << "MMMMMM: " << xmp[0] << " " << yz[0] << " " << yz[1] << endl;
      //cout << "PPPPPP: " << xmp[1] << " " << yz[0] << " " << yz[1] << endl;
      
    }
  }
  
  throw(0);
  MPI_Pause("about to debug");
  
}


    /*
    

    {
      double bbmin[3] = { 1.0E+20,1.0E+20,1.0E+20 };
      double bbmax[3] = { -1.0E+20,-1.0E+20,-1.0E+20 };
      int ierr = 0;
      FOR_IED {
	if (faoed[ied][1] < 0) {
	  ierr = -1;
	  FOR_J2 {
	    const int ino = nooed[ied][j];
	    FOR_I3 bbmin[i] = min(bbmin[i],x_no[ino][i]);
	    FOR_I3 bbmax[i] = max(bbmax[i],x_no[ino][i]);
	  }
	}
      }
      if (ierr == -1) {
	//cout << "Got uncut edge in surface patch: " << COUT_VEC(bbmin) << " " << COUT_VEC(bbmax) << endl;
	if ((bbmax[0]-bbmin[0]) < min(bbmax[1]-bbmin[1],bbmax[2]-bbmin[2])) {

	  if (debug) cout << " > y and z cut" << endl;

	  // y and z cut...
	  const double xc[3] = {
	    0.5*(bbmin[0]+bbmax[0]),
	    0.5*(bbmin[1]+bbmax[1]),
	    0.5*(bbmin[2]+bbmax[2])
	  };
	  // shift to the center of the bbox...
	  FOR_INO FOR_I3 x_no[ino][i] -= xc[i];
	  // and cut against the two largest extents...
	  // -4 == y0
	  {
	    const double n[3] = { 0.0, -0.45*(bbmax[1]-bbmin[1]), 0.0 };
	    cut_surf(n,-4);
	  }
	  // -5 == y1
	  {
	    const double n[3] = { 0.0, 0.45*(bbmax[1]-bbmin[1]), 0.0 };
	    cut_surf(n,-5);
	  }
	  // -6 == z0
	  {
	    const double n[3] = { 0.0, 0.0, -0.45*(bbmax[2]-bbmin[2]) };
	    cut_surf(n,-6);
	  }
	  // -7 == z1
	  {
	    const double n[3] = { 0.0, 0.0, 0.45*(bbmax[2]-bbmin[2]) };
	    cut_surf(n,-7);
	  }
	  // and shift back...
	  FOR_INO FOR_I3 x_no[ino][i] += xc[i];
	}
	else if ((bbmax[1]-bbmin[1]) < min(bbmax[0]-bbmin[0],bbmax[2]-bbmin[2])) {

	  if (debug) cout << " > x and z cut" << endl;

	  // x and z cut...
	  const double xc[3] = {
	    0.5*(bbmin[0]+bbmax[0]),
	    0.5*(bbmin[1]+bbmax[1]),
	    0.5*(bbmin[2]+bbmax[2])
	  };
	  // shift to the center of the bbox...
	  FOR_INO FOR_I3 x_no[ino][i] -= xc[i];
	  // and cut against the two largest extents...
	  // -2 == x0
	  {
	    const double n[3] = { -0.45*(bbmax[0]-bbmin[0]), 0.0, 0.0 };
	    cut_surf(n,-2);
	  }
	  // -3 == x1
	  {
	    const double n[3] = { 0.45*(bbmax[0]-bbmin[0]), 0.0, 0.0 };
	    cut_surf(n,-3);
	  }
	  // -6 == z0
	  {
	    const double n[3] = { 0.0, 0.0, -0.45*(bbmax[2]-bbmin[2]) };
	    cut_surf(n,-6);
	  }
	  // -7 == z1
	  {
	    const double n[3] = { 0.0, 0.0, 0.45*(bbmax[2]-bbmin[2]) };
	    cut_surf(n,-7);
	  }
	  // and shift back...
	  FOR_INO FOR_I3 x_no[ino][i] += xc[i];
	}
	else {

	  if (debug) cout << " > x and y cut" << endl;
	  
	  // x and y cut...
	  const double xc[3] = {
	    0.5*(bbmin[0]+bbmax[0]),
	    0.5*(bbmin[1]+bbmax[1]),
	    0.5*(bbmin[2]+bbmax[2])
	  };
	  // shift to the center of the bbox...
	  FOR_INO FOR_I3 x_no[ino][i] -= xc[i];
	  // and cut against the two largest extents...
	  // -2 == x0
	  {
	    const double n[3] = { -0.45*(bbmax[0]-bbmin[0]), 0.0, 0.0 };
	    cut_surf(n,-2);
	  }
	  // -3 == x1
	  {
	    const double n[3] = { 0.45*(bbmax[0]-bbmin[0]), 0.0, 0.0 };
	    cut_surf(n,-3);
	  }
	  // -4 == y0
	  {
	    const double n[3] = { 0.0, -0.45*(bbmax[1]-bbmin[1]), 0.0 };
	    cut_surf(n,-4);
	  }
	  // -5 == y1
	  {
	    const double n[3] = { 0.0, 0.45*(bbmax[1]-bbmin[1]), 0.0 };
	    cut_surf(n,-5);
	  }
	  // and shift back...
	  FOR_INO FOR_I3 x_no[ino][i] += xc[i];
	}
      }
    }

    */





template<typename T>
inline void writeZoneOrderedRecord(MPI_File& fh, MPI_Offset& offset, const string& name, const int id,  
                                   const T* var, int8* my_zone_count, const int8* zone_count, const int n_local,
                                   const int8 n_global, const int nzo, map<int,int>& zone_index_map) { 

  if ( mpi_rank == 0 ) { 
    cout << " > " << name << " ... " << endl;
    Header header;
    sprintf(header.name,"%s",name.c_str());
    header.id   = id;
    header.skip = header_size + n_global*sizeof(T);
    ByteSwap::setLswMswPairForInt8(header.idata+0,n_global);
    MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
  }

  packAndWriteZoneOrderedRecord(fh,offset,var,znobf,my_zone_count,zone_count,
                                n_local,n_global,nzo,zone_index_map);

  offset += header_size + n_global*sizeof(T);
}

template<typename T>
inline void packAndWriteZoneOrderedRecord(MPI_File& fh, MPI_Offset& offset,const T* var, 
                                          const int* znobf, int8* my_zone_count, const int8* zone_count, 
                                          const int n_local, const int8 n_global,const int nzo,
                                          map<int,int>& zone_index_map) { 

  int8 zone_offset = 0;
  for (int izo = 0; izo < nzo+1; ++izo) { 
    if ( zone_count[izo] > 0 ) {
      const int n_    = my_zone_count[izo];
      assert(zone_index_map.find(izo-1) != zone_index_map.end());
      const int izone = zone_index_map[izo-1];
      T* pack = new T[n_];
      my_zone_count[izo] = 0;
      for (int i = 0; i < n_local; ++i) { 
        if ( znobf[i] == izone) { 
          pack[my_zone_count[izo]++] = var[i];
        }
      }
      assert(my_zone_count[izo] == n_);
      
      int8 tmp = int8(n_);
      int8 this_count;
      MPI_Scan(&tmp,&this_count,1,MPI_INT8,MPI_SUM,mpi_comm); 
      this_count -= n_;
      
      MPI_Datatype MPI_T = getMpiDatatype<T>();
      MPI_File_write_at_all(fh,offset+header_size+(zone_offset+this_count)*sizeof(T),
                            pack,n_,MPI_T,MPI_STATUS_IGNORE);
      
      delete[] pack;
    }
    zone_offset += zone_count[izo];
  }
}





    /*
    if (mpi_rank == 0) {
      
      int8 nbf_global = 0;
      int8 noobf_global = 0;
      for (int izone = 0; izone < nzone; ++izone) {
	nbf_global += nbf_zone[izone];
	noobf_global += noobf_zone[izone];
	if (izone < nzone-1)
	  cout << " > bf zone: " << mainPart->surface->zoneVec[izone].getName() << ", nbf: " << nbf_zone[izone] << endl;
	else
	  cout << " > bf zone: " << "orphan" << ", nbf: " << nbf_zone[nzone-1] << endl;
      }
      cout << " > nbf_global: " << nbf_global << " avg noobf: " << double(noobf_global)/double(nbf_global) << endl;
      
      int8 nfa_global = 0;
      int8 noofa_global = 0;
      for (int izone = 0; izone < 27; ++izone) {
	nfa_global += nfa_zone[izone];
	noofa_global += noofa_zone[izone];
	cout << " > fa zone: " << izone << ", nfa: " << nfa_zone[izone] << endl;
      }
      cout << " > nfa_global: " << nfa_global << " avg noofa: " << double(noofa_global)/double(nfa_global) << endl;
      
      
      
    }
    */





		my_nfa_zone[izone] += 1;
		my_noofa_zone[izone] += inoGlobalVec.size();
	      izone = getFaceZone(flip_bits);
	      my_nfa_zone[izone] += 1;
	      my_noofa_zone[izone] += inoGlobalVec.size();
	      // XXXXXX


		herehere
		






    
    


    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE -- these need to be local offsets first to support packing,
      then switch to scanned offsets later

    
    int8 * my_nbf_disp = new int8[nzone];
    MPI_Scan(my_nbf_zone,my_nbf_disp,nzone,MPI_INT8,MPI_SUM,mpi_comm);
    int8 * nbf_zone = new int8[nzone];
    if (mpi_rank == mpi_size-1)
      for (int izone = 0; izone < nzone; ++izone) 
	nbf_zone[izone] = my_nbf_disp[izone];
    MPI_Bcast(nbf_zone,nzone,MPI_INT8,mpi_size-1,mpi_comm);
    for (int izone = 0; izone < nzone; ++izone) 
      my_nbf_disp[izone] -= my_nbf_zone[izone];
    
    int8 * my_noobf_disp = new int8[nzone];
    MPI_Scan(my_noobf_zone,my_noobf_disp,nzone,MPI_INT8,MPI_SUM,mpi_comm);
    int8 * noobf_zone = new int8[nzone];
    if (mpi_rank == mpi_size-1)
      for (int izone = 0; izone < nzone; ++izone) 
	noobf_zone[izone] = my_noobf_disp[izone];
    MPI_Bcast(noobf_zone,nzone,MPI_INT8,mpi_size-1,mpi_comm);
    for (int izone = 0; izone < nzone; ++izone) 
      my_noobf_disp[izone] -= my_noobf_zone[izone];
    
    // nfa zone counting...

    int8 my_nfa_disp[27];
    MPI_Scan(my_nfa_zone,my_nfa_disp,27,MPI_INT8,MPI_SUM,mpi_comm);
    int8 nfa_zone[27];
    if (mpi_rank == mpi_size-1)
      for (int izone = 0; izone < 27; ++izone) 
	nfa_zone[izone] = my_nfa_disp[izone];
    MPI_Bcast(nfa_zone,27,MPI_INT8,mpi_size-1,mpi_comm);
    for (int izone = 0; izone < 27; ++izone) 
      my_nfa_disp[izone] -= my_nfa_zone[izone];
    
    int8 my_noofa_disp[27];
    MPI_Scan(my_noofa_zone,my_noofa_disp,27,MPI_INT8,MPI_SUM,mpi_comm);
    int8 noofa_zone[27];
    if (mpi_rank == mpi_size-1)
      for (int izone = 0; izone < 27; ++izone) 
	noofa_zone[izone] = my_noofa_disp[izone];
    MPI_Bcast(noofa_zone,27,MPI_INT8,mpi_size-1,mpi_comm);
    for (int izone = 0; izone < 27; ++izone) 
      my_noofa_disp[izone] -= my_noofa_zone[izone];
    











// old LegacyIO stuff...

  /*
    map<const int,int> bitMap;
    bitMap[              (1<<0)] = 0;
    bitMap[              (1<<1)] = 0;

    bitMap[       (1<<2)       ] = 1;
    bitMap[       (1<<3)       ] = 1;

    bitMap[       (1<<2)|(1<<0)] = 2;
    bitMap[       (1<<2)|(1<<1)] = 2;
    bitMap[       (1<<3)|(1<<0)] = 2;
    bitMap[       (1<<3)|(1<<1)] = 2;

    bitMap[(1<<4)              ] = 3;
    bitMap[(1<<5)              ] = 3;
    
    bitMap[(1<<4)|       (1<<0)] = 4;
    bitMap[(1<<4)|       (1<<1)] = 4;
    bitMap[(1<<5)|       (1<<0)] = 4;
    bitMap[(1<<5)|       (1<<1)] = 4;

    bitMap[(1<<4)|(1<<2)       ] = 5;
    bitMap[(1<<4)|(1<<3)       ] = 5;
    bitMap[(1<<5)|(1<<2)       ] = 5;
    bitMap[(1<<5)|(1<<3)       ] = 5;

    bitMap[(1<<4)|(1<<2)|(1<<0)] = 6;
    bitMap[(1<<4)|(1<<2)|(1<<1)] = 6;
    bitMap[(1<<4)|(1<<3)|(1<<0)] = 6;
    bitMap[(1<<4)|(1<<3)|(1<<1)] = 6;
    bitMap[(1<<5)|(1<<2)|(1<<0)] = 6;
    bitMap[(1<<5)|(1<<2)|(1<<1)] = 6;
    bitMap[(1<<5)|(1<<3)|(1<<0)] = 6;
    bitMap[(1<<5)|(1<<3)|(1<<1)] = 6;
  */




    
#ifdef JUNKJUINK

    {



      {

	// for each face, build node loop...

	for (int ip = 0; ip < mainPart->points->np; ++ip) {
	  for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
	    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	      const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	      assert(ip != ip_nbr); // no self-connections
	      if (ip_nbr < mainPart->points->np) {
		// the face nbr should be matched and valid as well...
		const int ifa_nbr_ = mainPart->cvdVec[ip].ifa_nbr[ifa_];
		assert((ifa_nbr_ >= 0)&&(ifa_nbr_ < mainPart->cvdVec[ip_nbr].getNfa()));
		assert( mainPart->cvdVec[ip_nbr].getNbofa(ifa_nbr_) == ip );
		assert( (mainPart->cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) );
		assert(mainPart->cvdVec[ip_nbr].ifa_nbr[ifa_nbr_] == ifa_);
		// only compute the case when ip_nbr > ip...
		if (ip_nbr > ip) {
		
		  edgeMap0.clear();
		  mainPart->cvdVec[ip].setFaceEdgeMap(edgeMap0,ifa_);
		  const double (* const x0)[3] = mainPart->cvdVec[ip].x_no; 
		
		  edgeMap1.clear();
		  mainPart->cvdVec[ip_nbr].setFaceEdgeMapReverse(edgeMap1,ifa_nbr_);
		  const double (* const x1)[3] = mainPart->cvdVec[ip_nbr].x_no; 
		
		  const double dx[3] = DIFF(mainPart->points->xp[ip_nbr],mainPart->points->xp[ip]);
		  const double d2_tol = 1.0E-16*DOT_PRODUCT(dx,dx);

		  // compare starting nodes of the remaining edge map...

		  while ((!edgeMap0.empty())||(!edgeMap1.empty())) {

		    assert(!edgeMap0.empty());
		    assert(!edgeMap1.empty());
		  
		    // N^2 search to find closest pair of nodes associated with remaining edges...
		  
		    double d2_min = 1.0E+20; 
		    map<const int,int>::iterator iter0;
		    map<const int,int>::iterator iter1;
		    for (map<const int,int>::iterator iter0_ = edgeMap0.begin(); iter0_ != edgeMap0.end(); ++iter0_) {
		      const int ino0 = iter0_->first;
		      for (map<const int,int>::iterator iter1_ = edgeMap1.begin(); iter1_ != edgeMap1.end(); ++iter1_) {
			const int ino1 = iter1_->first;
			double dx_no[3]; FOR_I3 dx_no[i] = x0[ino0][i] - x1[ino1][i] - dx[i];
			const double d2 = DOT_PRODUCT(dx_no,dx_no);
			if (d2 < d2_min) {
			  d2_min = d2;
			  iter0 = iter0_;
			  iter1 = iter1_;
			}
		      }
		    }
		    assert(d2_min < d2_tol);
		  
		    // we have a starting iterator...
		
		    const int ino0 = iter0->first;
		    int ino0_prev = ino0;
		    int ino0_next = iter0->second;
		    edgeMap0.erase(iter0);

		    const int ino1 = iter1->first;
		    int ino1_prev = ino1;
		    int ino1_next = iter1->second;
		    edgeMap1.erase(iter1);

		    // the nodes are associated with a particular group...
		    int igr0 = 0;
		    while (ino0 >= mainPart->cvdVec[ip].getNoogr(igr0+1))
		      ++igr0;
		  
		    int igr1 = 0;
		    while (ino1 >= mainPart->cvdVec[ip_nbr].getNoogr(igr1+1))
		      ++igr1;
		  
		    // get the starting point of the edge loop...
		
		    double xp[3]; FOR_I3 xp[i] = 0.5*( x0[ino0][i] + x1[ino1][i] );
		  
		    vector< pair<int,int> > nodeLoopVec; 
		    nodeLoopVec.push_back(pair<int,int>(ino0,ino1));
		  
		    while ((ino0_next != ino0)||(ino1_next != ino1)) {
		    
		      if (DIST2(x0[ino0_next],xp) <= DIST2(x1[ino1_next],xp)) {
			// ino0_next is closer. now decide which of the following we are going to add:
			// (ino0_next,ino1_prev), or
			// (ino0_next,ino1_next), or 
			// (ino0_next,-1)...
			double dx_test[3]; FOR_I3 dx_test[i] = x0[ino0_next][i] - x1[ino1_prev][i] - dx[i];
			if (DOT_PRODUCT(dx_test,dx_test) < d2_tol) {
			  // (ino0_next,ino1_prev)...
			  nodeLoopVec.push_back(pair<int,int>(ino0_next,ino1_prev));
			  FOR_I3 xp[i] = 0.5*( x0[ino0_next][i] + x1[ino1_prev][i] );
			  if (ino0_next != ino0) {
			    ino0_prev = ino0_next;
			    iter0 = edgeMap0.find(ino0_prev);
			    assert(iter0 != edgeMap0.end());
			    ino0_next = iter0->second;
			    edgeMap0.erase(iter0);
			  }
			}
			else {
			  FOR_I3 dx_test[i] = x0[ino0_next][i] - x1[ino1_next][i] - dx[i];
			  if (DOT_PRODUCT(dx_test,dx_test) < d2_tol) {
			    // (ino0_next,ino1_next)... 
			    nodeLoopVec.push_back(pair<int,int>(ino0_next,ino1_next));
			    FOR_I3 xp[i] = 0.5*( x0[ino0_next][i] + x1[ino1_next][i] );
			    if (ino0_next != ino0) {
			      ino0_prev = ino0_next;
			      iter0 = edgeMap0.find(ino0_prev);
			      assert(iter0 != edgeMap0.end());
			      ino0_next = iter0->second;
			      edgeMap0.erase(iter0);
			    }
			    if (ino1_next != ino1) {
			      ino1_prev = ino1_next;
			      iter1 = edgeMap1.find(ino1_prev);
			      assert(iter1 != edgeMap1.end());
			      ino1_next = iter1->second;
			      edgeMap1.erase(iter1);
			    }
			  }
			  else {
			    // (ino0_next,-1)...
			    nodeLoopVec.push_back(pair<int,int>(ino0_next,-1));
			    FOR_I3 xp[i] = x0[ino0_next][i] - 0.5*dx[i];
			    if (ino0_next != ino0) {
			      ino0_prev = ino0_next;
			      iter0 = edgeMap0.find(ino0_prev);
			      assert(iter0 != edgeMap0.end());
			      ino0_next = iter0->second;
			      edgeMap0.erase(iter0);
			    }
			  }
			}
		      }
		      else {
			// ino1_next is closer. now decide which of the following we are going to add:
			// (ino0_prev,ino1_next), or
			// (ino0_next,ino1_next), or 
			// (-1,ino1_next)...
			double dx_test[3]; FOR_I3 dx_test[i] = x0[ino0_prev][i] - x1[ino1_next][i] - dx[i];
			if (DOT_PRODUCT(dx_test,dx_test) < d2_tol) {
			  // (ino0_prev,ino1_next)...
			  nodeLoopVec.push_back(pair<int,int>(ino0_prev,ino1_next));
			  FOR_I3 xp[i] = 0.5*( x0[ino0_prev][i] + x1[ino1_next][i] );
			  if (ino1_next != ino1) {
			    ino1_prev = ino1_next;
			    iter1 = edgeMap1.find(ino1_prev);
			    assert(iter1 != edgeMap1.end());
			    ino1_next = iter1->second;
			    edgeMap1.erase(iter1);
			  }
			}
			else {
			  FOR_I3 dx_test[i] = x0[ino0_next][i] - x1[ino1_next][i] - dx[i];
			  if (DOT_PRODUCT(dx_test,dx_test) < d2_tol) {
			    // (ino0_next,ino1_next)... 
			    nodeLoopVec.push_back(pair<int,int>(ino0_next,ino1_next));
			    FOR_I3 xp[i] = 0.5*( x0[ino0_next][i] + x1[ino1_next][i] );
			    if (ino0_next != ino0) {
			      ino0_prev = ino0_next;
			      iter0 = edgeMap0.find(ino0_prev);
			      assert(iter0 != edgeMap0.end());
			      ino0_next = iter0->second;
			      edgeMap0.erase(iter0);
			    }
			    if (ino1_next != ino1) {
			      ino1_prev = ino1_next;
			      iter1 = edgeMap1.find(ino1_prev);
			      assert(iter1 != edgeMap1.end());
			      ino1_next = iter1->second;
			      edgeMap1.erase(iter1);
			    }
			  }
			  else {
			    // (-1,ino1_next)...
			    nodeLoopVec.push_back(pair<int,int>(-1,ino1_next));
			    FOR_I3 xp[i] = x1[ino1_next][i] + 0.5*dx[i];
			    if (ino1_next != ino1) {
			      ino1_prev = ino1_next;
			      iter1 = edgeMap1.find(ino1_prev);
			      assert(iter1 != edgeMap1.end());
			      ino1_next = iter1->second;
			      edgeMap1.erase(iter1);
			    }
			  }
			}
		      }
		    }
		  
		    cout << "got loop from igr0: " << igr0 << " to igr1: " << igr1 << endl;
		    for (int ii = 0; ii < nodeLoopVec.size(); ++ii) 
		      cout << " > " << nodeLoopVec[ii].first << " " << nodeLoopVec[ii].second << endl;
		    //getchar();
		  
		  }
		
		  cout << "both maps empty!" << endl;
		  getchar();
		
		}
	      
	      }
	      else {

		const int ig = ip_nbr - mainPart->points->np;
		int rank,bits,index;
		BitUtils::unpackRankBitsIndex(rank,bits,index,mainPart->rbiGhostVec[ig]);
		// this face should appear twice. Only count it when rank > mpi_rank
		assert((rank != mpi_rank)||(bits != 0));
		if ( (mpi_rank > rank) || ((mpi_rank == rank)&&(bits > BitUtils::flipPeriodicBits(bits))) ) {
		
		  edgeMap0.clear();
		  mainPart->cvdVec[ip].setFaceEdgeMapReverse(edgeMap0,ifa_);
		  assert(!edgeMap0.empty());
		
		  vector<pair<int,int> > nooedVec; // (ino0,ino1) edges in local coords
		  vector<int> noVec; // list of local->*_no coords
		
		  int nno_local = 0;
		  edgeMap1.clear(); // use edgeMap1 as noMap...
		  for (map<const int,int>::iterator iter = edgeMap0.begin(); iter != edgeMap0.end(); ++iter) {
		    const int ino0 = iter->first;
		    int ino0_local;
		    map<const int,int>::iterator no_iter = edgeMap1.find(ino0);
		    if (no_iter == edgeMap1.end()) {
		      ino0_local = nno_local;
		      edgeMap1[ino0] = nno_local++;
		    }
		    else {
		      ino0_local = no_iter->second;
		    }
		    const int ino1 = iter->second;
		    int ino1_local;
		    no_iter = edgeMap1.find(ino1);
		    if (no_iter == edgeMap1.end()) {
		      ino1_local = nno_local;
		      edgeMap1[ino1] = nno_local++;
		    }
		    else {
		      ino1_local = no_iter->second;
		    }
		    // send over the edges once...
		    nooedVec.push_back(pair<int,int>(ino0_local,ino1_local));
		  }
		  noVec.resize(edgeMap1.size());
		  for (map<const int,int>::iterator iter = edgeMap1.begin(); iter != edgeMap1.end(); ++iter)
		    noVec[iter->second] = iter->first;
		
		}
	      }
	    }
	  }
	}
      
      }
      





















    
      // count faces...
      // and unique internal (i.e. from lower to higher global icv)...

      map<const pair<int,int>,int> ghostFaMap;
      int nfa_i = 0;
      nfa_shadow = 0;
      for (int ip = 0; ip < mainPart->points->np; ++ip) {
	for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
	  if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	    const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	    assert(ip != ip_nbr); // no self-connections
	    if (ip_nbr < mainPart->points->np) {
	      // local face...
	      if (ip_nbr > ip) {
		// this face should appear twice. Only count it when ip < ip_nbr
		++nfa_i;
	      }
	    }
	    else {
	      const int ig = ip_nbr - mainPart->points->np;
	      int rank,bits,index;
	      BitUtils::unpackRankBitsIndex(rank,bits,index,mainPart->rbiGhostVec[ig]);
	      assert(bits == 0);
	      assert(rank != mpi_rank);
	      // this face should appear twice. Only count it when rank > mpi_rank
	      if (rank > mpi_rank) {
		ghostFaMap[pair<int,int>(ip,ifa_)] = nfa_i;
		++nfa_i;
	      }
	      else
		++nfa_shadow;
	    }
	  }
	}
      }

      //cout << "[" << mpi_rank << "] nfa_i, nfa_shadow: " << nfa_i << " " << nfa_shadow << endl;
  
      // ===================================================
      // nodes...
      // ===================================================
  
      const double d2_tol_node = 1.0E-20;
  
      // the node vec links nodes in cvdVec on both sides of a face...
      vector< pair<int,int> > * faNodeVec = new vector< pair<int,int> >[nfa_i]; // the main faces get an int pair
      vector< int > * faShadowNodeVec = new vector<int>[nfa_shadow]; // the shadow faces store their loop only
    
      int8 (*cvofa_global)[2] = new int8[nfa_i][2];
    
      // each cv also holds a tolerance...
      double * d2_cv = new double[ncv];
      FOR_ICV d2_cv[icv] = 0.0;

      FOR_RANK send_count[rank] = 0;
      FOR_RANK send_count2[rank] = 0;
    
      {
	int ifa_i = 0;
	int ifa_shadow = 0;
	for (int ip = 0; ip < mainPart->points->np; ++ip) {
	  for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
	    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	      const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	      assert(ip != ip_nbr); // no self-connections
	      if (ip_nbr < mainPart->points->np) {
		// start by updating the d2_cv...
		const double dx[3] = DIFF(mainPart->points->xp[ip_nbr],mainPart->points->xp[ip]);
		const double d2 = DOT_PRODUCT(dx,dx);
		d2_cv[ip] = max(d2_cv[ip],d2);
		d2_cv[ip_nbr] = max(d2_cv[ip_nbr],d2);
		// local face...
		if (ip_nbr > ip) {
		  // build the first node loop...
		  vector<int> nodeLoop;
		  mainPart->cvdVec[ip].setFaceNodeLoop(nodeLoop,ifa_);
		  vector<SimplePoint> nodePtLoop(nodeLoop.size());
		  for (int i = 0; i < nodeLoop.size(); ++i) {
		    const int ino = nodeLoop[i];
		    FOR_J3 nodePtLoop[i].x[j] = mainPart->cvdVec[ip].x_no[ino][j] - 0.5*dx[j];
		  }
		  // and get the local nbr...
		  const int ifa_nbr_ = mainPart->cvdVec[ip].ifa_nbr[ifa_];
		  //const int igr_nbr = mainPart->cvdVec[ip].ifa_igr_nbr[ifa_]&7;
		  assert((ifa_nbr_ >= 0)&&(ifa_nbr_ < mainPart->cvdVec[ip_nbr].getNfa()));
		  //assert((igr_nbr >= 0)&&(igr_nbr < mainPart->cvdVec[ip_nbr].getNgr()));
		  //assert((ifa_nbr_ >= mainPart->cvdVec[ip_nbr].getFaogr(igr_nbr))&&(ifa_nbr_ < mainPart->cvdVec[ip_nbr].getFaogr(igr_nbr+1)));
		  assert( mainPart->cvdVec[ip_nbr].getNbofa(ifa_nbr_) == ip );
		  assert( (mainPart->cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) );
		  //assert(mainPart->cvdVec[ip_nbr].ifa_igr_nbr[ifa_nbr_] == ((ifa<<3)|igr));
		  vector<int> nodeLoopNbr;
		  mainPart->cvdVec[ip_nbr].setFaceNodeLoop(nodeLoopNbr,ifa_nbr_);
		  vector<SimplePoint> nodePtLoopNbr(nodeLoopNbr.size());
		  for (int i = 0; i < nodeLoopNbr.size(); ++i) {
		    const int ino = nodeLoopNbr[i];
		    FOR_J3 nodePtLoopNbr[i].x[j] = mainPart->cvdVec[ip_nbr].x_no[ino][j] + 0.5*dx[j];
		  }
		  reconcileNodeLoops(faNodeVec[ifa_i],nodePtLoop,nodePtLoopNbr,d2_tol_node*d2);
		  // reconcileNodeLoops returns an index pair in each entry of faNodeVec that walks the
		  // nodes. Now convert these to nodes in the adjacent cvdVec's...
		  for (int ii = 0; ii < faNodeVec[ifa_i].size(); ++ii) {
		    if (faNodeVec[ifa_i][ii].first >= 0) 
		      faNodeVec[ifa_i][ii].first = nodeLoop[faNodeVec[ifa_i][ii].first];
		    if (faNodeVec[ifa_i][ii].second >= 0) 
		      faNodeVec[ifa_i][ii].second = nodeLoopNbr[faNodeVec[ifa_i][ii].second];
		  }
		  // also set the cvofa_global...
		  cvofa_global[ifa_i][0] = cvora[mpi_rank] + int8(ip);
		  cvofa_global[ifa_i][1] = cvora[mpi_rank] + int8(ip_nbr);
		  ++ifa_i;
		}
	      }
	      else {
		const int ig = ip_nbr - mainPart->points->np;
		// local face...
		int rank,bits,index;
		BitUtils::unpackRankBitsIndex(rank,bits,index,mainPart->rbiGhostVec[ig]);
		assert(bits == 0);
		assert(rank != mpi_rank);
		// this face should appear twice. Only count it when rank > mpi_rank
		if (rank > mpi_rank) {
		  vector<int> nodeLoop;
		  mainPart->cvdVec[ip].setFaceNodeLoop(nodeLoop,ifa_);
		  assert(faNodeVec[ifa_i].empty());
		  faNodeVec[ifa_i].resize(nodeLoop.size());
		  for (int ii = 0; ii < nodeLoop.size(); ++ii) 
		    faNodeVec[ifa_i][ii].first = nodeLoop[ii];
		  // also set the cvofa_global...
		  cvofa_global[ifa_i][0] = cvora[mpi_rank] + int8(ip);
		  cvofa_global[ifa_i][1] = cvora[rank] + index;
		  ++ifa_i;
		}
		else {
		  // this is a shadow: here we just store the node loop...
		  assert(faShadowNodeVec[ifa_shadow].empty());
		  mainPart->cvdVec[ip].setFaceNodeLoop(faShadowNodeVec[ifa_shadow],ifa_);
		  send_count[rank] += 3; // 3 ints: ip, ifa, nnof
		  send_count2[rank] += faShadowNodeVec[ifa_shadow].size()*3; //HACK for midpoint: + 3; // 3 doubles per node: 
		  ++ifa_shadow;
		}
	      }
	    }
	  }
	}
	assert(ifa_i == nfa_i);
	assert(ifa_shadow == nfa_shadow);
      }
    
      // calc send_disp...
      //int * send_disp = new int[mpi_size];
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
      const int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
      assert(send_count_sum == nfa_shadow*3);

      //int * send_disp2 = new int[mpi_size];
      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
      const int send_count2_sum = send_disp2[mpi_size-1] + send_count2[mpi_size-1];

      // pack the nodes and the ip/ifa where they are heading...
    
      int * send_buf_int = new int[send_count_sum];
      double * send_buf2_double = new double[send_count2_sum];

      {
	int ifa_shadow = 0;
	for (int ip = 0; ip < mainPart->points->np; ++ip) {
	  for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
	    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	      const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	      assert(ip != ip_nbr); // no self-connections
	      if (ip_nbr >= mainPart->points->np) {
		const int ig = ip_nbr - mainPart->points->np;
		// start by updating the d2_cv...
		const double dx[3] = DIFF(mainPart->xpGhostVec[ig].x,mainPart->points->xp[ip]);
		const double d2 = DOT_PRODUCT(dx,dx);
		d2_cv[ip] = max(d2_cv[ip],d2);
		int rank,bits,index;
		BitUtils::unpackRankBitsIndex(rank,bits,index,mainPart->rbiGhostVec[ig]);
		assert(bits == 0);
		assert(rank != mpi_rank);
		// this face should appear twice. Only count it when rank > mpi_rank
		if (rank < mpi_rank) {
		  // this is a shadow: here we just store the node loop...
		  send_buf_int[send_disp[rank]]   = index; // ip on rank
		  send_buf_int[send_disp[rank]+1] = mainPart->cvdVec[ip].ifa_nbr[ifa_];
		  send_buf_int[send_disp[rank]+2] = faShadowNodeVec[ifa_shadow].size();
		  send_disp[rank] += 3;
		  // HACK for checking face...
		  //FOR_I3 send_buf2_double[send_disp2[rank]+i] = 0.5*(mainPart->xpGhostVec[ig].x[i] + mainPart->points->xp[ip][i]);
		  //send_disp2[rank] += 3;
		  for (int ii = 0; ii < faShadowNodeVec[ifa_shadow].size(); ++ii) {
		    const int ino = faShadowNodeVec[ifa_shadow][ii];
		    // HACK: use absolute node coords...
		    FOR_I3 send_buf2_double[send_disp2[rank]+i] = mainPart->cvdVec[ip].x_no[ino][i] + mainPart->points->xp[ip][i]; // - 0.5*dx[i];
		    //cout << "packing x_no for ifa_shadow: " << ifa_shadow << " : " << COUT_VEC(send_buf2_double+send_disp2[rank]) << endl;
		    send_disp2[rank] += 3;
		  }
		  ++ifa_shadow;
		}
	      }
	    }
	  }
	}
	assert(ifa_shadow == nfa_shadow);
      }

      // reset send_disp...
    
      send_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
    
      // and process on the recv side...
    
      int * recv_count = new int[mpi_size];
      MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
    
      int * recv_disp = new int[mpi_size];
      recv_disp[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
      const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
    
      int * recv_buf_int = new int[recv_count_sum];
      MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		    recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
      delete[] send_buf_int;
      delete[] send_count;
      delete[] send_disp; 
      delete[] recv_count;
      delete[] recv_disp;
    
      // reset send_disp2...
    
      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
    
      int * recv_count2 = new int[mpi_size];
      MPI_Alltoall(send_count2,1,MPI_INT,recv_count2,1,MPI_INT,mpi_comm);
    
      int * recv_disp2 = new int[mpi_size];
      recv_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	recv_disp2[rank] = recv_count2[rank-1] + recv_disp2[rank-1];
      const int recv_count2_sum = recv_disp2[mpi_size-1] + recv_count2[mpi_size-1];
    
      double * recv_buf2_double = new double[recv_count2_sum];
      MPI_Alltoallv(send_buf2_double,send_count2,send_disp2,MPI_DOUBLE,
		    recv_buf2_double,recv_count2,recv_disp2,MPI_DOUBLE,
		    mpi_comm);
      delete[] send_buf2_double; send_buf2_double = NULL;
    
      // we now have the node coordinates and node lists 
    
      double my_d2_max[2] = { 0.0, 0.0 };
      int nnof_offset = 0;
      for (int irecv = 0; irecv < recv_count_sum; irecv += 3) {
	const int ip = recv_buf_int[irecv]; assert((ip >= 0)&&(ip < mainPart->points->np));
	const int ifa_ = recv_buf_int[irecv+1]; assert((ifa_ >= 0)&&(ifa_ < mainPart->cvdVec[ip].getNfa()));
	const int nnof = recv_buf_int[irecv+2];
	const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	assert(ip_nbr >= mainPart->points->np);
	const int ig = ip_nbr - mainPart->points->np;
	// start by updating the d2_cv...
	const double dx[3] = DIFF(mainPart->xpGhostVec[ig].x,mainPart->points->xp[ip]);
	const double d2 = DOT_PRODUCT(dx,dx);
	d2_cv[ip] = max(d2_cv[ip],d2);
	// now find the face...
	map<const pair<int,int>,int>::iterator iter = ghostFaMap.find(pair<int,int>(ip,ifa_));
	assert(iter != ghostFaMap.end());
	const int ifa = iter->second; assert((ifa >= 0)&&(ifa < nfa_i));
	assert(ip == cvofa_global[ifa][0]-cvora[mpi_rank]);
	ghostFaMap.erase(iter);
	// recall that the node loop was stored in the first member of the pair...
	vector<int> nodeLoop(faNodeVec[ifa].size());
	vector<SimplePoint> nodePtLoop(faNodeVec[ifa].size());
	for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	  const int ino = faNodeVec[ifa][ii].first;
	  nodeLoop[ii] = ino;
	  FOR_I3 nodePtLoop[ii].x[i] = mainPart->cvdVec[ip].x_no[ino][i] + mainPart->points->xp[ip][i]; // - 0.5*dx[i]; // HACK
	}
	faNodeVec[ifa].clear();
	// check the next 3 members of the recv_buf2_double: should be the edge midpoint...
	/*
	  {
	  double x_mid[3]; FOR_I3 x_mid[i] = recv_buf2_double[nnof_offset*3+i];
	  ++nnof_offset;
	  double this_x_mid[3]; FOR_I3 this_x_mid[i] = 0.5*(mainPart->xpGhostVec[ig].x[i] + mainPart->points->xp[ip][i]);
	  const double d2 = DIST2(x_mid,this_x_mid);
	  my_d2_max[0] = max(my_d2_max[0],d2);
	  }
	*/
	// and the nbr loop from the messaging...
	vector<int> nodeLoopNbr(nnof);
	vector<SimplePoint> nodePtLoopNbr(nnof);
	for (int nof = 0; nof < nnof; ++nof) {
	  nodeLoopNbr[nof] = nnof_offset+nof; // put recv buffer indices in here
	  FOR_I3 nodePtLoopNbr[nof].x[i] = recv_buf2_double[(nnof_offset+nof)*3+i];
	}
	nnof_offset += nnof;
	reconcileNodeLoops(faNodeVec[ifa],nodePtLoop,nodePtLoopNbr,d2_tol_node*d2);
	// reconcileNodeLoops returns an index pair in each entry of faNodeVec that walks the
	// nodes. Now convert these to nodes in the adjacent cvdVec's...
	for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	  if (faNodeVec[ifa][ii].first >= 0) 
	    faNodeVec[ifa][ii].first = nodeLoop[faNodeVec[ifa][ii].first];
	  if (faNodeVec[ifa][ii].second >= 0) 
	    faNodeVec[ifa][ii].second = nodeLoopNbr[faNodeVec[ifa][ii].second];
	  // HACK -- check...
	  if ((faNodeVec[ifa][ii].first >= 0)&&(faNodeVec[ifa][ii].second >= 0)) {
	    // first is a local node in ip...
	    double x_no[3]; FOR_I3 x_no[i] = mainPart->cvdVec[ip].x_no[faNodeVec[ifa][ii].first][i] + mainPart->points->xp[ip][i];
	    // second is an offset into the recv_buf2...
	    double x_no_recv[3]; FOR_I3 x_no_recv[i] = recv_buf2_double[faNodeVec[ifa][ii].second*3+i];
	    const double d2 = DIST(x_no,x_no_recv);
	    //cout << "node pair matches: ifa: " << ifa << " x_no: " << COUT_VEC(x_no) << " x_no_recv: " << COUT_VEC(x_no_recv) << " dist: " << sqrt(d2) << endl; 
	    my_d2_max[1] = max(my_d2_max[1],d2);
	  }
	  else {
	    //cout << "node pair DOES NOT match" << endl;
	  }
	}
      }
      assert(nnof_offset*3 == recv_count2_sum);
      assert(ghostFaMap.empty());
      delete[] recv_buf2_double;
      delete[] recv_buf_int;

      double d2_max[2];
      MPI_Reduce(my_d2_max,d2_max,2,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
      if (mpi_rank == 0) {
	cout << " > shadow face match (should be zero): " << sqrt(d2_max[0]) << endl;
	cout << " > shadow face node match (should be small): " << sqrt(d2_max[1]) << endl;
      }

      // ================================================
      // now build a common global node indexing...
      // ================================================
    
      int * noocv_i = new int[ncv+1];
      noocv_i[0] = 0;
      FOR_ICV {
	noocv_i[icv+1] = noocv_i[icv] + mainPart->cvdVec[icv].getNno();
	assert((noocv_i[icv+1] > 0)&&(noocv_i[icv+1] < TWO_BILLION ));
      }
      const int noocv_s = noocv_i[ncv];
    
      // and use d2_cv to link nodes based on distance...
    
      int * cnono = new int[noocv_s]; // compressed-node-of-node...
      int * cnocv_i = new int[ncv+1]; // compressed-node-of-cv 
      cnocv_i[0] = 0;
    
      FOR_ICV {
	int noc_offset = noocv_i[icv];
	for (int ino = 0; ino < mainPart->cvdVec[icv].getNno(); ++ino) 
	  cnono[noc_offset+ino] = ino;
	for (int ino0 = 0; ino0 < mainPart->cvdVec[icv].getNno(); ++ino0) {
	  for (int ino1 = ino0+1; ino1 < mainPart->cvdVec[icv].getNno(); ++ino1) {
	    const double d2 = DIST2(mainPart->cvdVec[icv].x_no[ino0],mainPart->cvdVec[icv].x_no[ino1]);
	    if (d2 < d2_tol_node*d2_cv[icv]) {
	      int ino0_ = cnono[noc_offset+ino0];
	      while (ino0_ != cnono[noc_offset+ino0_])
		ino0_ = cnono[noc_offset+ino0_];
	      int ino1_ = cnono[noc_offset+ino1];
	      while (ino1_ != cnono[noc_offset+ino1_])
		ino1_ = cnono[noc_offset+ino1_];
	      cnono[noc_offset+ino0_] = cnono[noc_offset+ino1_] = min(ino0_,ino1_);
	    }
	  }
	}
	// and count compressed nodes...
	int ncn = 0;
	for (int ino = 0; ino < mainPart->cvdVec[icv].getNno(); ++ino) {
	  if (cnono[noc_offset+ino] == ino) {
	    ++ncn;
	    cnono[noc_offset+ino] = -ncn;
	  }
	  else {
	    int icn = cnono[noc_offset+ino];
	    while (icn >= 0)
	      icn = cnono[noc_offset+icn];
	    cnono[noc_offset+ino] = icn;
	  }
	}
	for (int ino = 0; ino < mainPart->cvdVec[icv].getNno(); ++ino) {
	  assert(cnono[noc_offset+ino] < 0);
	  cnono[noc_offset+ino] = -cnono[noc_offset+ino]-1;
	}
	cnocv_i[icv+1] = cnocv_i[icv] + ncn;
      }
      delete[] d2_cv;
    
      const int cnocv_s = cnocv_i[ncv];

      int8 * cnora = NULL;
      buildXora(cnora,cnocv_s);
      assert(int8(cnocv_s) == cnora[mpi_rank+1]-cnora[mpi_rank]);
    
      // put a unique ordering in ino_global...
    
      int8 * ino_global = new int8[cnocv_s];
      for (int ino = 0; ino < cnocv_s; ++ino)
	ino_global[ino] = cnora[mpi_rank] + int8(ino);
    
      // --------------------------------
      // force node numbering to be common
      // by taking the minimum at all linked nodes...
      // --------------------------------
    
      FOR_RANK {
	send_count2[rank] /= 3;
	send_disp2[rank] /= 3;
	recv_count2[rank] /= 3;
	recv_disp2[rank] /= 3;
      }

      int8 * send_buf2_int8 = new int8[send_count2_sum/3];
      int8 * recv_buf2_int8 = new int8[recv_count2_sum/3];

      // for node coordinate HACK...
      send_buf2_double = new double[send_count2_sum];
      for (int ii = 0; ii < send_count2_sum; ++ii)
	send_buf2_double[ii] = 1.0E+20;

      recv_buf2_double = new double[recv_count2_sum];
    
#include "compressNodes.hpp"
    
      // now any face that has atleast 3 unique nodes gets included in the final output...

      int * noofa_count = new int[nfa_i];
      int noofa_s = 0;
    
      for (int ifa = 0; ifa < nfa_i; ++ifa) {
	assert((cvofa_global[ifa][0] >= cvora[mpi_rank])&&(cvofa_global[ifa][0] < cvora[mpi_rank+1]));
	const int icv = cvofa_global[ifa][0]-cvora[mpi_rank]; 
	assert((icv >= 0)&&(icv < ncv));
	if ((cvofa_global[ifa][1] >= cvora[mpi_rank])&&(cvofa_global[ifa][1] < cvora[mpi_rank+1])) {
	  // ==================================================================
	  // interior face...
	  // ==================================================================
	  const int icv_nbr = cvofa_global[ifa][1]-cvora[mpi_rank]; 
	  assert((icv_nbr >= 0)&&(icv_nbr < ncv));
	  assert(icv != icv_nbr);
	  // loop through the face nodes and reconcile the node numbering...
	  vector<int8> nodeVec;
	  for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	    const int ino = faNodeVec[ifa][ii].first;
	    int8 ino_g = -1;
	    if (ino >= 0) {
	      const int icn = cnono[noocv_i[icv]+ino];
	      ino_g = max(ino_global[cnocv_i[icv]+icn],-ino_global[cnocv_i[icv]+icn]-2);
	    }
	    const int ino_nbr = faNodeVec[ifa][ii].second;
	    int8 ino_g_nbr = -1;
	    if (ino_nbr >= 0) {
	      const int icn_nbr = cnono[noocv_i[icv_nbr]+ino_nbr];
	      ino_g_nbr = max(ino_global[cnocv_i[icv_nbr]+icn_nbr],-ino_global[cnocv_i[icv_nbr]+icn_nbr]-2);
	    }
	    // atleast one of the ghosts must be positive...
	    if (ino_g >= 0) {
	      assert((ino_g_nbr == -1)||(ino_g_nbr == ino_g));
	      if (nodeVec.empty() || nodeVec.back() != ino_g)
		nodeVec.push_back(ino_g);
	    }
	    else {
	      assert(ino_g_nbr >= 0);
	      assert(ino_g == -1);
	      if (nodeVec.empty() || nodeVec.back() != ino_g_nbr)
		nodeVec.push_back(ino_g_nbr);
	    }
	  }
	  assert(!nodeVec.empty());
	  // we may have added the same node at the beginning and the end...
	  if (nodeVec.back() == nodeVec.front())
	    nodeVec.pop_back();
	  // if there are 3 or more unique nodes, then we will be including this face, so flip ALL global nodes to -ve...
	  if (nodeVec.size() >= 3) {
	    for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	      const int ino = faNodeVec[ifa][ii].first;
	      if (ino >= 0) {
		const int icn = cnono[noocv_i[icv]+ino];
		if (ino_global[cnocv_i[icv]+icn] >= 0)
		  ino_global[cnocv_i[icv]+icn] = -ino_global[cnocv_i[icv]+icn]-2;
	      }
	      const int ino_nbr = faNodeVec[ifa][ii].second;
	      if (ino_nbr >= 0) {
		const int icn_nbr = cnono[noocv_i[icv_nbr]+ino_nbr];
		if (ino_global[cnocv_i[icv_nbr]+icn_nbr] >= 0)
		  ino_global[cnocv_i[icv_nbr]+icn_nbr] = -ino_global[cnocv_i[icv_nbr]+icn_nbr]-2;
	      }
	    }
	    noofa_count[ifa] = nodeVec.size();
	    noofa_s += nodeVec.size();
	  }
	  else {
	    cout << "got an internal face with nodeVec.size(): " << nodeVec.size() << endl;
	    noofa_count[ifa] = -1;
	  }
	}
	else {
	  // ==================================================================
	  // iter-processor boundary or periodic face...
	  // ==================================================================
	  // loop through the face nodes and reconcile the node numbering...
	  vector<int8> nodeVec;
	  for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	    const int ino = faNodeVec[ifa][ii].first;
	    int8 ino_g = -1;
	    if (ino >= 0) {
	      const int icn = cnono[noocv_i[icv]+ino];
	      ino_g = max(ino_global[cnocv_i[icv]+icn],-ino_global[cnocv_i[icv]+icn]-2);
	    }
	    const int irecv = faNodeVec[ifa][ii].second;
	    int8 ino_g_nbr = -1;
	    if (irecv >= 0) {
	      ino_g_nbr = max(recv_buf2_int8[irecv],-recv_buf2_int8[irecv]-2);
	    }
	    // atleast one of the ghosts must be positive...
	    if (ino_g >= 0) {
	      assert((ino_g_nbr == -1)||(ino_g_nbr == ino_g));
	      if (nodeVec.empty() || nodeVec.back() != ino_g)
		nodeVec.push_back(ino_g);
	    }
	    else {
	      assert(ino_g_nbr >= 0);
	      assert(ino_g == -1);
	      if (nodeVec.empty() || nodeVec.back() != ino_g_nbr)
		nodeVec.push_back(ino_g_nbr);
	    }
	  }
	  assert(!nodeVec.empty());
	  // we may have added the same node at the beginning and the end...
	  if (nodeVec.back() == nodeVec.front())
	    nodeVec.pop_back();
	  // if there are 3 or more unique nodes, then we will be including this face, so flip ALL global nodes to -ve...
	  if (nodeVec.size() >= 3) {
	    for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	      const int ino = faNodeVec[ifa][ii].first;
	      if (ino >= 0) {
		const int icn = cnono[noocv_i[icv]+ino];
		if (ino_global[cnocv_i[icv]+icn] >= 0)
		  ino_global[cnocv_i[icv]+icn] = -ino_global[cnocv_i[icv]+icn]-2;
	      }
	      const int irecv = faNodeVec[ifa][ii].second;
	      if (irecv >= 0) {
		if (recv_buf2_int8[irecv] >= 0)
		  recv_buf2_int8[irecv] = -recv_buf2_int8[irecv]-2;
	      }
	    }
	    noofa_count[ifa] = nodeVec.size();
	    noofa_s += nodeVec.size();
	  }
	  else {
	    cout << "got a boundary face with nodeVec.size(): " << nodeVec.size() << endl;
	    noofa_count[ifa] = -1;
	  }
	}
      }
    
      // now send back and make ino_global's negative...
    
      MPI_Alltoallv(recv_buf2_int8,recv_count2,recv_disp2,MPI_INT8,
		    send_buf2_int8,send_count2,send_disp2,MPI_INT8,
		    mpi_comm);
    
      {
	int ifa_shadow = 0;
	for (int ip = 0; ip < mainPart->points->np; ++ip) {
	  for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
	    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	      const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	      assert(ip != ip_nbr); // no self-connections
	      if (ip_nbr >= mainPart->points->np) {
		const int ig = ip_nbr - mainPart->points->np;
		int rank,bits,index;
		BitUtils::unpackRankBitsIndex(rank,bits,index,mainPart->rbiGhostVec[ig]);
		assert(bits == 0);
		assert(rank != mpi_rank);
		if (rank < mpi_rank) {
		  for (int ii = 0; ii < faShadowNodeVec[ifa_shadow].size(); ++ii) {
		    const int ino = faShadowNodeVec[ifa_shadow][ii];
		    const int icn = cnono[noocv_i[ip]+ino];
		    if (send_buf2_int8[send_disp2[rank]] < 0) {
		      if (ino_global[cnocv_i[ip]+icn] >= 0) {
			assert(ino_global[cnocv_i[ip]+icn] == -send_buf2_int8[send_disp2[rank]]-2);
			ino_global[cnocv_i[ip]+icn] = send_buf2_int8[send_disp2[rank]];
		      }
		      else {
			assert(ino_global[cnocv_i[ip]+icn] == send_buf2_int8[send_disp2[rank]]);
		      }
		    }
		    else {
		      assert(send_buf2_int8[send_disp2[rank]] == max(ino_global[cnocv_i[ip]+icn],-ino_global[cnocv_i[ip]+icn]-2));
		    }
		    ++send_disp2[rank];
		  }
		  ++ifa_shadow;
		}
	      }
	    }
	  }
	}
	assert(ifa_shadow == nfa_shadow);
      }
    
      // and reset send_disp2...

      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
    
      // =======================================
      // the boundary faces
      // -------------------
      // note that boundary faces cannot result in 
      // node condensation, but there may be nodes 
      // that specifically belong to just boundary faces, so we include them here...
      // =======================================

      vector<string> zoneVec;
      zoneVec.resize(mainPart->surface->zoneVec.size());
      for (int ii = 0; ii < mainPart->surface->zoneVec.size(); ++ii) {
	zoneVec[ii] = mainPart->surface->zoneVec[ii].getName();
	if (mpi_rank == 0) 
	  cout << " > got zone " << ii << " \"" << zoneVec[ii] << "\"" << endl;
      }
    
      int nfa_b = 0;
      for (int ip = 0; ip < mainPart->points->np; ++ip) {
	nfa_b += mainPart->cvdVec[ip].getNbf();
	//for (int ibf = 0; ibf < mainPart->cvdVec[ip].getNbf(); ++ibf) {
	//const int izone = mainPart->cvdVec[ip].getZnobf(ibf);
	//  assert((izone >= 0)&&(izone < zoneVec.size()));
	//  ++bfozn[izone+1];
	//}
      }
    
      vector<int> * bfNodeVec = new vector<int>[nfa_b];
      int * cvobf = new int[nfa_b];
      int * znobf = new int[nfa_b];
      int * noobf_count = new int[nfa_b];
      int noobf_s = 0;
    
      {
	int ifa_b = 0;
	for (int ip = 0; ip < mainPart->points->np; ++ip) {
	  for (int ibf = 0; ibf < mainPart->cvdVec[ip].getNbf(); ++ibf) {
	    cvobf[ifa_b] = ip;
	    const int izone = mainPart->cvdVec[ip].getZnobf(ibf);
	    assert((izone >= 0)&&(izone < zoneVec.size()));
	    znobf[ifa_b] = izone;
	    mainPart->cvdVec[ip].setBfNodeLoop(bfNodeVec[ifa_b],ibf);
	    // now the node loop...
	    vector<int8> nodeVec;
	    for (int ii = 0; ii < bfNodeVec[ifa_b].size(); ++ii) {
	      const int ino = bfNodeVec[ifa_b][ii];
	      const int icn = cnono[noocv_i[ip]+ino];
	      const int8 ino_g = max(ino_global[cnocv_i[ip]+icn],-ino_global[cnocv_i[ip]+icn]-2);
	      if (nodeVec.empty() || nodeVec.back() != ino_g)
		nodeVec.push_back(ino_g);
	    }
	    if (nodeVec.back() == nodeVec.front())
	      nodeVec.pop_back();
	    // if there are more than 3 unique nodes, then we will be including this face, so flip ALL global nodes to -ve...
	    if (nodeVec.size() >= 3) {
	      for (int ii = 0; ii < bfNodeVec[ifa_b].size(); ++ii) {
		const int ino = bfNodeVec[ifa_b][ii];
		const int icn = cnono[noocv_i[ip]+ino];
		if (ino_global[cnocv_i[ip]+icn] >= 0)
		  ino_global[cnocv_i[ip]+icn] = -ino_global[cnocv_i[ip]+icn]-2;
	      }
	      noobf_count[ifa_b] = nodeVec.size();
	      noobf_s += nodeVec.size();
	    }
	    else {
	      cout << "got a bf with nodeVec.size(): " << nodeVec.size() << endl;
	      noobf_count[ifa_b] = -1;
	    }
	    ++ifa_b;
	  }
	}
	assert(ifa_b == nfa_b);
      }
    
      // at this point, every face (fa and bf) we are keeping has its ino_global set -ve...

      // HACK
      for (int ii = 0; ii < send_count2_sum; ++ii)
	send_buf2_double[ii] = 1.0E+20;
    
#include "compressNodes.hpp"

      // now got through the nodes and set the -ve's we own to a small positive value, and
      // other negatives to a large value...
    
      int * local_buf = new int[cnocv_s];
      for (int ino = 0; ino < cnocv_s; ++ino) 
	local_buf[ino] = -1;
    
      for (int ino = 0; ino < cnocv_s; ++ino) {
	if ((-ino_global[ino]-2 >= cnora[mpi_rank])&&(-ino_global[ino]-2 < cnora[mpi_rank+1])) {
	  const int ino_local = -ino_global[ino]-cnora[mpi_rank]-2;
	  assert((ino_local >= 0)&&(ino_local < cnocv_s));
	  local_buf[ino_local] = 0;
	}
      }

      int nno = 0;
      for (int ino = 0; ino < cnocv_s; ++ino) 
	if (local_buf[ino] == 0) 
	  local_buf[ino] = nno++;
      int8 * noora = NULL;
      buildXora(noora,nno);
      assert(int8(nno) == noora[mpi_rank+1]-noora[mpi_rank]);
    
      if (mpi_rank == 0)
	cout << " > nno_global: " << noora[mpi_size] << endl;
    
      for (int ino = 0; ino < cnocv_s; ++ino) {
	if ((-ino_global[ino]-2 >= cnora[mpi_rank])&&(-ino_global[ino]-2 < cnora[mpi_rank+1])) {
	  const int ino_local = -ino_global[ino]-cnora[mpi_rank]-2;
	  assert((ino_local >= 0)&&(ino_local < cnocv_s));
	  assert(local_buf[ino_local] >= 0);
	  ino_global[ino] = noora[mpi_rank] + local_buf[ino_local];
	}
	else {
	  // everybody else just gets sets large - i.e. the final node count...
	  ino_global[ino] = noora[mpi_size];
	}
      }
    
      delete[] cnora;
      delete[] local_buf;

      // and compress one final time...

      // HACK
      for (int ii = 0; ii < send_count2_sum; ++ii)
	send_buf2_double[ii] = 1.0E+20;
    
#include "compressNodes.hpp"

      delete[] send_buf2_int8;

      // =========================================================
      // now build the final noofa_count and noofa_v_global...
      // =========================================================
    
      // send over the coordinates from the shadow faces...
      // HACK: need to realloc the send/recv double buf here? Maybe just keep it allocated until now...
      // also, this is already there because of the hack, but send again...

      {
	int ifa_shadow = 0;
	for (int ip = 0; ip < mainPart->points->np; ++ip) {
	  for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
	    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
	      const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
	      assert(ip != ip_nbr); // no self-connections
	      if (ip_nbr >= mainPart->points->np) {
		const int ig = ip_nbr - mainPart->points->np;
		int rank,bits,index;
		BitUtils::unpackRankBitsIndex(rank,bits,index,mainPart->rbiGhostVec[ig]);
		assert(bits == 0);
		assert(rank != mpi_rank);
		if (rank < mpi_rank) {
		  for (int ii = 0; ii < faShadowNodeVec[ifa_shadow].size(); ++ii) {
		    const int ino = faShadowNodeVec[ifa_shadow][ii];
		    const int icn = cnono[noocv_i[ip]+ino];
		    FOR_I3 send_buf2_double[send_disp2[rank]*3+i] = mainPart->cvdVec[ip].x_no[ino][i] + mainPart->points->xp[ip][i]; // put the actual node coord into the send_buf2_double
		    ++send_disp2[rank];
		  }
		  ++ifa_shadow;
		}
	      }
	    }
	  }
	}
	assert(ifa_shadow == nfa_shadow);
      }
      delete[] faShadowNodeVec;
    
      // reset send_disp2...
    
      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
      
      FOR_RANK {
	send_count2[rank] *= 3;
	send_disp2[rank] *= 3;
	recv_count2[rank] *= 3;
	recv_disp2[rank] *= 3;
      }
    
      MPI_Alltoallv(send_buf2_double,send_count2,send_disp2,MPI_DOUBLE,
		    recv_buf2_double,recv_count2,recv_disp2,MPI_DOUBLE,
		    mpi_comm);
      delete[] send_buf2_double;
    
      // nodes...
    
      double (*x_no)[3] = new double[nno][3];
      double (*x2_no)[3] = new double[nno][3];
      int * flag_no = new int[nno];
      FOR_INO {
	FOR_I3 x_no[ino][i] = 0.0;
	FOR_I3 x2_no[ino][i] = 0.0;
	flag_no[ino] = 0;
      }

      int8 * noofa_v_global = new int8[noofa_s];
      int noofa_s_check = 0;
    
      vector<int8> int8Vec;
      vector<double> doubleVec;

      for (int ifa = 0; ifa < nfa_i; ++ifa) if (noofa_count[ifa] != -1) {
	assert((cvofa_global[ifa][0] >= cvora[mpi_rank])&&(cvofa_global[ifa][0] < cvora[mpi_rank+1]));
	const int icv = cvofa_global[ifa][0]-cvora[mpi_rank]; 
	assert((icv >= 0)&&(icv < ncv));
	if ((cvofa_global[ifa][1] >= cvora[mpi_rank])&&(cvofa_global[ifa][1] < cvora[mpi_rank+1])) {
	  const int icv_nbr = cvofa_global[ifa][1]-cvora[mpi_rank]; 
	  assert((icv_nbr >= 0)&&(icv_nbr < ncv));
	  assert(icv != icv_nbr);
	  // loop through the face nodes and reconcile the node numbering...
	  vector<int> nodeVec;
	  for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	    const int ino = faNodeVec[ifa][ii].first;
	    int8 ino_g = -1;
	    if (ino >= 0) {
	      const int icn = cnono[noocv_i[icv]+ino];
	      ino_g = ino_global[cnocv_i[icv]+icn];
	    }
	    const int ino_nbr = faNodeVec[ifa][ii].second;
	    int8 ino_g_nbr = -1;
	    if (ino_nbr >= 0) {
	      const int icn_nbr = cnono[noocv_i[icv_nbr]+ino_nbr];
	      ino_g_nbr = ino_global[cnocv_i[icv_nbr]+icn_nbr];
	    }
	    // atleast one of the ghosts must be positive...
	    if (ino_g >= 0) {
	      assert((ino_g_nbr == -1)||(ino_g_nbr == ino_g));
	      if (nodeVec.empty() || nodeVec.back() != ino_g)
		nodeVec.push_back(ino_g);
	    }
	    else {
	      assert(ino_g_nbr >= 0);
	      assert(ino_g == -1);
	      if (nodeVec.empty() || nodeVec.back() != ino_g_nbr)
		nodeVec.push_back(ino_g_nbr);
	    }
	    // ---------------------
	    // update x_no...
	    // ---------------------
	    if (ino_g >= 0) {
	      if ((ino_g >= noora[mpi_rank])&&(ino_g < noora[mpi_rank+1])) {
		const int ino_local = ino_g-noora[mpi_rank];
		FOR_I3 x_no[ino_local][i] += mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i];
		FOR_I3 x2_no[ino_local][i] += pow(mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i],2);
		flag_no[ino_local] += 1;
	      }
	      else {
		// we need to send these coordinates to another rank...
		int8Vec.push_back(ino_g);
		FOR_I3 doubleVec.push_back(mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i]);
	      }
	    }
	    if (ino_g_nbr >= 0) {
	      if ((ino_g_nbr >= noora[mpi_rank])&&(ino_g_nbr < noora[mpi_rank+1])) {
		const int ino_local = int(ino_g_nbr-noora[mpi_rank]);
		FOR_I3 x_no[ino_local][i] += mainPart->cvdVec[icv_nbr].x_no[ino_nbr][i] + mainPart->points->xp[icv_nbr][i];
		FOR_I3 x2_no[ino_local][i] += pow(mainPart->cvdVec[icv_nbr].x_no[ino_nbr][i] + mainPart->points->xp[icv_nbr][i],2);
		flag_no[ino_local] += 1;
	      }
	      else {
		// we need to send these coordinates to another rank...
		int8Vec.push_back(ino_g_nbr);
		FOR_I3 doubleVec.push_back(mainPart->cvdVec[icv_nbr].x_no[ino_nbr][i] + mainPart->points->xp[icv_nbr][i]);
	      }
	    }
	  }
	  // we may have added the same node at the beginning and the end...
	  if (nodeVec.back() == nodeVec.front())
	    nodeVec.pop_back();
	  assert(nodeVec.size() >= 3);
	  assert(nodeVec.size() == noofa_count[ifa]);
	  for (int i = 0; i < nodeVec.size(); ++i) {
	    assert((nodeVec[i] >= 0)&&(nodeVec[i] < noora[mpi_size]));
	    noofa_v_global[noofa_s_check+i] = nodeVec[i];
	  }
	  noofa_s_check += nodeVec.size();
	}
	else {
	  // loop through the face nodes and reconcile the node numbering...
	  vector<int> nodeVec;
	  for (int ii = 0; ii < faNodeVec[ifa].size(); ++ii) {
	    const int ino = faNodeVec[ifa][ii].first;
	    int8 ino_g = -1;
	    if (ino >= 0) {
	      const int icn = cnono[noocv_i[icv]+ino];
	      ino_g = ino_global[cnocv_i[icv]+icn];
	    }
	    const int irecv = faNodeVec[ifa][ii].second;
	    int8 ino_g_nbr = -1;
	    if (irecv >= 0) {
	      ino_g_nbr = recv_buf2_int8[irecv];
	    }
	    // atleast one of the ghosts must be positive...
	    if (ino_g >= 0) {
	      assert((ino_g_nbr == -1)||(ino_g_nbr == ino_g));
	      if (nodeVec.empty() || nodeVec.back() != ino_g)
		nodeVec.push_back(ino_g);
	    }
	    else {
	      assert(ino_g_nbr >= 0);
	      assert(ino_g == -1);
	      if (nodeVec.empty() || nodeVec.back() != ino_g_nbr)
		nodeVec.push_back(ino_g_nbr);
	    }
	    // ---------------------
	    // update x_no...
	    // ---------------------
	    if (ino_g >= 0) {
	      if ((ino_g >= noora[mpi_rank])&&(ino_g < noora[mpi_rank+1])) {
		const int ino_local = ino_g-noora[mpi_rank];
		FOR_I3 x_no[ino_local][i] += mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i];
		FOR_I3 x2_no[ino_local][i] += pow(mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i],2);
		flag_no[ino_local] += 1;
	      }
	      else {
		int8Vec.push_back(ino_g);
		FOR_I3 doubleVec.push_back(mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i]);
	      }
	    }
	    if (ino_g_nbr >= 0) {
	      if ((ino_g_nbr >= noora[mpi_rank])&&(ino_g_nbr < noora[mpi_rank+1])) {
		const int ino_local = int(ino_g_nbr-noora[mpi_rank]);
		FOR_I3 x_no[ino_local][i] += recv_buf2_double[irecv*3+i];
		FOR_I3 x2_no[ino_local][i] += pow(recv_buf2_double[irecv*3+i],2);
		flag_no[ino_local] += 1;
	      }
	      else {
		int8Vec.push_back(ino_g_nbr);
		FOR_I3 doubleVec.push_back(recv_buf2_double[irecv*3+i]);
	      }
	    }
	  }
	  // we may have added the same node at the beginning and the end...
	  if (nodeVec.back() == nodeVec.front())
	    nodeVec.pop_back();
	  assert(nodeVec.size() >= 3);
	  assert(nodeVec.size() == noofa_count[ifa]);
	  for (int i = 0; i < nodeVec.size(); ++i) {
	    assert((nodeVec[i] >= 0)&&(nodeVec[i] < noora[mpi_size]));
	    noofa_v_global[noofa_s_check+i] = nodeVec[i];
	  }
	  noofa_s_check += nodeVec.size();
	}
      }
      assert(noofa_s_check == noofa_s);
      delete[] recv_buf2_int8;
      delete[] recv_buf2_double;
      delete[] faNodeVec;
    
      // and boundary faces...
    
      int8 * noobf_v_global = new int8[noobf_s];
      int noobf_s_check = 0;
      for (int ibf = 0; ibf < nfa_b; ++ibf) if (noobf_count[ibf] != -1) {
	const int icv = cvobf[ibf];
	// now the node loop...
	vector<int8> nodeVec;
	for (int ii = 0; ii < bfNodeVec[ibf].size(); ++ii) {
	  const int ino = bfNodeVec[ibf][ii];
	  const int icn = cnono[noocv_i[icv]+ino];
	  const int8 ino_g = ino_global[cnocv_i[icv]+icn];
	  if (nodeVec.empty() || nodeVec.back() != ino_g)
	    nodeVec.push_back(ino_g);
	  // and update x_no...
	  if ((ino_g >= noora[mpi_rank])&&(ino_g < noora[mpi_rank+1])) {
	    const int ino_local = ino_g-noora[mpi_rank];
	    FOR_I3 x_no[ino_local][i] += mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i];
	    FOR_I3 x2_no[ino_local][i] += pow(mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i],2);
	    flag_no[ino_local] += 1;
	  }
	  else {
	    int8Vec.push_back(ino_g);
	    FOR_I3 doubleVec.push_back(mainPart->cvdVec[icv].x_no[ino][i] + mainPart->points->xp[icv][i]);
	  }
	}
	if (nodeVec.back() == nodeVec.front())
	  nodeVec.pop_back();
	assert(nodeVec.size() >= 3);
	assert(nodeVec.size() == noobf_count[ibf]);
	for (int i = 0; i < nodeVec.size(); ++i) {
	  assert((nodeVec[i] >= 0)&&(nodeVec[i] < noora[mpi_size]));
	  noobf_v_global[noobf_s_check+i] = nodeVec[i];
	}
	noobf_s_check += nodeVec.size();
      }
      assert(noobf_s_check == noobf_s);
      delete[] bfNodeVec;
      delete[] noocv_i;
      delete[] cnono;
      delete[] cnocv_i;
      delete[] ino_global;
    
      // -------------------------------------------------------------------------------------
      // finally exchange the packed nodes and coordinate values that were not coincident...
      // -------------------------------------------------------------------------------------
    
      FOR_RANK send_count2[rank] = 0;
    
      int * rankArray = new int[int8Vec.size()];
      for (int ii = 0; ii < int8Vec.size(); ++ii) {
	assert((int8Vec[ii] >= 0)&&(int8Vec[ii] < noora[mpi_size]));
	rankArray[ii] = getRankInXora(int8Vec[ii],noora);
	++send_count2[rankArray[ii]];
      }
    
      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
      assert(int8Vec.size() == send_disp2[mpi_size-1] + send_count2[mpi_size-1]);
    
      int * send_buf2_int = new int[int8Vec.size()];
      assert(doubleVec.size() == int8Vec.size()*3);
      send_buf2_double = new double[int8Vec.size()*3];
    
      for (int ii = 0; ii < int8Vec.size(); ++ii) {
	const int rank = rankArray[ii];
	const int ino_local = int8Vec[ii] - noora[rank];
	send_buf2_int[send_disp2[rank]] = ino_local;
	FOR_I3 send_buf2_double[send_disp2[rank]*3+i] = doubleVec[ii*3+i];
	++send_disp2[rank];
      }
      delete[] rankArray;

      // and reset send_disp2...
    
      send_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	send_disp2[rank] = send_count2[rank-1] + send_disp2[rank-1];
    
      // recv side stuff...
    
      MPI_Alltoall(send_count2,1,MPI_INT,recv_count2,1,MPI_INT,mpi_comm);
    
      recv_disp2[0] = 0;
      for (int rank = 1; rank < mpi_size; ++rank)
	recv_disp2[rank] = recv_count2[rank-1] + recv_disp2[rank-1];
      const int recv_count2_sum2 = recv_disp2[mpi_size-1] + recv_count2[mpi_size-1];
    
      int * recv_buf2_int = new int[recv_count2_sum2];
      MPI_Alltoallv(send_buf2_int,send_count2,send_disp2,MPI_INT,
		    recv_buf2_int,recv_count2,recv_disp2,MPI_INT,
		    mpi_comm);
      delete[] send_buf2_int;
    
      FOR_RANK {
	send_count2[rank] *= 3;
	send_disp2[rank] *= 3;
	recv_count2[rank] *= 3;
	recv_disp2[rank] *= 3;
      }

      recv_buf2_double = new double[recv_count2_sum2*3];
      MPI_Alltoallv(send_buf2_double,send_count2,send_disp2,MPI_DOUBLE,
		    recv_buf2_double,recv_count2,recv_disp2,MPI_DOUBLE,
		    mpi_comm);
      delete[] send_buf2_double;
      delete[] send_count2;
      delete[] send_disp2;
      delete[] recv_count2;
      delete[] recv_disp2;
    
      for (int irecv = 0; irecv < recv_count2_sum2; ++irecv) {
	const int ino_local = recv_buf2_int[irecv];
	assert((ino_local >= 0)&&(ino_local < nno));
	FOR_I3 x_no[ino_local][i] += recv_buf2_double[irecv*3+i];
	FOR_I3 x2_no[ino_local][i] += pow(recv_buf2_double[irecv*3+i],2);
	flag_no[ino_local] += 1;
      }
      delete[] recv_buf2_int;
      delete[] recv_buf2_double;
    
      // ========================================================
      // now normalize x_no and check rms...
      // ========================================================
    
      FOR_INO {
	assert(flag_no[ino] > 0); // all nodes touched!
	const double tmp = 1.0/double(flag_no[ino]);
	FOR_I3 x_no[ino][i] *= tmp;
	FOR_I3 x2_no[ino][i] = sqrt( max(x2_no[ino][i]*tmp - x_no[ino][i]*x_no[ino][i],0.0) );
      }
      delete[] flag_no;
    
      dumpRange(x_no,nno,"X_NO");
      dumpRange(x2_no,nno,"X_NO RMS");
    
      delete[] x2_no;
    
      // now clean up a bit...
    
      int nfa_final = 0;
      noofa_s_check = 0;
      for (int ifa = 0; ifa < nfa_i; ++ifa) {
	if (noofa_count[ifa] != -1) {
	  cvofa_global[nfa_final][0] = cvofa_global[ifa][0];
	  cvofa_global[nfa_final][1] = cvofa_global[ifa][1];
	  noofa_count[nfa_final] = noofa_count[ifa];
	  noofa_s_check += noofa_count[nfa_final]; 
	  ++nfa_final;
	}
      }
      assert(noofa_s_check == noofa_s);
      int8 * faora = NULL;
      buildXora(faora,nfa_final);
      assert(int8(nfa_final) == faora[mpi_rank+1]-faora[mpi_rank]);
    
      int nbf_final = 0;
      noobf_s_check = 0;
      for (int ibf = 0; ibf < nfa_b; ++ibf) {
	if (noobf_count[ibf] != -1) {
	  cvobf[nbf_final] = cvobf[ibf];
	  znobf[nbf_final] = znobf[ibf];
	  noobf_count[nbf_final] = noobf_count[ibf];
	  noobf_s_check += noobf_count[nbf_final];
	  ++nbf_final;
	}
      }
      assert(noobf_s_check == noobf_s);
      int8 * bfora = NULL;
      buildXora(bfora,nbf_final);
      assert(int8(nbf_final) == bfora[mpi_rank+1]-bfora[mpi_rank]);
    
      // ==============================================================================
      // now write...
      // ==============================================================================
    
      char dummy[128];
      sprintf(dummy,"%s",filename.c_str());
      MPI_File_delete(dummy,MPI_INFO_NULL);
    
      MPI_File fh;
      MPI_File_open(mpi_comm,dummy,MPI_MODE_WRONLY|MPI_MODE_CREATE,MPI_INFO_NULL,&fh); // was MPI_INFO_NULL
    
      MPI_Offset offset = 0;
    
      if ( mpi_rank == 0 ) { 
	int itmp[2] = { UGP_IO_MAGIC_NUMBER, 2 };
	cout << " > UGP_IO_VERSION: " << itmp[1] << endl;
	MPI_File_write(fh,itmp,2,MPI_INT,MPI_STATUS_IGNORE);
      }
      offset += int_size*2;
    
      if ( mpi_rank == 0 ) { 
	Header header;
	sprintf(header.name,"NO_FA_CV_COUNTS");
	header.id = UGP_IO_NO_FA_CV_COUNTS;
	header.skip = header_size;
	cout << " > nno_global: " << noora[mpi_size] << endl;
	cout << " > nfa_global: " << bfora[mpi_size]+faora[mpi_size] << endl;
	cout << " > ncv_global: " << cvora[mpi_size] << endl;
	//header.idata[0] = noora[mpi_size];
	//header.idata[1] = bfora[mpi_size]+faora[mpi_size];
	//header.idata[2] = cvora[mpi_size];
	ByteSwap::setLswMswPairForInt8(header.idata+0,noora[mpi_size]);
	ByteSwap::setLswMswPairForInt8(header.idata+2,bfora[mpi_size]+faora[mpi_size]);
	ByteSwap::setLswMswPairForInt8(header.idata+4,cvora[mpi_size]);
	MPI_File_write(fh,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      offset += header_size;

      // ===========================================
      // face zone names.
      // include a default-internal zone as the last.
      // ===========================================
    
      if (mpi_rank == 0) {
	Header header;
	header.id       = UGP_IO_FA_ZONE_HEADER;
	header.skip     = header_size;
	header.idata[0] = FA_ZONE_BOUNDARY;
	for (int izone = 0; izone < zoneVec.size(); ++izone) {
	  sprintf(header.name,"%s",zoneVec[izone].c_str());
	  header.idata[1] = izone;
	  MPI_File_write(fh,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	}
	// last zone is internal...
	sprintf(header.name,"%s","default-internal");
	header.idata[0] = FA_ZONE_INTERNAL;
	header.idata[1] = zoneVec.size();
	MPI_File_write(fh,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      offset += (zoneVec.size()+1)*header_size;

      // ===========================================
      // and zone index for all faces...
      // ===========================================
    
      if ( mpi_rank == 0 ) { 
	cout << " > fa_zone..." << endl;
	Header header;
	sprintf(header.name,"FA_ZONE");
	header.id = UGP_IO_FA_ZONE;
	header.skip = header_size + (bfora[mpi_size]+faora[mpi_size])*int_size;
	header.idata[0] = bfora[mpi_size]+faora[mpi_size];
	//ByteSwap::setLswMswPairForInt8(header.idata+0,bfora[mpi_size]+faora[mpi_size]);
	MPI_File_write(fh,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      // boundary zone index in znobf...
      MPI_File_write_at_all(fh,offset+header_size+bfora[mpi_rank]*int_size,
			    znobf,nbf_final,MPI_INT,MPI_STATUS_IGNORE);
      // and for the internal faces, put them all in the last zone...
      {
	int * fa_zone = new int[nfa_final];
	for (int ifa = 0; ifa < nfa_final; ++ifa)
	  fa_zone[ifa] = zoneVec.size();
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_rank])*int_size,
			      fa_zone,nfa_final,MPI_INT,MPI_STATUS_IGNORE);
	delete[] fa_zone;
      }
      offset += header_size+(bfora[mpi_size]+faora[mpi_size])*int_size;

      // ===========================================
      // cv zone name -- just one called "fluid".
      // ===========================================
    
      if (mpi_rank == 0) {
	Header header;
	sprintf(header.name,"%s","fluid");
	header.id       = UGP_IO_CV_ZONE_HEADER;
	header.skip     = header_size;
	header.idata[0] = CV_ZONE_FLUID;
	header.idata[1] = 0;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      offset += header_size;

      // ===========================================
      // and zone index for all cvs...
      // ===========================================
    
      if ( mpi_rank == 0 ) { 
	cout << " > cv_zone..." << endl;
	Header header;
	sprintf(header.name,"CV_ZONE");
	header.id = UGP_IO_CV_ZONE;
	header.skip = header_size + cvora[mpi_size]*int_size;
	header.idata[0] = cvora[mpi_size];
	//ByteSwap::setLswMswPairForInt8(header.idata+0,bfora[mpi_size]+faora[mpi_size]);
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      // and for the internal faces, put them all in the last zone...
      {
	int * cv_zone = new int[ncv];
	for (int icv = 0; icv < ncv; ++icv)
	  cv_zone[icv] = 0;
	MPI_File_write_at_all(fh,offset+header_size+cvora[mpi_rank]*int_size,
			      cv_zone,ncv,MPI_INT,MPI_STATUS_IGNORE);
	delete[] cv_zone;
      }
      offset += header_size + cvora[mpi_size]*int_size;

      // ===========================================
      // noofa_i/v...
      // ===========================================
    
      /*
	{
      
	int8 * noofaora = NULL;
	buildXora(noofaora,noofa_s);
	assert(int8(noofa_s) == noofaora[mpi_rank+1]-noofaora[mpi_rank]);
      
	int8 * noobfora = NULL;
	buildXora(noobfora,noobf_s);
	assert(int8(noobf_s) == noobfora[mpi_rank+1]-noobfora[mpi_rank]);
      
	if ( mpi_rank == 0 ) { 
	Header header;
	sprintf(header.name,"NOOFA_I_AND_V_INT8");
	header.id        = UGP_IO_NOOFA_I_AND_V_INT8;
	header.skip      = header_size + (bfora[mpi_size]+faora[mpi_size])*int_size + (noobfora[mpi_size]+noofaora[mpi_size])*int8_size;
	ByteSwap::setLswMswPairForInt8(header.idata+0,bfora[mpi_size]+faora[mpi_size]);
	ByteSwap::setLswMswPairForInt8(header.idata+2,noobfora[mpi_size]+noofaora[mpi_size]);
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	}
      
	// counts...
	MPI_File_write_at_all(fh,offset+header_size+bfora[mpi_rank]*int_size,
	noobf_count,nbf_final,MPI_INT,MPI_STATUS_IGNORE);
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_rank])*int_size,
	noofa_count,nfa_final,MPI_INT,MPI_STATUS_IGNORE);
	// nodes...
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_size])*int_size+noobfora[mpi_rank]*int8_size,
	noobf_v_global,noobf_s,MPI_INT8,MPI_STATUS_IGNORE);
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_size])*int_size+(noobfora[mpi_size]+noofaora[mpi_rank])*int8_size,
	noofa_v_global,noofa_s,MPI_INT8,MPI_STATUS_IGNORE);
      
	offset += header_size + (bfora[mpi_size]+faora[mpi_size])*int_size + (noobfora[mpi_size]+noofaora[mpi_size])*int8_size;
      
	delete[] noobfora;
	delete[] noofaora;
      
	}
      */

      // ===========================================
      // hack for int-based write of noofa_i/v...
      // ===========================================
    
      {
      
	int8 * noofaora = NULL;
	buildXora(noofaora,noofa_s);
	assert(int8(noofa_s) == noofaora[mpi_rank+1]-noofaora[mpi_rank]);
      
	int8 * noobfora = NULL;
	buildXora(noobfora,noobf_s);
	assert(int8(noobf_s) == noobfora[mpi_rank+1]-noobfora[mpi_rank]);
      
	if ( mpi_rank == 0 ) { 
	  cout << " > noofa_i/v..." << endl;
	  Header header;
	  sprintf(header.name,"NOOFA_I_AND_V");
	  header.id        = UGP_IO_NOOFA_I_AND_V;
	  header.skip      = header_size + (bfora[mpi_size]+faora[mpi_size])*int_size + (noobfora[mpi_size]+noofaora[mpi_size])*int_size;
	  header.idata[0] = bfora[mpi_size]+faora[mpi_size];
	  // noofa_count gets written as 2 ints...
	  ByteSwap::setLswMswPairForInt8(header.idata+1,noobfora[mpi_size]+noofaora[mpi_size]);
	  MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
	}
      
	// counts...
	MPI_File_write_at_all(fh,offset+header_size+bfora[mpi_rank]*int_size,
			      noobf_count,nbf_final,MPI_INT,MPI_STATUS_IGNORE);
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_rank])*int_size,
			      noofa_count,nfa_final,MPI_INT,MPI_STATUS_IGNORE);
	// nodes...
	int * nooX_v = new int[max(noobf_s,noofa_s)];
      
	for (int nob = 0; nob < noobf_s; ++nob) {
	  assert(noobf_v_global[nob] < TWO_BILLION);
	  nooX_v[nob] = noobf_v_global[nob];
	}
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_size])*int_size+noobfora[mpi_rank]*int_size,
			      nooX_v,noobf_s,MPI_INT,MPI_STATUS_IGNORE);
      
	for (int nof = 0; nof < noofa_s; ++nof) {
	  assert(noofa_v_global[nof] < TWO_BILLION);
	  nooX_v[nof] = noofa_v_global[nof];
	}
      
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_size])*int_size+(noobfora[mpi_size]+noofaora[mpi_rank])*int_size,
			      nooX_v,noofa_s,MPI_INT,MPI_STATUS_IGNORE);
      
	delete[] nooX_v;
      
	offset += header_size + (bfora[mpi_size]+faora[mpi_size])*int_size + (noobfora[mpi_size]+noofaora[mpi_size])*int_size;
      
	delete[] noobfora;
	delete[] noofaora;
      
      }

      // ===========================================
      // hack for int-based cvofa...
      // ===========================================
    
      if ( mpi_rank == 0 ) { 
	cout << " > cvofa..." << endl;
	Header header;
	sprintf(header.name,"CVOFA");
	header.id        = UGP_IO_CVOFA;
	header.skip      = header_size + (bfora[mpi_size]+faora[mpi_size])*int_size*2;
	header.idata[0] = (bfora[mpi_size]+faora[mpi_size]);
	header.idata[1] = 2;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      {
      
	int (*cvoX_tmp)[2] = new int[max(nbf_final,nfa_final)][2];
      
	for (int ibf = 0; ibf < nbf_final; ++ibf) {
	  cvoX_tmp[ibf][0] = cvobf[ibf] + cvora[mpi_rank];
	  cvoX_tmp[ibf][1] = -1;
	}
	MPI_File_write_at_all(fh,offset+header_size+bfora[mpi_rank]*int_size*2,
			      cvoX_tmp,nbf_final*2,MPI_INT,MPI_STATUS_IGNORE);
      
	for (int ifa = 0; ifa < nfa_final; ++ifa) {
	  assert(cvofa_global[ifa][0] < TWO_BILLION);
	  cvoX_tmp[ifa][0] = cvofa_global[ifa][0];
	  assert(cvofa_global[ifa][1] < TWO_BILLION);
	  cvoX_tmp[ifa][1] = cvofa_global[ifa][1];
	}
	MPI_File_write_at_all(fh,offset+header_size+(bfora[mpi_size]+faora[mpi_rank])*int_size*2,
			      cvoX_tmp,nfa_final*2,MPI_INT,MPI_STATUS_IGNORE);
      
	delete[] cvoX_tmp;
      
      }
      offset += header_size + (bfora[mpi_size]+faora[mpi_size])*int_size*2;

      // ===========================================
      // x_no...
      // ===========================================
    
      if ( mpi_rank == 0 ) { 
	cout << " > x_no..." << endl;
	Header header;
	sprintf(header.name,"X_NO");
	header.id        = UGP_IO_X_NO;
	header.skip      = header_size + noora[mpi_size]*double_size*3;
	header.idata[0] = noora[mpi_size];
	header.idata[1] = 3;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      MPI_File_write_at_all(fh,offset+header_size+noora[mpi_rank]*double_size*3,
			    x_no,nno*3,MPI_DOUBLE,MPI_STATUS_IGNORE);
      offset += header_size + noora[mpi_size]*double_size*3;
    
      // ===========================================
      // final EOF...
      // ===========================================

      if (mpi_rank == 0) {
	cout << " > EOF..." << endl;
	Header header;
	header.id = UGP_IO_EOF;
	sprintf(header.name,"EOF");
	header.skip = header_size;
	MPI_File_write_at(fh,offset,&header,1,MPI_Header,MPI_STATUS_IGNORE);
      }
      offset += header_size;
    
      MPI_File_set_size(fh,offset);
      MPI_File_close(&fh);

      // ===========================================
      // cleanup
      // ===========================================
    
      delete[] cvofa_global;
      delete[] noofa_count;
      delete[] cvobf;
      delete[] znobf;
      delete[] noobf_count;
      delete[] x_no;
      delete[] noofa_v_global;
      delete[] noobf_v_global;
      delete[] cvora;
      delete[] noora;
      delete[] faora;
      delete[] bfora;

    }

#endif














CCCCCCCCCCC



    /*

      cvdVec[ip_nbr].clearAll();
      cvdVec[ip_nbr].status = -1;
      status = -1;
      return -1;
      }
      else {
      // cout << "dn_tol: " << dn_tol_match << " dn_zero: " << dn_zero << " dx_tol: " << dx_tol_match << " dx_zero: " << dx_zero << endl;
      // cout << "cvdVec[ip_nbr].status: " << cvdVec[ip_nbr].status << endl;
      // if we got here, then there is no matching face in ip_nbr, but there should be. The
      // likely problem is that the ip_nbr should have a larger delta -- i.e. its delta is not
      // large enough to have ip as a nbr...
      cvdVec[ip_nbr].clearAll();
      cvdVec[ip_nbr].status = -1;
      if ( points->delta[ip_nbr] <= sqrt(d2) )
      points->delta[ip_nbr] = 1.00001*sqrt(d2);
      else
      points->delta[ip_nbr] *= 1.5;
      status = -1;
      return -1;
      }

      }
    */
    


    /*
      if (status == -3) {
      // the nbr had faces left over that did not match us. We need to rebuild 
      // with bigger delta...
      double d2; 
      const int ip_nbr =  cvdVec[ip].getNbofa(ifa);
      if (ip_nbr < points->np) 
      d2 = DIST2(points->xp[ip],points->xp[ip_nbr]);
      else 
      d2 = DIST2(points->xp[ip],xpGhostVec[ip_nbr-points->np].x);
      cvdVec[ip].clearAll();
      cvdVec[ip].status = -1;
      if ( points->delta[ip_nbr] <= sqrt(d2) )
      points->delta[ip_nbr] = 1.00001*sqrt(d2);
      else
      points->delta[ip] *= 1.5;
      return -1;
      }
      else if (status == -2) {
      // there was no matching nbr, so we had better be 0... 
      assert(cvdVec[ip].ifa_bits[ifa] & ZERO_LOCAL_BIT);
      cvdVec[ip].ifa_bits[ifa] |= NO_NBR_BIT;
      return 0;
      }
      else if (status == -1) {
      // we did not match, so we need to revisit on the next iter...
      assert((cvdVec[ip].status == 0)||(cvdVec[ip].status == 1));
      cvdVec[ip].status = 0;
      if (debug_flag) {
      double d2; 
      const int ip_nbr =  cvdVec[ip].getNbofa(ifa);
      if (ip_nbr < points->np) 
      d2 = DIST2(points->xp[ip],points->xp[ip_nbr]);
      else 
      d2 = DIST2(points->xp[ip],xpGhostVec[ip_nbr-points->np].x);
      cvdVec[ip].clearAll();
      cvdVec[ip].status = -1;
      if ( points->delta[ip_nbr] <= sqrt(d2) )
      points->delta[ip_nbr] = 1.00001*sqrt(d2);
      else
      points->delta[ip] *= 1.5;
      }
      return -1;
      }
    */
    








  void setFromCuttableAndBuildInternalFaceStuffOld(const CuttableVoronoiData& cuttable,const Surface * const surface,const double x0[3]) {
    
    // this version tries to group faces. I do not recommend using it, because it
    // can get into robustness problems checking the Voronoi diagram. The 
    // routine above groups all faces touching any given nbr together into a single 
    // face for robust VD checking. When we have a valid VD, then we can go crazy 
    // with heuristics building the node loops, etc...
    
    assert(0);
    
    // we combine the setting from cuttable and building internal face stuff
    // because we reorder during setting to allow orphan handling...

    static int debug = 0;
    static int ocount = 0; // orphan count
    ++debug;
    //cout << "buildInternalFaceStuff: debug: " << debug << endl;

    ned = cuttable.ned; assert(ned > 0);
    nno = cuttable.nno; assert(nno > 0);
    
    // split nodes according to orphan groups first...
   
    {

      int * no_flag = new int[nno];
      FOR_INO no_flag[ino] = ino;
      FOR_IED {
	// decend the no_flag to get the terminal node number...
	int ino0 = no_flag[cuttable.nooed[ied][0]];
	while (ino0 != no_flag[ino0])
	  ino0 = no_flag[ino0];
	int ino1 = no_flag[cuttable.nooed[ied][1]];
	while (ino1 != no_flag[ino1])
	  ino1 = no_flag[ino1];
	if (ino0 < ino1)
	  no_flag[ino1] = ino0;
	else
	  no_flag[ino0] = ino1;
      }
    
      // now count the number of groups...
    
      ngr = 0;
      FOR_INO {
	if (no_flag[ino] == ino) {
	  ++ngr;
	  no_flag[ino] = -ngr;
	}
	else {
	  int ino_ = no_flag[ino];
	  while (ino_ >= 0)
	    ino_ = no_flag[ino_];
	  no_flag[ino] = ino_;
	}
      }

      // right now, no_flag contains -1,-2,-3,-4...
    
      //cout << "ngr: " << ngr << endl;
      assert(noogr == NULL);
      noogr = new int[ngr+1];

      assert(edogr == NULL);
      edogr = new int[ngr+1];
    
      if (ngr > 1) {

	// if there is more than one group, this means there are orphans
	// and we need to order the
	// nodes such that the first nodes are in the group containing
	// the voronoi vertex -- i.e. the primary group. The primary group
	// owns the face closes to the vertex (I think this is provably correct, because of the convexity of 
	// the internal faces. Note also that the fact that orphans exist implies boundary faces must
	// exist. To determine the face that is closest to 
	// the Voronoi vertex, we use the shared mem surface and find the closest tri from the 
	// surface.
      
	set<int> * istSet = new set<int>[ngr];
	FOR_IED {
	  FOR_I2 {
	    if (cuttable.faoed[ied][i] >= 0) {
	      const int igr = -no_flag[cuttable.nooed[ied][0]]-1;
	      assert(igr == -no_flag[cuttable.nooed[ied][1]]-1);
	      assert((igr >= 0)&&(igr < ngr));
	      istSet[igr].insert(cuttable.faoed[ied][i]);
	    }
	  }
	}

	double d2_closest;
	int igr_closest = -1;
	for (int igr = 0; igr < ngr; ++igr) {
	  for (set<int>::iterator iter = istSet[igr].begin(); iter != istSet[igr].end(); ++iter) {
	    const int ist = *iter;
	    const double this_d2 = getPointToTriDist2(x0,
						      surface->xp[surface->spost[ist][0]],
						      surface->xp[surface->spost[ist][1]],
						      surface->xp[surface->spost[ist][2]]);
	    if ((igr_closest == -1)||(this_d2 < d2_closest)) {
	      igr_closest = igr;
	      d2_closest = this_d2;
	    }
	  }
	}
	assert((igr_closest >= 0)&&(igr_closest < ngr));
	delete[] istSet;

	// now loop through the nodes and set the no_flag to the positive group index...
	for (int igr = 0; igr < ngr; ++igr)
	  noogr[igr+1] = 0;
	FOR_INO {
	  if (no_flag[ino] == -igr_closest-1) 
	    no_flag[ino] = 0;
	  else if (no_flag[ino] > -igr_closest-1)
	    no_flag[ino] = -no_flag[ino];
	  else
	    no_flag[ino] = -no_flag[ino]-1;
	  // and count...
	  const int igr = no_flag[ino];
	  assert((igr >= 0)&&(igr < ngr));
	  ++noogr[igr+1];
	}

	// and complete noogr...
	noogr[0] = 0;
	for (int igr = 0; igr < ngr; ++igr)
	  noogr[igr+1] += noogr[igr];
	assert(noogr[ngr] == nno);
      
	// now edges...
	for (int igr = 0; igr < ngr; ++igr)
	  edogr[igr+1] = 0;
      
	int * ed_flag = new int[ned];
	FOR_IED {
	  const int igr = no_flag[cuttable.nooed[ied][0]];
	  assert(igr == no_flag[cuttable.nooed[ied][1]]);
	  assert((igr >= 0)&&(igr < ngr));
	  ed_flag[ied] = igr;
	  ++edogr[igr+1];
	}

	edogr[0] = 0;
	for (int igr = 0; igr < ngr; ++igr)
	  edogr[igr+1] += edogr[igr];

	// copy over x_no and turn no_flag into a new index...

	assert(x_no == NULL);
	x_no = new double[nno][3];
	FOR_INO {
	  const int igr = no_flag[ino];
	  const int ino_new = noogr[igr]++;;
	  no_flag[ino] = ino_new;
	  FOR_I3 x_no[ino_new][i] = cuttable.x_no[ino][i];
	}

	// and return noogr...
	for (int igr = ngr-1; igr > 0; --igr)
	  noogr[igr] = noogr[igr-1];
	noogr[0] = 0;
	
	// copy over edge data...
	assert(nooed == NULL);
	nooed = new int[ned][2];
	assert(faoed == NULL);
	faoed = new int[ned][2];
	
	FOR_IED {
	  const int igr = ed_flag[ied];
	  const int ied_new = edogr[igr]++;
	  nooed[ied_new][0] = no_flag[cuttable.nooed[ied][0]];
	  nooed[ied_new][1] = no_flag[cuttable.nooed[ied][1]];
	  faoed[ied_new][0] = cuttable.faoed[ied][0];
	  faoed[ied_new][1] = cuttable.faoed[ied][1];
	}
      
	delete[] ed_flag;

	// and return edogr...
	for (int igr = ngr-1; igr > 0; --igr)
	  edogr[igr] = edogr[igr-1];
	edogr[0] = 0;
	
	//cout << "[" << mpi_rank << "] got orphans: " << ngr << ", xp: " << COUT_VEC(x0) << endl;
	//writeTecplotOrphans(ocount++,x0);
	//getchar();
	
      }
      else {
      
	// =============================================
	// for one group, all no_flags are simply 0...
	// =============================================
	assert(ngr == 1);
	noogr[0] = 0;
	noogr[1] = nno;
	edogr[0] = 0;
	edogr[1] = ned;
	assert(nooed == NULL);
	nooed = new int[ned][2];
	memcpy(nooed,cuttable.nooed,ned*2*sizeof(int));
	assert(faoed == NULL);
	faoed = new int[ned][2];
	memcpy(faoed,cuttable.faoed,ned*2*sizeof(int));
	assert(x_no == NULL);
	x_no = new double[nno][3];
	memcpy(x_no,cuttable.x_no,nno*3*sizeof(double));

      }
    
      delete[] no_flag;

    }
    
    // =========================================================================
    // now everything should be copied from cuttable and in correct group order
    // =========================================================================
    
    // note that this grouping algorithm is not guaranteed to be unique. It is possible
    // to form a figure-8 face that could be treated as either one or two faces...
    // this algorithm assumes the edges around each unique face occur in loops. Because
    // the sorted map pair has the node first, and nodes are currently in the group order,
    // the faces we produce will also be in group order...
    
    int (*faoed_flag)[2] = new int[ned][2];  
    {
      map<const pair<int,int>,pair<int,int> > faceNodeMap;
      FOR_IED {
	faoed_flag[ied][0] = -1;
	faoed_flag[ied][1] = -1;
	const int ino0 = nooed[ied][0];
	const int ino1 = nooed[ied][1];
	if (faoed[ied][0] <= -8) {
	  assert(faceNodeMap.find(pair<int,int>(ino0,faoed[ied][0])) == faceNodeMap.end());
	  faceNodeMap[pair<int,int>(ino0,faoed[ied][0])] = pair<int,int>(ino1,ied);
	}
	else {
	  assert(faoed[ied][0] >= 0);
	}
	if (faoed[ied][1] <= -8) {
	  assert(faceNodeMap.find(pair<int,int>(ino1,faoed[ied][1])) == faceNodeMap.end());
	  faceNodeMap[pair<int,int>(ino1,faoed[ied][1])] = pair<int,int>(ino0,-ied-1);
	}
	else {
	  assert(faoed[ied][1] >= 0);
	}
      }

      assert(nfa == 0);
      nfa = 0;
      while (!faceNodeMap.empty()) {
	map<const pair<int,int>,pair<int,int> >::iterator iter = faceNodeMap.begin();
	assert(iter != faceNodeMap.end());
	const int ino0 = iter->first.first;
	const int ifa = iter->first.second;
	int ino1 = iter->second.first;
	int ied = iter->second.second;
	if (ied >= 0) {
	  assert(faoed_flag[ied][0] == -1);
	  faoed_flag[ied][0] = nfa;
	}
	else {
	  assert(faoed_flag[-ied-1][1] == -1);
	  faoed_flag[-ied-1][1] = nfa;
	}
	faceNodeMap.erase(iter);
	while (ino1 != ino0) {
	  iter = faceNodeMap.find(pair<int,int>(ino1,ifa));
	  assert(iter != faceNodeMap.end());
	  ino1 = iter->second.first;
	  ied = iter->second.second;
	  if (ied >= 0) {
	    assert(faoed_flag[ied][0] == -1);
	    faoed_flag[ied][0] = nfa;
	  }
	  else {
	    assert(faoed_flag[-ied-1][1] == -1);
	    faoed_flag[-ied-1][1] = nfa;
	  }
	  faceNodeMap.erase(iter);
	}
	++nfa;
      }
    }

    assert(n_fa == NULL);
    assert(x_fa == NULL);
    assert(nbofa == NULL);
    assert(ifa_bits == NULL);
    assert(ifa_igr_nbr == NULL);
    
    n_fa = new double[nfa][3];
    x_fa = new double[nfa][3];
    nbofa = new int[nfa];
    ifa_bits = new uint[nfa];
    ifa_igr_nbr = new int[nfa];
    
    FOR_IFA {
      FOR_I3 n_fa[ifa][i] = 0.0;
      FOR_I3 x_fa[ifa][i] = 0.0;
      nbofa[ifa] = -1;
      ifa_bits[ifa] = 0;
      ifa_igr_nbr[ifa] = -1;
    }
    
    FOR_IED {
      if (faoed_flag[ied][0] >= 0) {
	const int ifa = faoed_flag[ied][0];
	const int ino = nbofa[ifa];
	if (ino == -1) {
	  // temporarily use nbofa to hold the node number -- it gets 
	  // corrected below...
	  nbofa[ifa] = nooed[ied][0];
	}
	else if (ino != nooed[ied][1]) {
	  const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][0]],x_no[nooed[ied][1]]);
	  FOR_I3 n_fa[ifa][i] += this_n[i];
	}
      }
      if (faoed_flag[ied][1] >= 0) {
	const int ifa = faoed_flag[ied][1];
	const int ino = nbofa[ifa];
	if (ino == -1) {
	  nbofa[ifa] = nooed[ied][1];
	}
	else if (ino != nooed[ied][0]) {
	  const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][1]],x_no[nooed[ied][0]]);
	  FOR_I3 n_fa[ifa][i] += this_n[i];
	}
      }
    }

    FOR_IED {
      if (faoed_flag[ied][0] >= 0) {
	const int ifa = faoed_flag[ied][0];
	const int ino = nbofa[ifa];
	if ((ino != nooed[ied][0])&&(ino != nooed[ied][1])) {
	  const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][0]],x_no[nooed[ied][1]]);
	  const double this_wgt = DOT_PRODUCT(this_n,n_fa[ifa]);
	  FOR_I3 x_fa[ifa][i] += this_wgt*(x_no[ino][i] + x_no[nooed[ied][0]][i] + x_no[nooed[ied][1]][i]);
	}
      }
      if (faoed_flag[ied][1] >= 0) {
	const int ifa = faoed_flag[ied][1];
	const int ino = nbofa[ifa];
	if ((ino != nooed[ied][0])&&(ino != nooed[ied][1])) {
	  const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][1]],x_no[nooed[ied][0]]);
	  const double this_wgt = DOT_PRODUCT(this_n,n_fa[ifa]);
	  FOR_I3 x_fa[ifa][i] += this_wgt*(x_no[ino][i] + x_no[nooed[ied][1]][i] + x_no[nooed[ied][0]][i]);
	}
      }
    }

    assert(faogr == NULL);
    faogr = new int[ngr+1];
    faogr[0] = 0;
    int igr = 0;
    FOR_IFA {
      
      // normalize x_fa...
      const double n2 = DOT_PRODUCT(n_fa[ifa],n_fa[ifa]);
      if (n2 > 0.0) {
	FOR_I3 x_fa[ifa][i] /= n2*3.0;
      }
      else {
	FOR_I3 x_fa[ifa][i] = 0.0; // we could try to set a better value here, but the face is useless anyways
      }
      
      // and multiply normal by 0.5...
      FOR_I3 n_fa[ifa][i] *= 0.5;
      
      // clear the nbofa...
      const int ino = nbofa[ifa];
      nbofa[ifa] = -1;
      
      // and set faogr...
      if (ino >= noogr[igr+1]) {
	assert(ino < noogr[igr+2]);
	faogr[igr+1] = ifa;
	++igr;
      }
      
    }
    faogr[ngr] = nfa;
    
    FOR_IED {
      FOR_I2 {
	if (faoed_flag[ied][i] >= 0) {
	  const int ifa = faoed_flag[ied][i];
	  if (nbofa[ifa] == -1) {
	    nbofa[ifa] = -faoed[ied][i]-8; 
	    assert(nbofa[ifa] >= 0);
	  }
	  else {
	    assert(nbofa[ifa] == -faoed[ied][i]-8);
	  }
	  // also, set the faoed to the negative face index...
	  assert(faoed[ied][i] <= -8);
	  faoed[ied][i] = -ifa-1;
	}
      }
    }
    
    delete[] faoed_flag;
    
    /*
      cout << "ngr: " << ngr << endl;
      FOR_IFA {
      assert(nbofa[ifa] >= 0);
      cout << "nbofa: " << nbofa[ifa] << endl;
      }
      getchar();
    */

    /*
      if (ngr > 1) {
      cout << "writing volume for ngr: " << ngr << endl;
      writeTecplot(debug,x0);
      getchar();
      }
    */

    //nfa_max = nfa;

  }




        
    
    




    /*
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    */
    
    
    
    
    
    
    
    

    
    
    
    
	

    
    

    MPI_Pause("SO FAR SO GOOD?");
    
    
    




















    
    


#ifdef fshjsfhjklfasd

    /*
  
  


    
    assert(x_bf == NULL); x_bf = new double[nbf][3];
    assert(n_bf == NULL); n_bf = new double[nbf][3];
    assert(znobf == NULL); znobf = new int[nbf];
    assert(cvobf == NULL); cvobf = new int[nbf];
      
    bfozn[0] = 0;
    for (int izone = 0; izone < zoneVec.size(); ++izone)
    bfozn[izone+1] += bfozn[izone];
    assert(bfozn[zoneVec.size()] == nbf);
      
    for (int ip = 0; ip < mainPart->points->np; ++ip) {
    for (int ibf = 0; ibf < mainPart->cvdVec[ip].getNbf(); ++ibf) {
    const int izone = mainPart->cvdVec[ip].getZnobf(ibf);
    const int ibf_solver = bfozn[izone]++;
    FOR_I3 x_bf[ibf_solver][i] = mainPart->cvdVec[ip].x_bf[ibf][i] + mainPart->points->xp[ip][i];
    FOR_I3 n_bf[ibf_solver][i] = mainPart->cvdVec[ip].n_bf[ibf][i];
    znobf[ibf_solver] = izone;
    cvobf[ibf_solver] = ip;
    // temporarily use the Znobf to store the ibf_solver. We need to remember to put this back below...
    mainPart->cvdVec[ip].setZnobf(ibf,ibf_solver);
    }
    }
    
    // reset bfozn...
    for (int izone = zoneVec.size()-1; izone > 0; --izone)
    bfozn[izone] = bfozn[izone-1];
    bfozn[0] = 0;
    
    assert(ppobf == NULL); // ppobf -- terminal parent-part of bf
    ppobf = new int[nbf];
    FOR_IBF ppobf[ibf] = -1;
      
    assert(spobf_i == NULL); // surface-point-of-bf i/v structure
    spobf_i = new int[nbf+1];
    FOR_IBF spobf_i[ibf+1] = 0;
    
    set<pair<int,int> > ibf_isp_set; 
    for (int ip = 0; ip < mainPart->points->np; ++ip) {
    ibf_isp_set.clear();
    for (int ict = 0; ict < mainPart->cvdVec[ip].getNct(); ++ict) if (mainPart->cvdVec[ip].area_ct[ict] > 0.0) {










    for (int ip = 0; ip < mainPart->points->np; ++ip) {
    nfa_b += mainPart->cvdV

    ncv_d = ncv;

    // set faces and figure out ghosts. Not that this will not be ALL the ghosts in the mainPart,
    // but a reduced number of them associated with actual connections to the points' Voronoi
    // diagrams...
    
    assert(mainPart->rbiGhostVec.size() == mainPart->xpGhostVec.size());
    assert(mainPart->rbiGhostVec.size() == mainPart->rbiGhostMap.size());
    int * flag_g = new int[mainPart->rbiGhostVec.size()];
    for (int ig = 0; ig < mainPart->rbiGhostVec.size(); ++ig)
    flag_g[ig] = -2;
    
    nfa_i = 0;
    nfa = 0;
    for (int ip = 0; ip < mainPart->points->np; ++ip) {
    for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
    const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
    assert(ip != ip_nbr); // no self-connections
    if (ip_nbr < mainPart->points->np) {
    // local face...
    if (ip_nbr > ip) {
    // this face should appear twice. Only count it when ip < ip_nbr
    ++nfa_i;
    }
    }
    else {
    const int ig = ip_nbr - mainPart->points->np;
    flag_g[ig] = -1;
    ++nfa;
    }
    }
    }
    }
    
    // now turn the flag_g into an index using the rbiGhostMap, because it is in rbi order...

    int * flag_g2 = new int[mainPart->rbiGhostVec.size()];
    
    int rank_count = 0;
    int rank_current = -1;
    ncv_dg = ncv_d;
    for (map<const uint8,int>::const_iterator iter = mainPart->rbiGhostMap.begin(); iter != mainPart->rbiGhostMap.end(); ++iter) {
    const int ig = iter->second;
    if (flag_g[ig] == -1) {
    flag_g2[ncv_dg-ncv_d] = ig;
    flag_g[ig] = ncv_dg++;
    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,iter->first);
    if (rank > rank_current) {
    ++rank_count;
    rank_current = rank;
    }
    else {
    assert(rank_current == rank);
    }
    }
    }
    
    // now build face stuff...
    
    nfa += nfa_i;
    assert(cvofa == NULL); cvofa = new int[nfa][2];
    assert(n_fa == NULL);  n_fa = new double[nfa][3];
    assert(x_fa == NULL);  x_fa = new double[nfa][3];
    
    double my_d2_max = 0.0;
    int ifa_i = 0;
    int ifa = nfa_i;
    for (int ip = 0; ip < mainPart->points->np; ++ip) {
    for (int ifa_ = 0; ifa_ < mainPart->cvdVec[ip].getNfa(); ++ifa_) {
    if ( (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip].ifa_bits[ifa_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)) ) {
    const int ip_nbr =  mainPart->cvdVec[ip].getNbofa(ifa_);
    assert(ip != ip_nbr); // no self-connections
    if (ip_nbr < mainPart->points->np) {
    // local face...
    if (ip_nbr > ip) {
    cvofa[ifa_i][0] = ip;
    cvofa[ifa_i][1] = ip_nbr;
    FOR_I3 x_fa[ifa_i][i] = mainPart->cvdVec[ip].x_fa[ifa_][i] + mainPart->points->xp[ip][i];
    // recall that mainPart->cvdVec[ip].ifa_igr_nbr contains the equal and opposite face...
    const int ifa_nbr_ = (mainPart->cvdVec[ip].ifa_igr_nbr[ifa_] >> 3); // discard group data for now -- revisit when orphans done
    assert((mainPart->cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_LOCAL_BIT|VALID_LOCAL_BIT)) && (mainPart->cvdVec[ip_nbr].ifa_bits[ifa_nbr_] & (NEAR_ZERO_NBR_BIT|VALID_NBR_BIT)));
    assert(mainPart->cvdVec[ip_nbr].getNbofa(ifa_nbr_) == ip);
    double x_fa_nbr[3]; FOR_I3 x_fa_nbr[i] = mainPart->cvdVec[ip_nbr].x_fa[ifa_nbr_][i] + mainPart->points->xp[ip_nbr][i];
    const double this_d2 =  DIST2(x_fa[ifa_i],x_fa_nbr);
    FOR_I3 x_fa[ifa_i][i] = 0.5*(x_fa[ifa_i][i] + x_fa_nbr[i]);
    // and the normal as the average....
    FOR_I3 n_fa[ifa_i][i] = 0.5*(mainPart->cvdVec[ip].n_fa[ifa_][i] - mainPart->cvdVec[ip_nbr].n_fa[ifa_nbr_][i]);
    my_d2_max = max(my_d2_max,this_d2);
    ++ifa_i;
    }
    }
    else {
    cvofa[ifa][0] = ip;
    const int ig = ip_nbr - mainPart->points->np;
    assert((flag_g[ig] >= ncv_d)&&(flag_g[ig] < ncv_dg));
    cvofa[ifa][1] = flag_g[ig];
    FOR_I3 x_fa[ifa][i] = mainPart->cvdVec[ip].x_fa[ifa_][i] + mainPart->points->xp[ip][i];
    FOR_I3 n_fa[ifa][i] = mainPart->cvdVec[ip].n_fa[ifa_][i]; // HACK -- take the full face normal on the one side for now
    ++ifa;
    }
    }
    }
    }

    delete[] flag_g; flag_g = NULL;

    assert(ifa_i == nfa_i);
    assert(ifa == nfa);
    
    // centroid stuff...
    
    assert(x_cv == NULL);   x_cv = new double[ncv_dg][3];
    
    assert(ncv == ncv_d);
    for (int icv = 0; icv < ncv; ++icv) {
    FOR_I3 x_cv[icv][i] = mainPart->points->xp[icv][i];
    }
    
    // use flag_g2 to pull from xpGhostVec...
    for (int icv = ncv_d; icv < ncv_dg; ++icv) {
    const int ig = flag_g2[icv-ncv_d];
    FOR_I3 x_cv[icv][i] = mainPart->xpGhostVec[ig].x[i];
    }
    
    // ===================================================
    // solver variables...
    // ===================================================
    
    assert(cv == NULL);
    cv = new IdealGasState[ncv_dg];
    
    // recall state...
    /*
    class IdealGasState { 
    public: 
    // cv attributes
    double vol;
    double vol0;
      
    // transported variables
    double rho; 
    double u[3]; 
    double rhoE; 
      
    // addtl primitive data/material properties
    double p;
    double h;
    double mu_total;
    double loc_total;
    double invRT;
    double invRTs; 
    double usq;
    double sor; // s/R
    double sos;
      
    //...and those not needed for the flux.
    double mu_lam;
    double mu_sgs;
    double loc_lam;
    double loc_sgs;
    double T;
    double cp;
    */
    
    double my_vol_sum = 0.0;
    for (int icv = 0; icv < ncv; ++icv) {
      cv[icv].vol = mainPart->cvdVec[icv].vol;
      my_vol_sum += cv[icv].vol;
      cv[icv].rho = rho_ref;
      cv[icv].u[0] = 0.0;
      cv[icv].u[1] = 0.0;
      cv[icv].u[2] = 0.0;

  
  
#endif
  





#ifdef OLD_BOUNCE_MOTION


  static double dxc_sum[3] = { 0.0, 0.0, 0.0 };
  static bool once = false;

  assert(motionVec.size() == 1);

  if (mpi_rank == 0)
    cout << "applying motion to part: " << getName() << endl;
    
  // hard code the domain bounds...
    
  const double x0 = -0.9;
  const double x1 = 2.1;
  const double y0 = -0.9;
  const double y1 = 1.1;
  const double r = 0.251;
    
  // hack the bounce motion model...
  const double xc0[3] = { xc[0], xc[1], xc[2] };
  FOR_I3 xc[i] += wc[i]*dt;
    
  // x-direction...
  if (xc[0]-r < x0) {
    assert(wc[0] < 0.0);
    wc[0] = -wc[0];
    xc[0] += x0-(xc[0]-r);
  }
  else if (xc[0]+r > x1) {
    assert(wc[0] > 0.0);
    wc[0] = -wc[0];
    xc[0] -= (xc[0]+r)-x1;
  }

  // y-direction...
  if (xc[1]-r < y0) {
    assert(wc[1] < 0.0);
    wc[1] = -wc[1];
    xc[1] += y0-(xc[1]-r);
  }
  else if (xc[1]+r > y1) {
    assert(wc[1] > 0.0);
    wc[1] = -wc[1];
    xc[1] -= (xc[1]+r)-y1;
  }

    
  // and the rotation matrix...
    
  const double dtheta = omega_z*dt;
  const double cos_dtheta = cos(dtheta);
  const double sin_dtheta = sin(dtheta);
  const double R[3][3] = { 
    { cos_dtheta, -sin_dtheta, 0.0 },
    { sin_dtheta, cos_dtheta,  0.0 },
    { 0.0,        0.0,         1.0 }
  };
        
  // and store dxc...
  FOR_I3 dxc[i] = xc[i] - xc0[i];
    
  // XXXXX hack into global scope data for now...
  FOR_I3 dxc_global[i] = dxc[i];    
    
  // debug hack...
  if (checkParam("XC_DEBUG")) {
    assert(!once);
    once = true;
    FILE * fp = fopen("xc_debug.bin","rb");
    fread(dxc,sizeof(double),3,fp);
    fclose(fp);
  }
    

  if (mpi_rank == 0)
    cout << "MOTION time: " << time << " xc: " << xc[0] << " " << xc[1] << " " << xc[2] << endl;
    
  // =============================================
  // now apply dxc to surface and points...
  // not sure if we want to carry these like this?
  // =============================================
    
  for (int ip = 0; ip < points->np; ++ip) {
      
    // store the relative x...
      
    double xr[3];
    FOR_I3 xr[i] = points->xp[ip][i] - xc0[i];
      
    // rotate this xr and add translation...
      
    FOR_I3 points->xp[ip][i] = DOT_PRODUCT(xr,R[i]) + xc[i];
      
  }

  // Surface
    
  // for the most general motion model, we store the old surface points
  // as part of the part (not the surface)...
  if (surface_xp0 == NULL) {
      
    surface_nsp0 = surface->nsp;
    MpiStuff::CTI_Mmap(surface_xp0,surface_nsp0);
    
  }

  if (mpi_rank_shared == 0) {
      
    // for motion treated in this way, the surface tris must be persistent over time. i.e.
    // we cannot prescribe an arbitrary motion to a part made up of parts in 
    // relative motion...
    assert(  surface_nsp0 == surface->nsp);
      
    for (int isp = 0; isp < surface->nsp; ++isp) {
	
      // backup the old 

      FOR_I3 surface_xp0[isp][i] = surface->xp[isp][i];
	
      // store the relative x...
	
      double xr[3];
      FOR_I3 xr[i] = surface->xp[isp][i] - xc0[i];
	
      // rotate this xr and add translation...
	
      FOR_I3 surface->xp[isp][i] = DOT_PRODUCT(xr,R[i]) + xc[i];
      
    }
      
  }
  MPI_Barrier(mpi_comm_shared);

  // HACK -- store displacement...
  if (mpi_rank == 0) {
      
    FOR_I3 dxc_sum[i] += dxc[i];
    FILE * fp = fopen("xc.bin","wb");
    fwrite(dxc_sum,sizeof(double),3,fp);
    fclose(fp);
    
  }
    
  return true;

}

#endif

















    
    


    
    
    

    /*
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    HEREHERE
    */

    /*
    _calcRhsImplicit(rhs0);
    
    for (int icv = 0; icv < ncv_d; ++icv) {
      if (implicit_flag_cv[icv] >= 0) {
	cout << "got implicit! " << rhs0[icv].rho << " " << COUT_VEC( rhs0[icv].rhou ) << " " << rhs0[icv].rhoE << endl;
      }
      else {
	cout << "got NOT implicit! " << rhs0[icv].rho << " " << COUT_VEC( rhs0[icv].rhou ) << " " << rhs0[icv].rhoE << endl;
      }
    }
    */
    
    MPI_Pause("how many");



#ifdef JUNKJUNK

  
  // =============================================================
  // now solve...
  // =============================================================
  
  double *drho0 = new double[nv_all];
  double (*drhou0)[3] = new double[nv_all][3];
  double *drhoE0 = new double[nv_all];
  
  double *drho1 = new double[nv_all];
  double (*drhou1)[3] = new double[nv_all][3];
  double *drhoE1 = new double[nv_all];
  
  double *drho2 = new double[nv_all];
  double (*drhou2)[3] = new double[nv_all][3];
  double *drhoE2 = new double[nv_all];
  
  calcRhs(drho0,drhou0,drhoE0,false);
  FOR_IV_ALL FOR_I3 drhou0[iv_all][i] += gcl_error[iv_all][i]*p[iv_all];

  double *rho0 = new double[nv_all];
  double (*rhou0)[3] = new double[nv_all][3];
  double *rhoE0 = new double[nv_all];
  
  // update all explicit values, and store state for implicits...
  
  FOR_IV_ALL {
    if (iv_implicit[iv_all]) {
      rho0[iv_all]            = rho[iv_all];
      FOR_I3 rhou0[iv_all][i] = rhou[iv_all][i];
      rhoE0[iv_all]           = rhoE[iv_all];
    }
    else {
      assert(volv[iv_all] > 0.0);
      rho[iv_all]              = ( dt*drho0[iv_all]     + volv0[iv_all]*rho[iv_all]     )/volv[iv_all];
      FOR_I3 rhou[iv_all][i]   = ( dt*drhou0[iv_all][i] + volv0[iv_all]*rhou[iv_all][i] )/volv[iv_all];
      rhoE[iv_all]             = ( dt*drhoE0[iv_all]    + volv0[iv_all]*rhoE[iv_all]    )/volv[iv_all];
    }
  }
  
  double *rho_rhs_implicit = new double[nv_all];
  double (*rhou_rhs_implicit)[3] = new double[nv_all][3];
  double *rhoE_rhs_implicit = new double[nv_all];
  
  int iter = 0;
  int done = 0;
  const double rho_zero = 1.0E-10; 
  while (done == 0) {
    
    ++iter;
    
    calcRhs(rho_rhs_implicit,rhou_rhs_implicit,rhoE_rhs_implicit,true);
    
    double my_res_max[5] = { 0.0, 0.0, 0.0, 0.0, 0.0 };
    FOR_IV_ALL {
      if (iv_implicit[iv_all]) {
	double res_rho     = 2.0*( dt*(drho0[iv_all]     + rho_rhs_implicit[iv_all])     - (volv[iv_all]*rho[iv_all] - volv0[iv_all]*rho0[iv_all]) )/(volv[iv_all] + volv0[iv_all]);
	double res_rhou[3];
	FOR_I3 res_rhou[i] = 2.0*( dt*(drhou0[iv_all][i] + rhou_rhs_implicit[iv_all][i]) - (volv[iv_all]*rhou[iv_all][i] - volv0[iv_all]*rhou0[iv_all][i]) )/(volv[iv_all] + volv0[iv_all]);
	double res_rhoE    = 2.0*( dt*(drhoE0[iv_all]    + rhoE_rhs_implicit[iv_all])    - (volv[iv_all]*rhoE[iv_all] - volv0[iv_all]*rhoE0[iv_all]) )/(volv[iv_all] + volv0[iv_all]);
	my_res_max[0] = max(my_res_max[0],fabs(res_rho));
	my_res_max[1] = max(my_res_max[1],fabs(res_rhou[0]));
	my_res_max[2] = max(my_res_max[2],fabs(res_rhou[1]));
	my_res_max[3] = max(my_res_max[3],fabs(res_rhou[2]));
	my_res_max[4] = max(my_res_max[4],fabs(res_rhoE));
	// correct implicit...
	const double relax = 0.5;
	rho[iv_all] += relax*res_rho;
	FOR_I3 rhou[iv_all][i] += relax*res_rhou[i];
	rhoE[iv_all] += relax*res_rhoE;
      }
      else {
	// should be identically zero...
	assert(rho_rhs_implicit[iv_all] == 0.0);
	FOR_I3 assert(rhou_rhs_implicit[iv_all][i] == 0.0);
	assert(rhoE_rhs_implicit[iv_all] == 0.0);
      }
    }
    double res_max[5];
    MPI_Reduce(my_res_max,res_max,5,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
    if (mpi_rank == 0) {
      cout << "iter, res: " << iter << " " << res_max[0] << " " << res_max[1] << " " << res_max[2] << " " << res_max[3] << " " << res_max[4] << endl;
      if ((res_max[0] < rho_zero)&&(res_max[1] < rho_zero)&&(res_max[2] < rho_zero)&&(res_max[3] < rho_zero)&&(res_max[4] < rho_zero))
	done = 1;
    }
    MPI_Bcast(&done,1,MPI_INT,0,mpi_comm);

    if ((done == 0)&&(iter == 100))
      done = 1;
    
    // we could make this a lot cheaper, but for now...
    
    updateCvData(rho);
    updateCvData(rhou);
    updateCvData(rhoE);
    eos->calcPTMuCpK(p,T,muLam,cp,kLam, rho,rhou,rhoE,nv_all+ng_all);
    
    // Calculate u
    for (int iv_all = 0; iv_all < nv_all+ng_all; ++iv_all) FOR_I3 u[iv_all][i] = rhou[iv_all][i]/rho[iv_all];
    
  }
  
  // we converged, so the state is updated. Return the implicit part in rho_rhs,etc...
  
  FOR_IV_ALL {
    if (iv_implicit[iv_all]) {
      drho0[iv_all] += rho_rhs_implicit[iv_all];
      FOR_I3 drhou0[iv_all][i] += rhou_rhs_implicit[iv_all][i];
      drhoE0[iv_all] += rhoE_rhs_implicit[iv_all];
    }
  }
  
  dumpMass(volv,rho,"MASS 1");
  dumpMomentum(volv,rhou,"MOMENTUM 1");
  dumpEnergy(volv,rhoE,"ENERGY 1");
  
  //MPI_Pause("done step 1");
  
  calcRhs(drho1,drhou1,drhoE1,false);
  FOR_IV_ALL FOR_I3 drhou1[iv_all][i] += gcl_error[iv_all][i]*p[iv_all];
  
  // update all explicit values, and store state for implicits...
  
  FOR_IV_ALL {
    if (iv_implicit[iv_all]) {
      rho0[iv_all]            = rho[iv_all];
      FOR_I3 rhou0[iv_all][i] = rhou[iv_all][i];
      rhoE0[iv_all]           = rhoE[iv_all];
    }
    else {
      rho[iv_all]              = 2.0*( dt*(0.25*drho1[iv_all]     - 0.75*drho0[iv_all])     + volv[iv_all]*rho[iv_all]     )/(volv[iv_all] + volv0[iv_all]);
      FOR_I3 rhou[iv_all][i]   = 2.0*( dt*(0.25*drhou1[iv_all][i] - 0.75*drhou0[iv_all][i]) + volv[iv_all]*rhou[iv_all][i] )/(volv[iv_all] + volv0[iv_all]);
      rhoE[iv_all]             = 2.0*( dt*(0.25*drhoE1[iv_all]    - 0.75*drhoE0[iv_all])    + volv[iv_all]*rhoE[iv_all]    )/(volv[iv_all] + volv0[iv_all]);
    }
  }
  
  iter = 0;
  done = 0;
  while (done == 0) {
    
    ++iter;
    
    calcRhs(rho_rhs_implicit,rhou_rhs_implicit,rhoE_rhs_implicit,true);
    
    double my_res_max[5] = { 0.0, 0.0, 0.0, 0.0, 0.0 };
    FOR_IV_ALL {
      if (iv_implicit[iv_all]) {
	double res_rho     = 2.0*( dt*(0.25*(drho1[iv_all] + rho_rhs_implicit[iv_all]) - 0.75*drho0[iv_all]) - (0.5*(volv[iv_all] + volv0[iv_all])*rho[iv_all] - volv[iv_all]*rho0[iv_all]) )/(volv[iv_all] + volv0[iv_all]);
	double res_rhou[3];
	FOR_I3 res_rhou[i] = 2.0*( dt*(0.25*(drhou1[iv_all][i] + rhou_rhs_implicit[iv_all][i]) - 0.75*drhou0[iv_all][i]) - (0.5*(volv[iv_all] + volv0[iv_all])*rhou[iv_all][i] - volv[iv_all]*rhou0[iv_all][i]) )/(volv[iv_all] + volv0[iv_all]);
	double res_rhoE    = 2.0*( dt*(0.25*(drhoE1[iv_all] + rhoE_rhs_implicit[iv_all]) - 0.75*drhoE0[iv_all]) - (0.5*(volv[iv_all] + volv0[iv_all])*rhoE[iv_all] - volv[iv_all]*rhoE0[iv_all]) )/(volv[iv_all] + volv0[iv_all]);
	my_res_max[0] = max(my_res_max[0],fabs(res_rho));
	my_res_max[1] = max(my_res_max[1],fabs(res_rhou[0]));
	my_res_max[2] = max(my_res_max[2],fabs(res_rhou[1]));
	my_res_max[3] = max(my_res_max[3],fabs(res_rhou[2]));
	my_res_max[4] = max(my_res_max[4],fabs(res_rhoE));
	// correct implicit...
	const double relax = 0.5;
	rho[iv_all] += relax*res_rho;
	FOR_I3 rhou[iv_all][i] += relax*res_rhou[i];
	rhoE[iv_all] += relax*res_rhoE;
      }
      else {
	// should be identically zero...
	assert(rho_rhs_implicit[iv_all] == 0.0);
	FOR_I3 assert(rhou_rhs_implicit[iv_all][i] == 0.0);
	assert(rhoE_rhs_implicit[iv_all] == 0.0);
      }
    }
    double res_max[5];
    MPI_Reduce(my_res_max,res_max,5,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
    if (mpi_rank == 0) {
      cout << "iter, res: " << iter << " " << res_max[0] << " " << res_max[1] << " " << res_max[2] << " " << res_max[3] << " " << res_max[4] << endl;
      if ((res_max[0] < rho_zero)&&(res_max[1] < rho_zero)&&(res_max[2] < rho_zero)&&(res_max[3] < rho_zero)&&(res_max[4] < rho_zero))
	done = 1;
    }
    MPI_Bcast(&done,1,MPI_INT,0,mpi_comm);

    if ((done == 0)&&(iter == 100))
      done = 1;
    
    // we could make this a lot cheaper, but for now...
    
    updateCvData(rho);
    updateCvData(rhou);
    updateCvData(rhoE);
    eos->calcPTMuCpK(p,T,muLam,cp,kLam, rho,rhou,rhoE,nv_all+ng_all);
    
    // Calculate u
    for (int iv_all = 0; iv_all < nv_all+ng_all; ++iv_all) FOR_I3 u[iv_all][i] = rhou[iv_all][i]/rho[iv_all];
    
  }
  
  // we converged, so the state is updated. Return the implicit part in rho_rhs,etc...
  
  FOR_IV_ALL {
    if (iv_implicit[iv_all]) {
      drho1[iv_all] += rho_rhs_implicit[iv_all];
      FOR_I3 drhou1[iv_all][i] += rhou_rhs_implicit[iv_all][i];
      drhoE1[iv_all] += rhoE_rhs_implicit[iv_all];
    }
  }
  
  {
    double * volv_avg = new double[nv_all];
    FOR_IV_ALL volv_avg[iv_all] = 0.5*(volv[iv_all] + volv0[iv_all]);
    dumpMass(volv_avg,rho,"MASS 2");
    dumpMomentum(volv_avg,rhou,"MOMENTUM 2");
    dumpEnergy(volv_avg,rhoE,"ENERGY 2");
    delete[] volv_avg;
  }
  
  //MPI_Pause("done step 2");
  
  calcRhs(drho2,drhou2,drhoE2,false);
  FOR_IV_ALL FOR_I3 drhou2[iv_all][i] += gcl_error[iv_all][i]*p[iv_all];

  // update all explicit values, and store state for implicits...
  
  FOR_IV_ALL {
    if (iv_implicit[iv_all]) {
      rho0[iv_all]            = rho[iv_all];
      FOR_I3 rhou0[iv_all][i] = rhou[iv_all][i];
      rhoE0[iv_all]           = rhoE[iv_all];
    }
    else {
      rho[iv_all]              = ( dt*(8.0*drho2[iv_all]     - drho1[iv_all]     - drho0[iv_all]     )/12.0 + 0.5*(volv[iv_all] + volv0[iv_all])*rho[iv_all]     )/volv[iv_all];
      FOR_I2 rhou[iv_all][i]   = ( dt*(8.0*drhou2[iv_all][i] - drhou1[iv_all][i] - drhou0[iv_all][i] )/12.0 + 0.5*(volv[iv_all] + volv0[iv_all])*rhou[iv_all][i] )/volv[iv_all];
      rhoE[iv_all]             = ( dt*(8.0*drhoE2[iv_all]    - drhoE1[iv_all]    - drhoE0[iv_all]    )/12.0 + 0.5*(volv[iv_all] + volv0[iv_all])*rhoE[iv_all]    )/volv[iv_all];
    }
  }
  
  iter = 0;
  done = 0;
  while (done == 0) {
    
    ++iter;
    
    calcRhs(rho_rhs_implicit,rhou_rhs_implicit,rhoE_rhs_implicit,true);
    
    double my_res_max[5] = { 0.0, 0.0, 0.0, 0.0, 0.0 };
    FOR_IV_ALL {
      if (iv_implicit[iv_all]) {
	double res_rho     = 2.0*( dt*(8.0*(drho2[iv_all] + rho_rhs_implicit[iv_all])         - drho1[iv_all]     - drho0[iv_all]     )/12.0 - ( volv[iv_all]*rho[iv_all] - 0.5*(volv[iv_all] + volv0[iv_all])*rho0[iv_all] ) )/(volv[iv_all] + volv0[iv_all]);
	double res_rhou[3];
	FOR_I3 res_rhou[i] = 2.0*( dt*(8.0*(drhou2[iv_all][i] + rhou_rhs_implicit[iv_all][i]) - drhou1[iv_all][i] - drhou0[iv_all][i] )/12.0 - ( volv[iv_all]*rhou[iv_all][i] - 0.5*(volv[iv_all] + volv0[iv_all])*rhou0[iv_all][i] ) )/(volv[iv_all] + volv0[iv_all]);
	double res_rhoE    = 2.0*( dt*(8.0*(drhoE2[iv_all] + rhoE_rhs_implicit[iv_all])         - drhoE1[iv_all]     - drhoE0[iv_all] )/12.0 - ( volv[iv_all]*rhoE[iv_all] - 0.5*(volv[iv_all] + volv0[iv_all])*rhoE0[iv_all] ) )/(volv[iv_all] + volv0[iv_all]);
	my_res_max[0] = max(my_res_max[0],fabs(res_rho));
	my_res_max[1] = max(my_res_max[1],fabs(res_rhou[0]));
	my_res_max[2] = max(my_res_max[2],fabs(res_rhou[1]));
	my_res_max[3] = max(my_res_max[3],fabs(res_rhou[2]));
	my_res_max[4] = max(my_res_max[4],fabs(res_rhoE));
	// correct implicit...
	const double relax = 0.5;
	rho[iv_all] += relax*res_rho;
	FOR_I3 rhou[iv_all][i] += relax*res_rhou[i];
	rhoE[iv_all] += relax*res_rhoE;
      }
      else {
	// should be identically zero...
	assert(rho_rhs_implicit[iv_all] == 0.0);
	FOR_I3 assert(rhou_rhs_implicit[iv_all][i] == 0.0);
	assert(rhoE_rhs_implicit[iv_all] == 0.0);
      }
    }
    double res_max[5];
    MPI_Reduce(my_res_max,res_max,5,MPI_DOUBLE,MPI_MAX,0,mpi_comm);
    if (mpi_rank == 0) {
      cout << "iter, res: " << iter << " " << res_max[0] << " " << res_max[1] << " " << res_max[2] << " " << res_max[3] << " " << res_max[4] << endl;
      if ((res_max[0] < rho_zero)&&(res_max[1] < rho_zero)&&(res_max[2] < rho_zero)&&(res_max[3] < rho_zero)&&(res_max[4] < rho_zero))
	done = 1;
    }
    MPI_Bcast(&done,1,MPI_INT,0,mpi_comm);

    if ((done == 0)&&(iter == 100))
      done = 1;
    
    // we could make this a lot cheaper, but for now...
    
    updateCvData(rho);
    updateCvData(rhou);
    updateCvData(rhoE);
    eos->calcPTMuCpK(p,T,muLam,cp,kLam, rho,rhou,rhoE,nv_all+ng_all);
    
    // Calculate u
    for (int iv_all = 0; iv_all < nv_all+ng_all; ++iv_all) FOR_I3 u[iv_all][i] = rhou[iv_all][i]/rho[iv_all];
    
  }
  
  delete[] rho_rhs_implicit;
  delete[] rhou_rhs_implicit;
  delete[] rhoE_rhs_implicit;
  
  delete[] rho0;
  delete[] rhou0;
  delete[] rhoE0;
  
  dumpMass(volv,rho,"MASS 3");
  dumpMomentum(volv,rhou,"MOMENTUM 3");
  dumpEnergy(volv,rhoE,"ENERGY 3");

  //MPI_Pause("done step 3");

  /*
    my_buf[0] = 0.0;
    my_buf[1] = 0.0;
    my_buf[2] = 0.0;
    // should be either a positive value or zero if it is a new cell
    // go over all to include disappearing cells
    FOR_IV_ALL {
    my_buf[0] += rho0[iv_all]*volv0[iv_all];
    FOR_I3 my_buf[1] += rhou0[iv_all][i]*volv0[iv_all];
    my_buf[2] += rhoE0[iv_all]*volv0[iv_all];
    }
    double buf_old[3];
    MPI_Reduce(my_buf,buf_old,3,MPI_DOUBLE,MPI_SUM,0,mpi_comm);

    my_buf[0] = 0.0;
    my_buf[1] = 0.0;
    my_buf[2] = 0.0;
    FOR_IV {
    // just the iv range...
    my_buf[0] += rho[iv]*volv[iv];
    FOR_I3 my_buf[1] += rhou[iv][i]*volv[iv];
    my_buf[2] += rhoE[iv]*volv[iv];
    }

    MPI_Reduce(my_buf,buf,3,MPI_DOUBLE,MPI_SUM,0,mpi_comm);
    if (mpi_rank == 0) {
    cout << "Time, step ---- " << time << " " << step << endl;
    cout << "Mass before, after: " << buf_old[0] << " " << buf[0] << " diff: " << buf[0]-buf_old[0] << endl;
    cout << "Momentum before, after: " << buf_old[1] << " " << buf[1] << " diff: " << buf[1]-buf_old[1] << endl;
    cout << "Energy   before, after: " << buf_old[2] << " " << buf[2] << " diff: " << buf[2]-buf_old[2] << endl;
    }
  */

  COUT1("====New variable range at n+1 ======");
  dumpRange(rho,nv,"RHO");
  dumpRange(rhou,nv,"RHOU");
  dumpRange(rhoE,nv,"RHOE");
  
  {
    double * drhoE = new double[nv];
    FOR_IV drhoE[iv] = rhoE[iv] - 253312.5;
    dumpRange(drhoE,nv,"DRHOE");
    delete[] drhoE;
  }

  dumpRange(p,nv,"P");
  dumpRange(T,nv,"T");
  //MPI_Pause("Done with flow step");
  COUT1("===== Done with Flow Solution =====");
  MPI_Sync("done FlowSolver::advanceStepFlowExplicit()");

  if (debug) {
    MPI_Pause("Done with flow step");
    debug = false;
  }
  
  // cleanup...
  
  delete[] drho0;
  delete[] drhou0;
  delete[] drhoE0;
  
  delete[] drho1;
  delete[] drhou1;
  delete[] drhoE1;
  
  delete[] drho2;
  delete[] drhou2;
  delete[] drhoE2;
  
  DELETE(iv_implicit);
  DELETE(fa_implicit);

  delete[] gcl_error;

    
    
    
















    
    





DONEDONE
    

#endif
  
















#ifdef JUNKJNKJJK    
	      
	      











	      if (cvdVec[ip].getNgr() > 1)
		cout << "got: ip_nbr: " << ip_nbr << " igr: " << igr << " ifa: " << ifa << endl;
	    }
	    if (cvdVec[ip].getNgr() > 1)
	      getchar();
	  }
	  

	  for (int igr = 0; igr < cvdVec[ip].getNgr(); ++igr) {
	    for (int ifa = cvdVec[ip].getFaogr(igr); ifa != cvdVec[ip].getFaogr(igr+1); ++ifa) if (!cvdVec[ip].checkFaceBit(ifa,NBR_FACE_BIT)) {
	      
	      const int ip_nbr = cvdVec[ip].getNbofa(ifa);
	      assert(ip_nbr != ip);
	      assert(ip_nbr >= 0);
	    
	      if (ip_nbr < points->np) {

		// ------------------------------------------------------------
		// this is a local nbr...
		// ------------------------------------------------------------
		
		// the common length scale for normalization is the nbr distance (squared)...
		
		const double d2_nbr = DIST2(points->xp[ip],points->xp[ip_nbr]);
		
		// if this a zero_face?...
		
		int zero_face;
		if (!cvdVec[ip].checkFaceBit(ifa,LOCAL_FACE_BIT)) {
		
		  // we have not visited this face locally yet, so do the math to see if this 
		  // face is a zero face...
  
		  const double n_tol = DOT_PRODUCT(cvdVec[ip].n_fa[ifa],cvdVec[ip].n_fa[ifa])/(d2_nbr*d2_nbr);
		  zero_face = (n_tol < dn_zero);
		  
		  // everything over getNfa should be zero...
		  //if (ifa >= cvdVec[ip].getNfaMax())
		  //  assert(zero_face);
		  
		  cvdVec[ip].setFaceBit(ifa,LOCAL_FACE_BIT);
		  if (zero_face) cvdVec[ip].setFaceBit(ifa,ZERO_LOCAL_FACE_BIT);
		  else cvdVec[ip].setFaceBit(ifa,NON_ZERO_LOCAL_FACE_BIT);
		  
		}
		else {
		  
		  zero_face = cvdVec[ip].checkFaceBit(ifa,ZERO_LOCAL_FACE_BIT);
		  
		}
		
		// look for a local match. Note that although all ip_status should be non-(-1) coming
		// into this routine, some may have been told to rebuild by this point...
		// could be old (-2) or new (0,1,2...)...
		
		if (ip_status[ip_nbr] != -1) {
		  
		  // the nbr exists...
		  
		  int ifa_nbr_matched = -1;
		  int igr_nbr_matched = -1;
		  for (int igr_nbr = 0; igr_nbr < cvdVec[ip_nbr].getNgr(); ++igr_nbr) {
		    for (int ifa_nbr = cvdVec[ip_nbr].getFaogr(igr_nbr); ifa_nbr != cvdVec[ip_nbr].getFaogr(igr_nbr+1); ++ifa_nbr) {
		      
		      if (cvdVec[ip_nbr].getNbofa(ifa_nbr) == ip) {
		      
			// compare faces and look for match...
		      
			const double n_sum[3] = {
			  cvdVec[ip].n_fa[ifa][0] + cvdVec[ip_nbr].n_fa[ifa_nbr][0],
			  cvdVec[ip].n_fa[ifa][1] + cvdVec[ip_nbr].n_fa[ifa_nbr][1],
			  cvdVec[ip].n_fa[ifa][2] + cvdVec[ip_nbr].n_fa[ifa_nbr][2] };
			const double n_sum_tol = DOT_PRODUCT(n_sum,n_sum)/(d2_nbr*d2_nbr);
		      
			const double dx[3] = {
			  cvdVec[ip].x_fa[ifa][0] - cvdVec[ip_nbr].x_fa[ifa_nbr][0] + (points->xp[ip][0] - points->xp[ip_nbr][0]),
			  cvdVec[ip].x_fa[ifa][1] - cvdVec[ip_nbr].x_fa[ifa_nbr][1] + (points->xp[ip][1] - points->xp[ip_nbr][1]),
			  cvdVec[ip].x_fa[ifa][2] - cvdVec[ip_nbr].x_fa[ifa_nbr][2] + (points->xp[ip][2] - points->xp[ip_nbr][2]) };
			const double dx_tol = DOT_PRODUCT(dx,dx)/d2_nbr;
		      
			if ( (n_sum_tol <= dn_zero) && (dx_tol <= dx_zero) ) {
			
			  // this face matches. Make sure it is unique -- i.e. we cannot have 
			  // two faces that both match...
			  
			  assert(ifa_nbr_matched == -1);
			  ifa_nbr_matched = ifa_nbr;
			  igr_nbr_matched = igr_nbr;
			  
			}

		      }

		    }

		  }
		  
		  if (ifa_nbr_matched >= 0) {
		    
		    // details of the nbr face...
		    
		    int zero_face_nbr;
		    if (!cvdVec[ip_nbr].checkFaceBit(ifa_nbr_matched,LOCAL_FACE_BIT)) {
		      
		      const double n_nbr_tol = DOT_PRODUCT(cvdVec[ip_nbr].n_fa[ifa_nbr_matched],cvdVec[ip_nbr].n_fa[ifa_nbr_matched])/(d2_nbr*d2_nbr);
		      zero_face_nbr = (n_nbr_tol < dn_zero);
		      
		      cvdVec[ip_nbr].setFaceBit(ifa_nbr_matched,LOCAL_FACE_BIT);
		      if (zero_face_nbr) cvdVec[ip_nbr].setFaceBit(ifa_nbr_matched,ZERO_LOCAL_FACE_BIT);
		      else cvdVec[ip_nbr].setFaceBit(ifa_nbr_matched,NON_ZERO_LOCAL_FACE_BIT);
		      
		    }
		    else {
		      
		      zero_face_nbr = cvdVec[ip_nbr].checkFaceBit(ifa_nbr_matched,ZERO_LOCAL_FACE_BIT);
		      
		    }

		    if ((igr != 0)||(igr_nbr_matched != 0))
		      cout << "matched igr:  " << igr << " with igr_nbr_matched: " << igr_nbr_matched << endl;
		    
		    assert( zero_face_nbr == zero_face );
		    
		    // and set the original face's NBR stuff...
		    
		    cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
		    if (zero_face_nbr) cvdVec[ip].setFaceBit(ifa,ZERO_NBR_FACE_BIT);
		    else cvdVec[ip].setFaceBit(ifa,NON_ZERO_NBR_FACE_BIT);
		      
		    // and decrement ip_status...
		    --ip_status[ip]; assert(ip_status[ip] >= 0);
			
		  }
		  else {
			
		    cout << "no match: " << endl;
		    cvdVec[ip].writeTecplot(ip,points->xp[ip]);
		    cvdVec[ip_nbr].writeTecplot(ip_nbr,points->xp[ip_nbr]);
		    assert(0);
		    
		  }
		  
		}
		
	      }
	      else {

		// parallel

		assert(0);
		
	      }

	    }

	  }

	}

      }
      
      
      
      MPI_Pause("****************************** OKOKOK *******************************");
      






















		

		
			
			
		      
		      
		      
		      
		      
		      
      break;
		  
      if (ifa_nbr < cvdVec[ip_nbr].getNfa()) {
		    
	// we got a matching face. Now check...
		    
	const double n_sum[3] = {
	  cvdVec[ip].n_fa[ifa][0] + cvdVec[ip_nbr].n_fa[ifa_nbr][0],
	  cvdVec[ip].n_fa[ifa][1] + cvdVec[ip_nbr].n_fa[ifa_nbr][1],
	  cvdVec[ip].n_fa[ifa][2] + cvdVec[ip_nbr].n_fa[ifa_nbr][2] };
	const double n_sum_tol = DOT_PRODUCT(n_sum,n_sum)/(d2_nbr*d2_nbr);
		    
	const double dx[3] = {
	  cvdVec[ip].x_fa[ifa][0] - cvdVec[ip_nbr].x_fa[ifa_nbr][0] + (points->xp[ip][0] - points->xp[ip_nbr][0]),
	  cvdVec[ip].x_fa[ifa][1] - cvdVec[ip_nbr].x_fa[ifa_nbr][1] + (points->xp[ip][1] - points->xp[ip_nbr][1]),
	  cvdVec[ip].x_fa[ifa][2] - cvdVec[ip_nbr].x_fa[ifa_nbr][2] + (points->xp[ip][2] - points->xp[ip_nbr][2]) };
	const double dx_tol = DOT_PRODUCT(dx,dx)/d2_nbr;
		    
	if ( (n_sum_tol > dn_zero) || ( !zero_face && ( dx_tol > dx_zero ) ) ) {
		      
	  // this face did not match! Could be that we need to rebuild one of the volumes,
	  // or our delta did not include some nbrs that are in our nbr's delta...
		      
	  if (ip_status[ip_nbr] == -2) {
	    ip_status[ip_nbr] = -1;
	    cvdVec[ip_nbr].clearLeavingNbofa();
	    my_done = 0;
	    ++my_count[0];
	  }
	  else if (points->delta[ip] > points->delta[ip_nbr]) {
			
	    //cout << "n_sum_tol: " << n_sum_tol << " dn_zero: " << dn_zero << " zero_face: " << zero_face << " dx_tol: " << dx_tol << " dx_zero: " << dx_zero << endl;
			
	    // we are smaller, so rebuild nbrs with larger ip delta...
	    ip_status[ip_nbr] = -1;
	    cvdVec[ip_nbr].clearLeavingNbofa();
	    points->delta[ip_nbr] = 1.00001*points->delta[ip];
	    my_done = 0;
	    ++my_count[1];
	  }
		      
	}
	else {
		      
	  // face is consistent with nbr...
		      
	  assert( zero_face_nbr == zero_face );
		      
	  // and set the original face's NBR stuff...
		      
	  cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
	  if (zero_face_nbr) cvdVec[ip].setFaceBit(ifa,ZERO_NBR_FACE_BIT);
	  else cvdVec[ip].setFaceBit(ifa,NON_ZERO_NBR_FACE_BIT);
		      
	  // and decrement ip_status...
	  --ip_status[ip]; assert(ip_status[ip] >= 0);
		      
	}
		    
      }
      else {
		    
	// on this unmatched face, the normal should be small...
	if (zero_face) {
	  cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
	  cvdVec[ip].setFaceBit(ifa,ZERO_NBR_FACE_BIT);
	  // and decrement ip_status...
	  --ip_status[ip]; assert(ip_status[ip] >= 0);
	}
	else if (ip_status[ip_nbr] == -2) {
	  ip_status[ip_nbr] = -1;
	  cvdVec[ip_nbr].clearLeavingNbofa();
	  my_done = 0;
	  ++my_count[2];
	}
	else {
		      
	  ip_status[ip_nbr] = -1;
	  cvdVec[ip_nbr].clearLeavingNbofa();
	  points->delta[ip_nbr] = max( points->delta[ip_nbr], sqrt(d2_nbr)*1.00001 );
	  my_done = 0;
	  ++my_count[3];
		      
	  //cvdVec[ip].writeTecplot(ip,points->xp[ip]);
	  //cvdVec[ip_nbr].writeTecplot(ip_nbr,points->xp[ip_nbr]);
	  //throw(0);
		      
	  /*
			
	  // the ip_nbr should have us as a face, but does not, because it
	  // thinks it is done, but has not gone out far enough...
	  if (points->delta[ip_nbr] < sqrt(d2_nbr)*1.00001) {
	  ip_status[ip_nbr] = -1;
	  cvdVec[ip_nbr].clear();
	  points->delta[ip_nbr] = sqrt(d2_nbr)*1.00001;
	  my_done = 0;
	  }
	  else {

	  const double n_tol = DOT_PRODUCT(cvdVec[ip].n_fa[ifa],cvdVec[ip].n_fa[ifa])/(d2_nbr*d2_nbr);
	  cout << "[" << mpi_rank << "] serious mismatch: ip_status[ip_nbr]: " << ip_status[ip_nbr] <<
	  " n_tol/dn_zero: " << n_tol/dn_zero << " dist: " << sqrt(d2_nbr) << endl;
	  cout << "[" << mpi_rank << "] XXXXX: " <<
	  points->xp[ip][0] << " " <<
	  points->xp[ip][1] << " " <<
	  points->xp[ip][2] << " " <<
	  points->delta[ip] << endl;
	  cout << "[" << mpi_rank << "] XXXXX: " <<
	  points->xp[ip_nbr][0] << " " <<
	  points->xp[ip_nbr][1] << " " <<
	  points->xp[ip_nbr][2] << " " <<
	  points->delta[ip_nbr] << endl;
	  cout << "[" << mpi_rank << "] FFFFF: " <<
	  points->xp[ip][0]+cvdVec[ip].x_fa[ifa][0] << " " <<
	  points->xp[ip][1]+cvdVec[ip].x_fa[ifa][1] << " " <<
	  points->xp[ip][2]+cvdVec[ip].x_fa[ifa][2] << endl;

	  cvdVec[ip].writeTecplot(ip,points->xp[ip]);
	  cvdVec[ip_nbr].writeTecplot(ip_nbr,points->xp[ip_nbr]);

	  assert(0);

	  }
	  */
	}

      }
		  
    }
  }
  else {

    // ------------------------------------------------------------
    // ghost nbr...
    // ------------------------------------------------------------

    const int ig_nbr = ip_nbr - points->np;

    // the common length scale for normalization is the nbr distance (squared)...

<<<<<<< HEAD
    const double d2_nbr = DIST2(points->xp[ip],xpGhostVec[ig_nbr].x);

    int zero_face;
    if (!cvdVec[ip].checkFaceBit(ifa,LOCAL_FACE_BIT)) {
=======
      // on the recv side, process the data...

      for (int irecv = 0; irecv < recv_count_sum; ++irecv) {

	const int ip = recv_buf_int[irecv*2];
	assert((ip >= 0)&&(ip < points->np));

	if (ip_status[ip] == -1) {

	  recv_buf_int[irecv] = -1;

	}
	else {

	  // and is the other face considered a "zero_face"...
>>>>>>> 928a9ed785f5379a4081f9faf23ca4b823e843b0

      const double n_tol = DOT_PRODUCT(cvdVec[ip].n_fa[ifa],cvdVec[ip].n_fa[ifa])/(d2_nbr*d2_nbr);
      zero_face = (n_tol < dn_zero);

      cvdVec[ip].setFaceBit(ifa,LOCAL_FACE_BIT);
      if (zero_face) cvdVec[ip].setFaceBit(ifa,ZERO_LOCAL_FACE_BIT);
      else cvdVec[ip].setFaceBit(ifa,NON_ZERO_LOCAL_FACE_BIT);

    }
    else {

      zero_face = cvdVec[ip].checkFaceBit(ifa,ZERO_LOCAL_FACE_BIT);

    }

    // we cannot check for or modify our nbr, so pack message...

    int rank,bits,index;
    BitUtils::unpackRankBitsIndex(rank,bits,index,rbiGhostVec[ig_nbr]);
    assert(bits == 0);
    assert(rank != mpi_rank);
    int inv_bits = 0;

    ++send_count[rank];

    // on process "rank", ip = "index", this "ip" should be the relevant nbr...

    uint8Vec.push_back(BitUtils::packRankBitsIndex(mpi_rank,inv_bits,ip));

    int ii = intVec.size();
    intVec.resize(ii+5);
    intVec[ii  ] = rank;
    intVec[ii+1] = ip;
    intVec[ii+2] = ifa;
    intVec[ii+3] = index;
    intVec[ii+4] = zero_face;

    ii = doubleVec.size();
    doubleVec.resize(ii+7);
    doubleVec[ii  ] = cvdVec[ip].n_fa[ifa][0];
    doubleVec[ii+1] = cvdVec[ip].n_fa[ifa][1];
    doubleVec[ii+2] = cvdVec[ip].n_fa[ifa][2];
    doubleVec[ii+3] = cvdVec[ip].x_fa[ifa][0];
    doubleVec[ii+4] = cvdVec[ip].x_fa[ifa][1];
    doubleVec[ii+5] = cvdVec[ip].x_fa[ifa][2];
    doubleVec[ii+6] = points->delta[ip];

  }

}

  }
}
		  }
      
// and exchange...

send_disp[0] = 0;
for (int rank = 1; rank < mpi_size; ++rank)
  send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
const int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
assert(send_count_sum == uint8Vec.size());
assert(send_count_sum*5 == intVec.size());
assert(send_count_sum*7 == doubleVec.size());

// only reallocate these if necessary...
if (send_count_sum > send_count_sum_max) {
  send_count_sum_max = send_count_sum;
  // 1 uint8...
  if (send_buf_uint8) delete[] send_buf_uint8;
  send_buf_uint8 = new uint8[send_count_sum];
  // 2 ints...
  if (send_buf_int) delete[] send_buf_int;
  send_buf_int = new int[send_count_sum*2];
  // 7 doubles...
  if (send_buf_double) delete[] send_buf_double;
  send_buf_double = new double[send_count_sum*7];
  // and the pair of ip/ifa...
  if (send_ip_ifa) delete[] send_ip_ifa;
  send_ip_ifa = new int[send_count_sum][2];
 }

// pack...
for (int ii = 0; ii < send_count_sum; ++ii) {
  const int rank = intVec[ii*5];
  assert((rank >= 0)&&(rank < mpi_size));
  // pack the pair first -- used for unpacking the response...
  send_ip_ifa[send_disp[rank]][0] = intVec[ii*5+1]; // ip
  send_ip_ifa[send_disp[rank]][1] = intVec[ii*5+2]; // ifa
  // uint8...
  send_buf_uint8[send_disp[rank]] = uint8Vec[ii]; // rbi for ip_nbr on rank
  // ints...
  send_buf_int[send_disp[rank]*2  ] = intVec[ii*5+3]; // ip on rank
  send_buf_int[send_disp[rank]*2+1] = intVec[ii*5+4]; // zero_face: 0, 1,
  // doubles...
  send_buf_double[send_disp[rank]*7  ] = doubleVec[ii*7  ];
  send_buf_double[send_disp[rank]*7+1] = doubleVec[ii*7+1];
  send_buf_double[send_disp[rank]*7+2] = doubleVec[ii*7+2];
  send_buf_double[send_disp[rank]*7+3] = doubleVec[ii*7+3];
  send_buf_double[send_disp[rank]*7+4] = doubleVec[ii*7+4];
  send_buf_double[send_disp[rank]*7+5] = doubleVec[ii*7+5];
  send_buf_double[send_disp[rank]*7+6] = doubleVec[ii*7+6];
  ++send_disp[rank];
 }
uint8Vec.clear();
intVec.clear();
doubleVec.clear();

send_disp[0] = 0;
for (int rank = 1; rank < mpi_size; ++rank)
  send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);

recv_disp[0] = 0;
for (int rank = 1; rank < mpi_size; ++rank)
  recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
const int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];

// only reallocate these if necessary...
if (recv_count_sum > recv_count_sum_max) {
  recv_count_sum_max = recv_count_sum;
  // 1 uint8...
  if (recv_buf_uint8) delete[] recv_buf_uint8;
  recv_buf_uint8 = new uint8[recv_count_sum];
  // 2 ints...
  if (recv_buf_int) delete[] recv_buf_int;
  recv_buf_int = new int[recv_count_sum*2];
  // 7 doubles...
  if (recv_buf_double) delete[] recv_buf_double;
  recv_buf_double = new double[recv_count_sum*7];
 }

MPI_Alltoallv(send_buf_uint8,send_count,send_disp,MPI_UINT8,
	      recv_buf_uint8,recv_count,recv_disp,MPI_UINT8,mpi_comm);

FOR_RANK {
  send_count[rank] *= 2;
  send_disp[rank] *= 2;
  recv_count[rank] *= 2;
  recv_disp[rank] *= 2;
}

MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
	      recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);

FOR_RANK {
  send_count[rank] = (send_count[rank]/2)*7;
  send_disp[rank] = (send_disp[rank]/2)*7;
  recv_count[rank] = (recv_count[rank]/2)*7;
  recv_disp[rank] = (recv_disp[rank]/2)*7;
}

MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
	      recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);

// on the recv side, process the data...
      
for (int irecv = 0; irecv < recv_count_sum; ++irecv) {

  const int ip = recv_buf_int[irecv*2];
  assert((ip >= 0)&&(ip < points->np));
	
  if (ip_status[ip] == -1) {
	  
    recv_buf_int[irecv] = -1;
	  
  }
  else {
	  
    // and is the other face considered a "zero_face"...

    const int zero_face = recv_buf_int[irecv*2+1];

    // this one is built, so check for a face that has this nbr. It should
    // always be in the ghost range...
    map<const uint8,int>::iterator iter = rbiGhostMap.find(recv_buf_uint8[irecv]);
    if (iter == rbiGhostMap.end()) {

      // we didn't find this nbr in the ghost range.

      if (zero_face) {
	// this is fine. The sending process thinks the face is zero, and we
	// do not have a match, so this is fine...
	recv_buf_int[irecv] = 0;
      }
      else if (ip_status[ip] == -2) {
	ip_status[ip] = -1;
	cvdVec[ip].clearLeavingNbofa();
	recv_buf_int[irecv] = -1;
	my_done = 0;
	++my_count[4];
      }
      else {

<<<<<<< HEAD
	//assert(0);

	// we were rebuilt, but we are probably not big enough to include
	// the nbr being searched for. Since we don't actually have the nbr being asked for,
	// we can build its normal distance from ip from the passed face information...
	const double nmag = sqrt( recv_buf_double[irecv*7  ]*recv_buf_double[irecv*7  ] +
				  recv_buf_double[irecv*7+1]*recv_buf_double[irecv*7+1] +
				  recv_buf_double[irecv*7+2]*recv_buf_double[irecv*7+2] );
	const double delta_half = ( recv_buf_double[irecv*7+3]*recv_buf_double[irecv*7  ] +
				    recv_buf_double[irecv*7+4]*recv_buf_double[irecv*7+1] +
				    recv_buf_double[irecv*7+5]*recv_buf_double[irecv*7+2] )/nmag;
	assert(delta_half > 0.0);
	ip_status[ip] = -1;
	cvdVec[ip].clearLeavingNbofa();
	points->delta[ip] = max( points->delta[ip], 2.0*delta_half*1.00001 );
	recv_buf_int[irecv] = -1;
	my_done = 0;
	++my_count[5];
      }
=======
      MPI_Alltoallv(recv_buf_int,recv_count,recv_disp,MPI_INT,
		    send_buf_int,send_count,send_disp,MPI_INT,
		    mpi_comm);

      for (int isend = 0; isend < send_count_sum; ++isend) {
	// we get the particular ip/ifa pair from the send_ip_ifa array...
	const int ip  = send_ip_ifa[isend][0];
	const int ifa = send_ip_ifa[isend][1];
	// this ip should have some unset nbrs left...
	if (ip_status[ip] > 0) {
	  // this face's NBR should NOT be set...
	  assert(!cvdVec[ip].checkFaceBit(ifa,NBR_FACE_BIT));
	  // take action depending on send buffer...
	  switch (send_buf_int[isend]) {
	  case -1:
	    // -1 means the nbr was not built, or is being rebuilt. "my_done" should
	    // already be zeroed on that rank...
	    break;
	  case 0:
	    // nbr is either not present, or is a zero face...
	    cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
	    cvdVec[ip].setFaceBit(ifa,ZERO_NBR_FACE_BIT);
	    assert(cvdVec[ip].checkFaceBit(ifa,ZERO_LOCAL_FACE_BIT)); // this could fail near the dn_tol limit...
	    // and decrement ip_status...
	    --ip_status[ip]; assert(ip_status[ip] >= 0);
	    break;
	  case 1:
	    // nbr is a non-zero face...
	    cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
	    cvdVec[ip].setFaceBit(ifa,NON_ZERO_NBR_FACE_BIT);
	    assert(cvdVec[ip].checkFaceBit(ifa,NON_ZERO_LOCAL_FACE_BIT)); // this could fail near the dn_tol limit...
	    // and decrement ip_status...
	    --ip_status[ip]; assert(ip_status[ip] >= 0);
	    break;
	  default:
	    cout << "error: got send_buf_int[isend]: " << send_buf_int[isend] << endl;
	    assert(0);
	  }
	}
	else {
	  assert(ip_status[ip] == -1);
	}
      }

      int8 count[11];
      MPI_Reduce(my_count,count,11,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
	cout << " > face failures: ";
	int8 count_sum = 0;
	for (int i = 0; i < 11; ++i) {
	  cout << i << ":" << count[i] << " ";
	  count_sum += count[i];
	}
	cout << "total: " << count_sum << endl;
      }

      // check if we are done...

      MPI_Allreduce(&my_done,&done,1,MPI_INT,MPI_MIN,mpi_comm);

    }

    // do a consistency check...
>>>>>>> 928a9ed785f5379a4081f9faf23ca4b823e843b0

    }
<<<<<<< HEAD
    else {
=======

    //MPI_Pause("LOOOOOOOOOOOOOKING GOOOOOOOOOOOOOOOOOOOOOOOOOD");

    // cleanup...

    delete[] xv;
    delete[] r0;
    delete[] r1;
    delete[] ipoiv;
    delete[] nboiv_i;
    if (nboiv_v) delete[] nboiv_v;

    delete[] ip_status;
>>>>>>> 928a9ed785f5379a4081f9faf23ca4b823e843b0

      const int ip_nbr = iter->second + points->np;
      const int ig_nbr = ip_nbr - points->np;
      const double d2_nbr = DIST2(points->xp[ip],xpGhostVec[ig_nbr].x);

      int ifa;
      for (ifa = 0; ifa < cvdVec[ip].getNfa(); ++ifa)
	if (cvdVec[ip].getNbofa(ifa) == ip_nbr)
	  break;

      if (ifa < cvdVec[ip].getNfa()) {

	// the common length scale for normalization is the nbr distance (squared)...

	const double n_sum[3] = {
	  cvdVec[ip].n_fa[ifa][0] + recv_buf_double[irecv*7  ],
	  cvdVec[ip].n_fa[ifa][1] + recv_buf_double[irecv*7+1],
	  cvdVec[ip].n_fa[ifa][2] + recv_buf_double[irecv*7+2] };
	const double n_sum_tol = DOT_PRODUCT(n_sum,n_sum)/(d2_nbr*d2_nbr);

	const double dx[3] = {
	  cvdVec[ip].x_fa[ifa][0] - recv_buf_double[irecv*7+3] + (points->xp[ip][0] - xpGhostVec[ig_nbr].x[0]),
	  cvdVec[ip].x_fa[ifa][1] - recv_buf_double[irecv*7+4] + (points->xp[ip][1] - xpGhostVec[ig_nbr].x[1]),
	  cvdVec[ip].x_fa[ifa][2] - recv_buf_double[irecv*7+5] + (points->xp[ip][2] - xpGhostVec[ig_nbr].x[2]) };
	const double dx_tol = DOT_PRODUCT(dx,dx)/d2_nbr;

	const double delta = recv_buf_double[irecv*7+6];

	if ( (n_sum_tol > dn_zero) || ( !zero_face && ( dx_tol > dx_zero ) ) ) {

	  // this face did not match!

	  if (ip_status[ip] == -2) {
	    ip_status[ip] = -1;
	    cvdVec[ip].clearLeavingNbofa();
	    recv_buf_int[irecv] = -1;
	    my_done = 0;
	    ++my_count[6];
	  }
	  else if (delta > points->delta[ip]) {

	    //cout << "2 n_sum_tol: " << n_sum_tol << " dn_zero: " << dn_zero << " zero_face: " << zero_face << " dx_tol: " << dx_tol << " dx_zero: " << dx_zero << endl;

	    // we are smaller, so rebuild nbrs with larger ip delta...
	    ip_status[ip] = -1;
	    cvdVec[ip].clearLeavingNbofa();
	    points->delta[ip] = 1.00001*delta;
	    recv_buf_int[irecv] = -1;
	    my_done = 0;
	    ++my_count[7];
	  }
	  else {
	    // what to return?...
	    recv_buf_int[irecv] = -2; // i.e. force nbr to rebuild - if everything is consistent, nbr should already know it needs to rebuild
	    ++my_count[8];
	  }

	}
	else {

	  // face is consistent with nbr...

	  assert(cvdVec[ip].checkFaceBit(ifa,LOCAL_FACE_BIT));
	  if (cvdVec[ip].checkFaceBit(ifa,ZERO_LOCAL_FACE_BIT)) {
	    recv_buf_int[irecv] = 0;
	    assert(zero_face);
	  }
	  else {
	    assert(cvdVec[ip].checkFaceBit(ifa,NON_ZERO_LOCAL_FACE_BIT));
	    recv_buf_int[irecv] = 1;
	    assert(!zero_face);
	  }

	}

      }
      else {

	if (zero_face) {
	  // this is fine. The sending process thinks the face is zero, and we
	  // do not have a match, so this is fine...
	  recv_buf_int[irecv] = 0;
	}
	else if (ip_status[ip] == -2) {
	  ip_status[ip] = -1;
	  cvdVec[ip].clearLeavingNbofa();
	  recv_buf_int[irecv] = -1;
	  my_done = 0;
	  ++my_count[9];
	}
	else {

	  //assert(0);

	  ip_status[ip] = -1;
	  cvdVec[ip].clearLeavingNbofa();
	  points->delta[ip] = max( points->delta[ip], sqrt(d2_nbr)*1.00001 );
	  recv_buf_int[irecv] = -1;
	  my_done = 0;
	  ++my_count[10];
	}

      }

    }
  }
 }

// and send back the int flag and complete...

FOR_RANK {
  send_count[rank] /= 7;
  send_disp[rank] /= 7;
  recv_count[rank] /= 7;
  recv_disp[rank] /= 7;
}

MPI_Alltoallv(recv_buf_int,recv_count,recv_disp,MPI_INT,
	      send_buf_int,send_count,send_disp,MPI_INT,
	      mpi_comm);

for (int isend = 0; isend < send_count_sum; ++isend) {
  // we get the particular ip/ifa pair from the send_ip_ifa array...
  const int ip  = send_ip_ifa[isend][0];
  const int ifa = send_ip_ifa[isend][1];
  // this ip should have some unset nbrs left...
  if (ip_status[ip] > 0) {
    // this face's NBR should NOT be set...
    assert(!cvdVec[ip].checkFaceBit(ifa,NBR_FACE_BIT));
    // take action depending on send buffer...
    switch (send_buf_int[isend]) {
    case -1:
      // -1 means the nbr was not built, or is being rebuilt. "my_done" should
      // already be zeroed on that rank...
      break;
    case 0:
      // nbr is either not present, or is a zero face...
      cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
      cvdVec[ip].setFaceBit(ifa,ZERO_NBR_FACE_BIT);
      assert(cvdVec[ip].checkFaceBit(ifa,ZERO_LOCAL_FACE_BIT)); // this could fail near the dn_tol limit...
      // and decrement ip_status...
      --ip_status[ip]; assert(ip_status[ip] >= 0);
      break;
    case 1:
      // nbr is a non-zero face...
      cvdVec[ip].setFaceBit(ifa,NBR_FACE_BIT);
      cvdVec[ip].setFaceBit(ifa,NON_ZERO_NBR_FACE_BIT);
      assert(cvdVec[ip].checkFaceBit(ifa,NON_ZERO_LOCAL_FACE_BIT)); // this could fail near the dn_tol limit...
      // and decrement ip_status...
      --ip_status[ip]; assert(ip_status[ip] >= 0);
      break;
    default:
      cout << "error: got send_buf_int[isend]: " << send_buf_int[isend] << endl;
      assert(0);
    }
  }
  else {
    assert(ip_status[ip] == -1);
  }
 }








#endif











  void setFromCuttableAndBuildInternalFaceStuffOrig(const CuttableVoronoiData& cuttable,const Surface * const surface,const double x0[3]) {

    assert(0);
    
    // we combine the setting from cuttable and building internal face stuff
    // because we reorder during setting to allow orphan handling...

    static int debug = 0;
    static int ocount = 0; // orphan count
    ++debug;
    //cout << "buildInternalFaceStuff: debug: " << debug << endl;

    ned = cuttable.ned; assert(ned > 0);
    nno = cuttable.nno; assert(nno > 0);
    
    // split nodes according to orphan groups first...
   
    {

      int * no_flag = new int[nno];
      FOR_INO no_flag[ino] = ino;
      FOR_IED {
	// decend the no_flag to get the terminal node number...
	int ino0 = no_flag[cuttable.nooed[ied][0]];
	while (ino0 != no_flag[ino0])
	  ino0 = no_flag[ino0];
	int ino1 = no_flag[cuttable.nooed[ied][1]];
	while (ino1 != no_flag[ino1])
	  ino1 = no_flag[ino1];
	if (ino0 < ino1)
	  no_flag[ino1] = ino0;
	else
	  no_flag[ino0] = ino1;
      }
    
      // now count the number of groups...
    
      ngr = 0;
      FOR_INO {
	if (no_flag[ino] == ino) {
	  ++ngr;
	  no_flag[ino] = -ngr;
	}
	else {
	  int ino_ = no_flag[ino];
	  while (ino_ >= 0)
	    ino_ = no_flag[ino_];
	  no_flag[ino] = ino_;
	}
      }

      // right now, no_flag contains -1,-2,-3,-4...
    
      //cout << "ngr: " << ngr << endl;
      assert(noogr == NULL);
      noogr = new int[ngr+1];

      assert(edogr == NULL);
      edogr = new int[ngr+1];
    
      if (ngr > 1) {

	// if there is more than one group, this means there are orphans
	// and we need to order the
	// nodes such that the first nodes are in the group containing
	// the voronoi vertex -- i.e. the primary group. The primary group
	// owns the face closes to the vertex (I think this is provably correct, because of the convexity of 
	// the internal faces. Note also that the fact that orphans exist implies boundary faces must
	// exist. To determine the face that is closest to 
	// the Voronoi vertex, we use the shared mem surface and find the closest tri from the 
	// surface.
      
	set<int> * istSet = new set<int>[ngr];
	FOR_IED {
	  FOR_I2 {
	    if (cuttable.faoed[ied][i] >= 0) {
	      const int igr = -no_flag[cuttable.nooed[ied][0]]-1;
	      assert(igr == -no_flag[cuttable.nooed[ied][1]]-1);
	      assert((igr >= 0)&&(igr < ngr));
	      istSet[igr].insert(cuttable.faoed[ied][i]);
	    }
	  }
	}

	double d2_closest;
	int igr_closest = -1;
	for (int igr = 0; igr < ngr; ++igr) {
	  for (set<int>::iterator iter = istSet[igr].begin(); iter != istSet[igr].end(); ++iter) {
	    const int ist = *iter;
	    const double this_d2 = getPointToTriDist2(x0,surface->xp[surface->spost[ist][0]],surface->xp[surface->spost[ist][1]],surface->xp[surface->spost[ist][2]]);
	    if ((igr_closest == -1)||(this_d2 < d2_closest)) {
	      igr_closest = igr;
	      d2_closest = this_d2;
	    }
	  }
	}
	assert((igr_closest >= 0)&&(igr_closest < ngr));
	delete[] istSet;

	// now loop through the nodes and set the no_flag to the positive group index...
	for (int igr = 0; igr < ngr; ++igr)
	  noogr[igr+1] = 0;
	FOR_INO {
	  if (no_flag[ino] == -igr_closest-1) 
	    no_flag[ino] = 0;
	  else if (no_flag[ino] > -igr_closest-1)
	    no_flag[ino] = -no_flag[ino];
	  else
	    no_flag[ino] = -no_flag[ino]-1;
	  // and count...
	  const int igr = no_flag[ino];
	  assert((igr >= 0)&&(igr < ngr));
	  ++noogr[igr+1];
	}

	// and complete noogr...
	noogr[0] = 0;
	for (int igr = 0; igr < ngr; ++igr)
	  noogr[igr+1] += noogr[igr];
	assert(noogr[ngr] == nno);
      
	// now edges...
	for (int igr = 0; igr < ngr; ++igr)
	  edogr[igr+1] = 0;
      
	int * ed_flag = new int[ned];
	FOR_IED {
	  const int igr = no_flag[cuttable.nooed[ied][0]];
	  assert(igr == no_flag[cuttable.nooed[ied][1]]);
	  assert((igr >= 0)&&(igr < ngr));
	  ed_flag[ied] = igr;
	  ++edogr[igr+1];
	}

	edogr[0] = 0;
	for (int igr = 0; igr < ngr; ++igr)
	  edogr[igr+1] += edogr[igr];

	// copy over x_no and turn no_flag into a new index...

	assert(x_no == NULL);
	x_no = new double[nno][3];
	FOR_INO {
	  const int igr = no_flag[ino];
	  const int ino_new = noogr[igr]++;;
	  no_flag[ino] = ino_new;
	  FOR_I3 x_no[ino_new][i] = cuttable.x_no[ino][i];
	}

	// and return noogr...
	for (int igr = ngr-1; igr > 0; --igr)
	  noogr[igr] = noogr[igr-1];
	noogr[0] = 0;
	
	// copy over edge data...
	assert(nooed == NULL);
	nooed = new int[ned][2];
	assert(faoed == NULL);
	faoed = new int[ned][2];
	
	FOR_IED {
	  const int igr = ed_flag[ied];
	  const int ied_new = edogr[igr]++;
	  nooed[ied_new][0] = no_flag[cuttable.nooed[ied][0]];
	  nooed[ied_new][1] = no_flag[cuttable.nooed[ied][1]];
	  faoed[ied_new][0] = cuttable.faoed[ied][0];
	  faoed[ied_new][1] = cuttable.faoed[ied][1];
	}
      
	delete[] ed_flag;

	// and return edogr...
	for (int igr = ngr-1; igr > 0; --igr)
	  edogr[igr] = edogr[igr-1];
	edogr[0] = 0;
	
	//cout << "[" << mpi_rank << "] got orphans: " << ngr << ", xp: " << COUT_VEC(x0) << endl;
	//writeTecplotOrphans(ocount++,x0);
	//getchar();
	
      }
      else {
      
	// =============================================
	// for one group, all no_flags are simply 0...
	// =============================================
	assert(ngr == 1);
	noogr[0] = 0;
	noogr[1] = nno;
	edogr[0] = 0;
	edogr[1] = ned;
	assert(nooed == NULL);
	nooed = new int[ned][2];
	memcpy(nooed,cuttable.nooed,ned*2*sizeof(int));
	assert(faoed == NULL);
	faoed = new int[ned][2];
	memcpy(faoed,cuttable.faoed,ned*2*sizeof(int));
	assert(x_no == NULL);
	x_no = new double[nno][3];
	memcpy(x_no,cuttable.x_no,nno*3*sizeof(double));

      }
    
      delete[] no_flag;

    }

    // =========================================================================
    // now everything should be copied from cuttable and in correct group order
    // =========================================================================
    
    assert(n_fa == NULL);
    assert(x_fa == NULL);
    assert(ifa_bits == NULL);
    assert(igr_ifa_nbr == NULL);

    const int nfa_old = nfa; assert(nfa_old == 0); // for now consider new case only
    nfa = 0;
    
    vol = 0.0; // for group 0 volume

    x_cv[0] = 0.0; // for group 0 centroid
    x_cv[1] = 0.0;
    x_cv[2] = 0.0;
    
    map<const pair<int,int>,pair<int,int> > faceMap;
    for (int igr = 0; igr < ngr; ++igr) {
      for (int ied = edogr[igr]; ied != edogr[igr+1]; ++ied) {
	// faoed can be just about anything:
	// +ve value here represent surface tris, -ve values represet either 
	// original hull faces (-2..-7 inclusive), or a voronoi nbr, -8,-9,etc...
	{
	  // here we use a -ve to align face ordering with ip_nbr, which is negative right now...
	  map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find( pair<int,int>(igr,-faoed[ied][0]) );
	  if (iter == faceMap.end()) {
	    if (faoed[ied][0] <= -8) {
	      faceMap[ pair<int,int>(igr,-faoed[ied][0]) ] = pair<int,int>(nooed[ied][0],nfa++);
	    }
	    else {
	      assert(faoed[ied][0] >= 0); // cannot have any seed boundary left over if we are calling this routine
	      faceMap[ pair<int,int>(igr,-faoed[ied][0]) ] = pair<int,int>(nooed[ied][0],-1); // no face data stored
	    }
	  }
	}
	{
	  map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find( pair<int,int>(igr,-faoed[ied][1]) );
	  if (iter == faceMap.end()) {
	    if (faoed[ied][1] <= -8) {
	      faceMap[ pair<int,int>(igr,-faoed[ied][1]) ] = pair<int,int>(nooed[ied][1],nfa++);
	    }
	    else {
	      assert(faoed[ied][1] >= 0); // cannot have any seed boundary left over if we are calling this routine
	      faceMap[ pair<int,int>(igr,-faoed[ied][1]) ] = pair<int,int>(nooed[ied][1],-1);
	    }
	  }
	}
      }
    }
    
    // now the old nbofa may or may not be represented in the map. If not represented,
    // then these ones get added to the end of the nbofa in the [nfa:nfa_max) range...
    // start by copying them contiguously into the first part of nbofa...

    int nfa_lost = 0;
    /*
      for (int ifa = 0; ifa < nfa_old; ++ifa) {
      map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find(-nbofa[ifa]-8);
      if (iter == faceMap.end()) 
      nbofa[nfa_lost++] = nbofa[ifa];
      }
    */

    nfa_max = nfa+nfa_lost;
    
    int * nbofa_new = new int[nfa_max];
    n_fa = new double[nfa_max][3];
    x_fa = new double[nfa_max][3];
    ifa_bits = new uint[nfa_max];

    faogr = new int[ngr+1];
    faogr[0] = 0;
    
    for (int ifa = 0; ifa < nfa_max; ++ifa) {
      nbofa_new[ifa] = -1;
      FOR_I3 x_fa[ifa][i] = 0.0;
      FOR_I3 n_fa[ifa][i] = 0.0;
      ifa_bits[ifa] = 0;
    }
    
    // we can set nbofa from the map. Also reorder the faces as they appear in the map, which
    // should be sorted on igr first... 
    int current_igr = 0;
    int ifa = 0;
    for (map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.begin(); iter != faceMap.end(); ++iter) {
      if (iter->second.second >= 0) {
	// reset the face index to the sorted index...
	iter->second.second = ifa;
	const int ip_nbr = iter->first.second-8;
	assert(ip_nbr >= 0);
	const int igr = iter->first.first;
	if (current_igr != igr) {
	  assert(igr == current_igr+1);
	  faogr[igr] = ifa;
	  current_igr = igr;
	}
	//cout << "igr: " << iter->first.first << " ip_nbr: " << ip_nbr << endl;
	assert(nbofa_new[ifa] == -1);
	nbofa_new[ifa] = ip_nbr;
	++ifa;
      }
    }
    assert(current_igr == ngr-1);
    assert(ifa == nfa);
    faogr[ngr] = nfa;
        
    // check...
    FOR_IFA {
      assert( nbofa_new[ifa] >= 0 );
    }
    
    // and copy the old nbrs into the last part of the array...
    /*
      for (int ifa = nfa; ifa < nfa_max; ++ifa) {
      assert(nbofa_new[ifa] == -1);
      nbofa_new[ifa] = nbofa[ifa-nfa];
      }
    */

    assert(nbofa == NULL);
    if (nbofa != NULL) delete[] nbofa;
    nbofa = nbofa_new;
    
    // normal and volume...
    for (int igr = 0; igr < ngr; ++igr) {
      for (int ied = edogr[igr]; ied != edogr[igr+1]; ++ied) {
	{
	  map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find( pair<int,int>(igr,-faoed[ied][0]) );
	  assert(iter != faceMap.end());
	  const int ino = iter->second.first;
	  if ((ino != nooed[ied][0])&&(ino != nooed[ied][1])) {
	    if (igr == 0) {
	      // only build volume and centroid for original part...
	      const double this_vol = CROSS_DOT(x_no[ino],x_no[nooed[ied][0]],x_no[nooed[ied][1]]);
	      vol += this_vol;
	      FOR_I3 x_cv[i] += this_vol*(x_no[ino][i]+x_no[nooed[ied][0]][i]+x_no[nooed[ied][1]][i]); // 4th point is (0,0,0) so is not included
	    }
	    const int ifa = iter->second.second;
	    if (ifa >= 0) {
	      const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][0]],x_no[nooed[ied][1]]);
	      FOR_I3 n_fa[ifa][i] += this_n[i];
	    }
	  }
	}
	{
	  map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find( pair<int,int>(igr,-faoed[ied][1]) );
	  assert(iter != faceMap.end());
	  const int ino = iter->second.first;
	  if ((ino != nooed[ied][0])&&(ino != nooed[ied][1])) {
	    if (igr == 0) {
	      const double this_vol = CROSS_DOT(x_no[ino],x_no[nooed[ied][1]],x_no[nooed[ied][0]]);
	      vol += this_vol;
	      FOR_I3 x_cv[i] += this_vol*(x_no[ino][i]+x_no[nooed[ied][1]][i]+x_no[nooed[ied][0]][i]);
	    }
	    const int ifa = iter->second.second;
	    if (ifa >= 0) {
	      const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][1]],x_no[nooed[ied][0]]);
	      FOR_I3 n_fa[ifa][i] += this_n[i];
	    }
	  }
	}
      }
    }

    assert(vol > 0.0);
    FOR_I3 x_cv[i] /= 4.0*vol; // thus the division by 4
    vol /= 6.0;

    /*
      if (ngr > 1) {
      cout << "XXXXX: " << x_cv[0]+x0[0] << " " << x_cv[1]+x0[1] << " " << x_cv[2]+x0[2] << endl;
      }
    */

    // face coordinates...
    for (int igr = 0; igr < ngr; ++igr) {
      for (int ied = edogr[igr]; ied != edogr[igr+1]; ++ied) {
	if (faoed[ied][0] <= -8) {
	  map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find( pair<int,int>(igr,-faoed[ied][0]) );
	  assert(iter != faceMap.end());
	  const int ino = iter->second.first;
	  if ((ino != nooed[ied][0])&&(ino != nooed[ied][1])) {
	    const int ifa = iter->second.second;
	    assert(ifa >= 0);
	    const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][0]],x_no[nooed[ied][1]]);
	    const double this_wgt = DOT_PRODUCT(this_n,n_fa[ifa]);
	    FOR_I3 x_fa[ifa][i] += this_wgt*(x_no[ino][i] + x_no[nooed[ied][0]][i] + x_no[nooed[ied][1]][i]);
	  }
	}
	if (faoed[ied][1] <= -8) {
	  map<const pair<int,int>,pair<int,int> >::iterator iter = faceMap.find( pair<int,int>(igr,-faoed[ied][1]) );
	  assert(iter != faceMap.end());
	  const int ino = iter->second.first;
	  if ((ino != nooed[ied][0])&&(ino != nooed[ied][1])) {
	    const int ifa = iter->second.second;
	    assert(ifa >= 0);
	    const double this_n[3] = TRI_NORMAL_2(x_no[ino],x_no[nooed[ied][1]],x_no[nooed[ied][0]]);
	    const double this_wgt = DOT_PRODUCT(this_n,n_fa[ifa]);
	    FOR_I3 x_fa[ifa][i] += this_wgt*(x_no[ino][i] + x_no[nooed[ied][0]][i] + x_no[nooed[ied][1]][i]);
	  }
	}
      }
    }

    FOR_IFA {
      const double n2 = DOT_PRODUCT(n_fa[ifa],n_fa[ifa]);
      if (n2 > 0.0) {
	FOR_I3 x_fa[ifa][i] /= n2*3.0;
      }
      else {
	FOR_I3 x_fa[ifa][i] = 0.0; // we could try to set a better value here, but the face is useless anyways
      }
      // and multiply normal by 0.5...
      FOR_I3 n_fa[ifa][i] *= 0.5;
    }

  }

#ifndef _HCP_POINT_BUILDER_HPP_
#define _HCP_POINT_BUILDER_HPP_

class BboxJK {
public:
  int8 type_and_index; // ( (int8(type)<<48) | index )
  double density; // the density multiplied by the bbox 2D area gives the weight
  int jkmin[2];
  int jkmax[2];
  bool operator<(const BboxJK& other) const {
    //assert(type_and_index != other.type_and_index); // fails
    return (type_and_index < other.type_and_index);
  }
  // some notes on < operator. On my desktop (Ham) it fails if the
  // assert is included, meaning that 2 elements are equal. I think
  // the stl sort must self-compare, because after sort, no 2 elements
  // are equal.
};

enum HcpWindowType {
  UNKNOWN_HCP_WINDOW,
  FAZONE_HCP_WINDOW,
  SPHERE_HCP_WINDOW,
  BOX_HCP_WINDOW,
  TCONE_HCP_WINDOW,
  ANNULAR_TCONE_HCP_WINDOW,
  PRISM_HCP_WINDOW,
  SBIN_HCP_WINDOW,
};

class HcpWindowData {
public:

  HcpWindowType type;
  string zones;
  int level;
  int nlayers;
  double geom_data[13];
  string sbin_filename;

  HcpWindowData() {
    type = UNKNOWN_HCP_WINDOW;
    level = -1;
    //nlayers = -1;
    nlayers = 10; // default to 10 layers
  }

  // parameter-based initialization...

  void init(Param * param) {
    int iarg = 0;
    init(iarg,param);
    if (iarg != param->size()) {
      CERR("extra tokens detected in HCP_WINDOW");
    }
  }

  void init(int& iarg,Param * param) {
    // and populate...
    string token = param->getString(iarg++);
    if (token == "FAZONE") {
      // ---------------------------------------------------------------
      // HCP_WINDOW FAZONE z1,z2,z3 LEVEL <int> NLAYERS <int>
      // ---------------------------------------------------------------
      this->type = FAZONE_HCP_WINDOW;
      this->zones = param->getString(iarg++); // expect comma-limited zone names...
      if (mpi_rank == 0)
	cout << " > HCP_WINDOW FAZONE " << this->zones << "..." << endl;
      if (param->getString(iarg++) != "LEVEL") {
	CERR("FAZONE syntax problem. Expecting token LEVEL. Sample usage:\n\n" <<
	     "HCP_WINDOW FAZONE=x0,z1,wall LEVEL=3 NLAYERS=10");
      }
      this->level = param->getInt(iarg++);
      if (param->getString(iarg++) != "NLAYERS") {
	CERR("FAZONE syntax problem. Expecting token NLAYERS. Sample usage:\n\n" <<
	     "HCP_WINDOW FAZONE=x0,z1,wall LEVEL=3 NLAYERS=10");
      }
      this->nlayers = param->getInt(iarg++);
    }
    else if (token == "SPHERE") {
      // ---------------------------------------------------------------
      // HCP_WINDOW SPHERE <x> <y> <z> <r> LEVEL <int> [NLAYERS <int>]
      //
      // for the case of a sphere, the presence of NLAYERS introduces
      // additional larger spheres.
      // ---------------------------------------------------------------
      this->type = SPHERE_HCP_WINDOW;
      // parse x,y,z,r...
      this->geom_data[0] = param->getDouble(iarg++);
      this->geom_data[1] = param->getDouble(iarg++);
      this->geom_data[2] = param->getDouble(iarg++);
      this->geom_data[3] = param->getDouble(iarg++);
      if (mpi_rank == 0)
	cout << " > HCP_WINDOW SPHERE " <<
	  this->geom_data[0] << " " <<  this->geom_data[1] << " " <<  this->geom_data[2] << " " <<
	  this->geom_data[3] << "..." << endl;
      assert(param->getString(iarg++) == "LEVEL");
      this->level = param->getInt(iarg++);
      if ((iarg < param->size())&&(param->getString(iarg) == "NLAYERS")) {
	++iarg;
	this->nlayers = param->getInt(iarg++);
      }
    }
    else if (token == "BOX") {
      // ---------------------------------------------------------------
      // HCP_WINDOW BOX <x0> <x1> <y0> <y1> <z0> <z1> LEVEL <int> [NLAYERS <int>]
      //
      // for the case of a box, the presence of NLAYERS introduces
      // bloated tris accordingly to introduce levels...
      // ---------------------------------------------------------------
      this->type = BOX_HCP_WINDOW;
      // parse x,y,z,r...
      this->geom_data[0] = param->getDouble(iarg++);
      this->geom_data[1] = param->getDouble(iarg++);
      this->geom_data[2] = param->getDouble(iarg++);
      this->geom_data[3] = param->getDouble(iarg++);
      this->geom_data[4] = param->getDouble(iarg++);
      this->geom_data[5] = param->getDouble(iarg++);
      if ((this->geom_data[1] <= this->geom_data[0])||(this->geom_data[3] <= this->geom_data[2])||(this->geom_data[5] <= this->geom_data[4])) {
	CERR("FAZONE syntax problem. Check BOX limits:\n\n" <<
	     "HCP_WINDOW BOX <x0> <x1> <y0> <y1> <z0> <z1> LEVEL <int> [NLAYERS <int>]");
      }
      if (mpi_rank == 0)
	cout << " > HCP_WINDOW BOX " <<
	  this->geom_data[0] << " " <<  this->geom_data[1] << " " <<
	  this->geom_data[2] << " " <<  this->geom_data[3] << " " <<
	  this->geom_data[4] << " " <<  this->geom_data[5] << "..." << endl;
      if (param->getString(iarg++) != "LEVEL") {
	CERR("FAZONE syntax problem. Expecting token LEVEL. Sample usage:\n\n" <<
	     "HCP_WINDOW BOX <x0> <x1> <y0> <y1> <z0> <z1> LEVEL <int> [NLAYERS <int>]");
      }
      this->level = param->getInt(iarg++);
      if ((iarg < param->size())&&(param->getString(iarg) == "NLAYERS")) {
	++iarg;
	this->nlayers = param->getInt(iarg++);
      }
    }
    else if (token == "ANNULAR_TCONE") {
      // ---------------------------------------------------------------
      // HCP_WINDOW ANNULAR_TCONE <x0> <y0> <z0> <r0-0> <r0-1> <x1> <y1> <z1> <r1-0> <r1-1> LEVEL <int> [NLAYERS <int>]
      // ---------------------------------------------------------------
      this->type = ANNULAR_TCONE_HCP_WINDOW;
      this->geom_data[0] = param->getDouble(iarg++);
      this->geom_data[1] = param->getDouble(iarg++);
      this->geom_data[2] = param->getDouble(iarg++);
      this->geom_data[3] = param->getDouble(iarg++);
      this->geom_data[4] = param->getDouble(iarg++);
      this->geom_data[5] = param->getDouble(iarg++);
      this->geom_data[6] = param->getDouble(iarg++);
      this->geom_data[7] = param->getDouble(iarg++);
      this->geom_data[8] = param->getDouble(iarg++);
      this->geom_data[9] = param->getDouble(iarg++);
      COUT1(" > HCP_WINDOW ANNULAR_TCONE " <<
	    this->geom_data[0] << " " <<  this->geom_data[1] << " " <<
	    this->geom_data[2] << " " <<  this->geom_data[3] << " " <<
	    this->geom_data[4] << " " <<  this->geom_data[5] << " " <<
	    this->geom_data[6] << " " <<  this->geom_data[7] << " " <<
	    this->geom_data[8] << " " <<  this->geom_data[9] );
      if (param->getString(iarg++) != "LEVEL") {
        CERR("FAZONE syntax problem. Expecting token LEVEL. Sample usage:\n\n" <<
             "HCP_WINDOW TCONE <x0> <y0> <z0> <r0-0> <r0-1> <x1> <y1> <z1> <r1-0> <r1-1> LEVEL <int> [NLAYERS <int>]");
      }
      this->level = param->getInt(iarg++);
      if ((iarg < param->size())&&(param->getString(iarg) == "NLAYERS")) {
        ++iarg;
        this->nlayers = param->getInt(iarg++);
      }
    }
    else if (token == "TCONE") {
      // ---------------------------------------------------------------
      // HCP_WINDOW TCONE <x0> <y0> <z0> <r0> <x1> <y1> <z1> <r1> LEVEL <int> [NLAYERS <int>]
      // ---------------------------------------------------------------
      this->type = TCONE_HCP_WINDOW;
      this->geom_data[0] = param->getDouble(iarg++);
      this->geom_data[1] = param->getDouble(iarg++);
      this->geom_data[2] = param->getDouble(iarg++);
      this->geom_data[3] = param->getDouble(iarg++);
      this->geom_data[4] = param->getDouble(iarg++);
      this->geom_data[5] = param->getDouble(iarg++);
      this->geom_data[6] = param->getDouble(iarg++);
      this->geom_data[7] = param->getDouble(iarg++);
      COUT1(" > HCP_WINDOW TCONE " <<
	    this->geom_data[0] << " " <<  this->geom_data[1] << " " <<
	    this->geom_data[2] << " " <<  this->geom_data[3] << " " <<
	    this->geom_data[4] << " " <<  this->geom_data[5] << " " <<
	    this->geom_data[6] << " " <<  this->geom_data[7] );
      if (param->getString(iarg++) != "LEVEL") {
        CERR("FAZONE syntax problem. Expecting token LEVEL. Sample usage:\n\n" <<
             "HCP_WINDOW TCONE <x0> <y0> <z0> <r0> <x1> <y1> <z1> <r1> LEVEL <int> [NLAYERS <int>]");
      }
      this->level = param->getInt(iarg++);
      if ((iarg < param->size())&&(param->getString(iarg) == "NLAYERS")) {
        ++iarg;
        this->nlayers = param->getInt(iarg++);
      }
    }
    else if (token == "PRISM") {
      // ---------------------------------------------------------------
      // HCP_WINDOW TCONE <x0> <y0> <z0> <rM0> <rm0> <x1> <y1> <z1> <rM0> <rm0> [ORTHN <nx1> <ny1> <nz1>] LEVEL <int> [NLAYERS <int>]
      // ---------------------------------------------------------------
      bool orthn_set = false;
      this->type = PRISM_HCP_WINDOW;
      this->geom_data[0] = param->getDouble(iarg++);
      this->geom_data[1] = param->getDouble(iarg++);
      this->geom_data[2] = param->getDouble(iarg++);
      this->geom_data[3] = param->getDouble(iarg++);
      this->geom_data[4] = param->getDouble(iarg++);
      this->geom_data[5] = param->getDouble(iarg++);
      this->geom_data[6] = param->getDouble(iarg++);
      this->geom_data[7] = param->getDouble(iarg++);
      this->geom_data[8] = param->getDouble(iarg++);
      this->geom_data[9] = param->getDouble(iarg++);
      this->geom_data[10] = 0.0;
      this->geom_data[11] = 0.0;
      this->geom_data[12] = 0.0;
      if (param->getString(iarg) == "ORTHN") {
        ++iarg;
        orthn_set = true;
        this->geom_data[10] = param->getDouble(iarg++);
        this->geom_data[11] = param->getDouble(iarg++);
        this->geom_data[12] = param->getDouble(iarg++);
      }

      if (param->getString(iarg++) != "LEVEL") {
        CERR("FAZONE syntax problem. Expecting token LEVEL. Sample usage:\n\n" <<
             "HCP_WINDOW PRISM <x0> <y0> <z0> <rM0> <rm0> <x1> <y1> <z1> <rM0> <rm0> [ORTHN <nx1> <ny1> <nz1>] LEVEL <int> [NLAYERS <int>]");
      }
      COUT1(" > HCP_WINDOW PRISM");
      COUT1("    > x0,l_major,l_minor: " << this->geom_data[0] << " " <<  this->geom_data[1] << " " << this->geom_data[2] << ", " <<  this->geom_data[3] << ", " << this->geom_data[4]);
      COUT1("    > x1,l_major,l_minor: " << this->geom_data[5] << " " <<  this->geom_data[6] << " " << this->geom_data[7] << ", " <<  this->geom_data[8] << ", " << this->geom_data[9]);
      if (orthn_set) {
        COUT1("    > major axis based on: " << this->geom_data[10] << " " <<  this->geom_data[11] << " " << this->geom_data[12]);
      }

      this->level = param->getInt(iarg++);
      if ((iarg < param->size())&&(param->getString(iarg) == "NLAYERS")) {
        ++iarg;
        this->nlayers = param->getInt(iarg++);
      }
    }
    else if (token == "SBIN") {
      // ---------------------------------------------------------------
      // HCP_WINDOW SBIN <filename> LEVEL <int> [NLAYERS <int>]
      // ---------------------------------------------------------------
      this->type = SBIN_HCP_WINDOW;
      this->sbin_filename = param->getString(iarg++);
      COUT1(" > HCP_WINDOW SBIN " << this->sbin_filename);
      if (param->getString(iarg++) != "LEVEL") {
        CERR("FAZONE syntax problem. Expecting token LEVEL. Sample usage:\n\n" <<
             "HCP_WINDOW SBIN <filename> LEVEL <int> [NLAYERS <int>]");
      }
      this->level = param->getInt(iarg++);
      if ((iarg < param->size())&&(param->getString(iarg) == "NLAYERS")) {
        ++iarg;
        this->nlayers = param->getInt(iarg++);
      }
    }
    else {
      CERR("unrecognized HCP_WINDOW: " << token);
    }
  }

};

class TriStuff {
public:

  class Tri {
  public:

    double x0[3];
    double x1[3];
    double x2[3];

    void init(const double x0[3],const double x1[3],const double x2[3]) {
      FOR_I3 this->x0[i] = x0[i];
      FOR_I3 this->x1[i] = x1[i];
      FOR_I3 this->x2[i] = x2[i];
    }

    void getCentroid(double xc[3]) const {
      FOR_I3 xc[i] = (x0[i] + x1[i] + x2[i])/3.0;
    }

  };

  static void initSbin(vector<Tri>& triVec,const string& sbin_filename) {

    FILE * fp = NULL;
    const int file_err = MiscUtils::openFile(&fp,sbin_filename,"rb");
    if (file_err != 0) CERR(" > HCP_WINDOW SBIN file DNE");

    bool byte_swap = false;
    int version;
    fread(&version,sizeof(int),1,fp);
    if ((version < 1)||(version > 10)) {
      version = ByteSwap::byteSwap(version);
      if ((version < 1)||(version > 10)) {
        CERRT("byteswap does not produce reasonable version: " << version,20);
      }
      byte_swap = true;
    }
    assert(version == 1);

    int count;
    fread(&count,sizeof(int),1,fp);
    if (byte_swap)
      count = ByteSwap::byteSwap(count);

    for (int izone = 0; izone < count; ++izone) {
      int length;
      fread(&length,sizeof(int),1,fp);
      if (byte_swap)
        length = ByteSwap::byteSwap(length);
      char cbuf[length+1];
      fread(cbuf,sizeof(char),length,fp); // no byteswap for char
    }

    int nsp;
    fread(&nsp,sizeof(int),1,fp);
    if (byte_swap)
      nsp = ByteSwap::byteSwap(nsp);
    double (*xp)[3] = new double[nsp][3];
    fread(xp,sizeof(double),nsp*3,fp);
    if (byte_swap)
      ByteSwap::byteSwap(xp,nsp);
    int nst;
    fread(&nst,sizeof(int),1,fp);
    if (byte_swap)
      nst = ByteSwap::byteSwap(nst);
    int (*spost)[3] = new int[nst][3];
    fread(spost,sizeof(int),nst*3,fp);
    if (byte_swap)
      ByteSwap::byteSwap(spost,nst);
    fclose(fp);

    // push into triVec...
    assert(triVec.empty());
    triVec.resize(nst);
    for (int ist = 0; ist < nst; ++ist) {
      const double * const x0 = xp[spost[ist][0]];
      const double * const x1 = xp[spost[ist][1]];
      const double * const x2 = xp[spost[ist][2]];
      triVec[ist].init(x0,x1,x2);
    }

    // cleanup...
    delete[] xp;
    delete[] spost;

  }

  static void initBox(vector<Tri>& triVec,const double x0,const double x1,
		      const double y0,const double y1,
		      const double z0,const double z1) {


    //cout << "initBox: " << x0 << " " << x1 << " " << y0 << " " << y1 << " " << z0 << " " << z1 << endl;

    // add 12 tris describing a box...
    const int nst0 = triVec.size();
    triVec.resize(nst0+12);

    const double x000[3] = { x0, y0, z0 };
    const double x001[3] = { x0, y0, z1 };
    const double x010[3] = { x0, y1, z0 };
    const double x011[3] = { x0, y1, z1 };
    const double x100[3] = { x1, y0, z0 };
    const double x101[3] = { x1, y0, z1 };
    const double x110[3] = { x1, y1, z0 };
    const double x111[3] = { x1, y1, z1 };

    int itri = nst0;
    triVec[itri++].init(x000,x001,x011);
    triVec[itri++].init(x000,x011,x010);
    triVec[itri++].init(x000,x100,x101);
    triVec[itri++].init(x000,x101,x001);
    triVec[itri++].init(x001,x101,x111);
    triVec[itri++].init(x001,x111,x011);
    triVec[itri++].init(x011,x111,x110);
    triVec[itri++].init(x011,x110,x010);
    triVec[itri++].init(x000,x010,x110);
    triVec[itri++].init(x000,x110,x100);
    triVec[itri++].init(x100,x110,x111);
    triVec[itri++].init(x100,x111,x101);
    assert(itri == nst0+12);

  }

  static void initPrism(vector<Tri>& triVec,
                        const double x0,const double y0,const double z0,const double rmaj0,const double rmin0,
                        const double x1,const double y1,const double z1,const double rmaj1,const double rmin1,const double m_axis0,const double m_axis1,const double m_axis2) {


    const double maj_axis[3] = {m_axis0,m_axis1,m_axis2};
    const double xc0[3] = { x0, y0, z0 };
    const double xc1[3] = { x1, y1, z1 };

    // absolute value ensures no folding as well as positive volume
    const double rM0 = fabs(0.5*rmaj0);
    const double rm0 = fabs(0.5*rmin0);
    const double rM1 = fabs(0.5*rmaj1);
    const double rm1 = fabs(0.5*rmin1);

    const double SMALL = 1E-12;
    if (rm0 < SMALL || rm1 < SMALL || rM0 < SMALL || rM1 < SMALL) CERR("cannot create prism with either major/minor axis length = 0");

    double axis[3];
    FOR_I3 axis[i] = xc1[i] - xc0[i];

    double radDir1[3];
    double radDir2[3];
    MiscUtils::getOrthogonalVectors(radDir1,radDir2,xc0,axis,maj_axis);

    double x000[3];
    FOR_I3 x000[i] = xc0[i] - rM0*radDir1[i] - rm0*radDir2[i];
    double x001[3];
    FOR_I3 x001[i] = xc0[i] - rM0*radDir1[i] + rm0*radDir2[i];
    double x010[3];
    FOR_I3 x010[i] = xc0[i] + rM0*radDir1[i] - rm0*radDir2[i];
    double x011[3];
    FOR_I3 x011[i] = xc0[i] + rM0*radDir1[i] + rm0*radDir2[i];

    double x100[3];
    FOR_I3 x100[i] = xc1[i] - rM1*radDir1[i] - rm1*radDir2[i];
    double x101[3];
    FOR_I3 x101[i] = xc1[i] - rM1*radDir1[i] + rm1*radDir2[i];
    double x110[3];
    FOR_I3 x110[i] = xc1[i] + rM1*radDir1[i] - rm1*radDir2[i];
    double x111[3];
    FOR_I3 x111[i] = xc1[i] + rM1*radDir1[i] + rm1*radDir2[i];

    // add 12 tris describing a box...
    const int nst0 = triVec.size();
    triVec.resize(nst0+12);

    int itri = nst0;
    triVec[itri++].init(x000,x001,x011);
    triVec[itri++].init(x000,x011,x010);
    triVec[itri++].init(x000,x100,x101);
    triVec[itri++].init(x000,x101,x001);
    triVec[itri++].init(x001,x101,x111);
    triVec[itri++].init(x001,x111,x011);
    triVec[itri++].init(x011,x111,x110);
    triVec[itri++].init(x011,x110,x010);
    triVec[itri++].init(x000,x010,x110);
    triVec[itri++].init(x000,x110,x100);
    triVec[itri++].init(x100,x110,x111);
    triVec[itri++].init(x100,x111,x101);
    assert(itri == nst0+12);
  }

  static void initTcone(vector<Tri>& triVec,
                        const double x0,const double y0,const double z0,const double rad0,
                        const double x1,const double y1,const double z1,const double rad1,const int n=128) {


    const double xc0[3] = { x0, y0, z0 };
    const double xc1[3] = { x1, y1, z1 };

    // absolute value ensures no singularity in the middle of the tcone as well as positive volume
    const double r0 = fabs(rad0);
    const double r1 = fabs(rad1);

    const double SMALL = 1E-12;
    if (r0 < SMALL || r1 < SMALL) CERR("cannot create a truncated cone with either radius = 0");

    double axis[3];
    FOR_I3 axis[i] = xc1[i] - xc0[i];

    const int nsp = 2*n+2;
    double (*xp_tmp)[3] = new double[nsp][3];  // holds tri points
    // first and last node are cap centers
    FOR_I3 {
      xp_tmp[0][i] = xc0[i];
      xp_tmp[nsp - 1][i] = xc1[i];
    }

    createCirclePts(xp_tmp,1,xc0,axis,r0,n);
    createCirclePts(xp_tmp,n+1,xc1,axis,r1,n);

    // now create tris
    const int nst0 = triVec.size();
    triVec.resize(nst0+4*n);

    // cap0, cap1
    facetCircleToPoint(triVec,xp_tmp,0,1,nst0,n);
    facetCircleToPoint(triVec,xp_tmp,nsp-1,n+1,nst0+3*n,n,true);

    // wall
    facetCircleToCircle(triVec,xp_tmp,1,n+1,nst0+n,n,true);

    DELETE(xp_tmp);
  }

  static void initAnnularTcone(vector<Tri>& triVec,
			       const double x0,const double y0,const double z0,const double _r00,const double _r01,
			       const double x1,const double y1,const double z1,const double _r10,const double _r11,const int n=128) {


    const double xc0[3] = { x0, y0, z0 };
    const double xc1[3] = { x1, y1, z1 };

    // absolute value ensures no singularity in the middle of the tcone as well as positive volume
    // ensure radii are ordered min/max
    const double r00 = min(fabs(_r00),fabs(_r01));
    const double r01 = max(fabs(_r00),fabs(_r01));
    const double r10 = min(fabs(_r10),fabs(_r11));
    const double r11 = max(fabs(_r10),fabs(_r11));

    const double SMALL = 1E-12;
    if (r00 < SMALL || r01 < SMALL || r10 < SMALL || r11 < SMALL) CERR("cannot create a truncated cone with any radius = 0");

    double axis[3];
    FOR_I3 axis[i] = xc1[i] - xc0[i];

    const int nsp = 4*n;
    double (*xp_tmp)[3] = new double[nsp][3];  // holds tri points

    createCirclePts(xp_tmp,0,xc0,axis,r00,n);
    createCirclePts(xp_tmp,n,xc0,axis,r01,n);
    createCirclePts(xp_tmp,2*n,xc1,axis,r10,n);
    createCirclePts(xp_tmp,3*n,xc1,axis,r11,n);

    // now create tris
    const int nst0 = triVec.size();
    triVec.resize(nst0+8*n);

    facetCircleToCircle(triVec,xp_tmp,0,n,nst0+0,n,true);
    facetCircleToCircle(triVec,xp_tmp,n,3*n,nst0+2*n,n,true);
    facetCircleToCircle(triVec,xp_tmp,2*n,0,nst0+4*n,n,true);
    facetCircleToCircle(triVec,xp_tmp,3*n,2*n,nst0+6*n,n,true);

    DELETE(xp_tmp);
  }

  /*
   * create the facets between a circle of points and a single point
   */
  static void facetCircleToPoint(vector<Tri>& triVec, const double (*xp_tmp)[3], const int indexPt, const int indexCircle, const int st0, const int n, const bool flip = false) {
    // flip dictates node ordering (normal direction convention)
    int pt1_inc = 1;
    int pt2_inc = 0;
    if (flip) {
      pt1_inc = 0;
      pt2_inc = 1;
    }

    for (int i=0, limit=n; i < limit; ++i) {
      triVec[st0+i].init(xp_tmp[indexPt],
                         xp_tmp[indexCircle + (i+pt1_inc)%n],
                         xp_tmp[indexCircle + (i+pt2_inc)%n]);
    }
  }

  /*
   * create the facets between two circles of points, assuming they have the same n
   */
  static void facetCircleToCircle(vector<Tri>& triVec, const double (*xp_tmp)[3], const int indexC0, const int indexC1, const int st0, const int n, const bool flip = false) {
    // flip dictates node ordering (normal direction convention)
    int pt1_inc = 1;
    int pt2_inc = 0;
    if (flip) {
      pt1_inc = 0;
      pt2_inc = 1;
    }

    for (int i=0, limit=n; i < limit; ++i) {
      triVec[st0+(2*i)].init(xp_tmp[indexC0 + (i+pt1_inc)%n],
                             xp_tmp[indexC0 + (i+pt2_inc)%n],
                             xp_tmp[indexC1 + (i+pt1_inc)%n]);

      triVec[st0+(2*i + 1)].init(xp_tmp[indexC0 + (i+pt2_inc)%n],
                                 xp_tmp[indexC1 + (i+pt2_inc)%n],
                                 xp_tmp[indexC1 + (i+pt1_inc)%n]);
    }
  }

};

#define HCP_BIT_MAX 28  // do not go above 30
#define HCP_LEVEL_MAX 24

class HcpVertex {
public:
  double x[3];
  int level;
  HcpVertex() {}
  HcpVertex(const double x[3],const int level) {
    this->x[0] = x[0];
    this->x[1] = x[1];
    this->x[2] = x[2];
    this->level = level;
  }
};

enum HcpPacking {
  HCP_PACKING_ONE, // most uniform faces (singularity prone)
  HCP_PACKING_ROOT2, // most spherical
  HCP_PACKING_ROOT3, // similar to root2, but stretched in one-direction
};

class HcpPointBuilder {

private:

  Surface * const surface;

public:

  double hcp_delta;
  bool got_hcp_delta;

  double hcp_x0[3];
  bool got_hcp_x0;

  double hcp_dx0[3];
  bool got_hcp_dx0;

  double hcp_packing_factor;
  bool got_hcp_packing;
  int hcp_packing;

  bool b_mesh_inspector;
  double x_mi[3];
  double r_mi;

  HcpPointBuilder(Surface * const surface_) : surface(surface_),
					      got_hcp_delta(false),
					      got_hcp_x0(false),
					      got_hcp_dx0(false),
					      got_hcp_packing(false),
					      b_mesh_inspector(false) {

    COUT1("HcpPointBuilder()");
    assert(surface->status == SHM_SURFACE);

  }

  ~HcpPointBuilder() {

    COUT1("~HcpPointBuilder()");

  }

  void setMeshInspectorSphere(const double x_mi_[3],const double r_mi_) {

    assert(!b_mesh_inspector);
    b_mesh_inspector = true;
    FOR_I3 x_mi[i] = x_mi_[i];
    r_mi = r_mi_;

  }

  void setHcpDelta(const double hcp_delta_) {

    COUT1(" > HcpPointBuilder::setHcpDelta(): " << hcp_delta_);
    hcp_delta = hcp_delta_;
    got_hcp_delta = true;

  }

  void setHcpX0(const double hcp_x0_[3]) {

    COUT1(" > HcpPointBuilder::setHcpX0(): " << hcp_x0_[0] << " " << hcp_x0_[1] << " " << hcp_x0_[2]);
    FOR_I3 hcp_x0[i] = hcp_x0_[i];
    got_hcp_x0 = true;

  }


  void setHcpDx0(const double hcp_dx0_[3]) {

    COUT1(" > HcpPointBuilder::setHcpDx0(): " << hcp_dx0_[0] << " " << hcp_dx0_[1] << " " << hcp_dx0_[2]);
    FOR_I3 hcp_dx0[i] = hcp_dx0_[i];
    got_hcp_dx0 = true;

  }

  void setHcpPacking(const string& name) {

    COUT1(" > HcpPointBuilder::setHcpPackingFactor(): " << name);
    if (name == "ROOT3") {
      hcp_packing_factor = 0.5*sqrt(3.0);
      hcp_packing = HCP_PACKING_ROOT3;
    }
    else if (name == "ROOT2") {
      hcp_packing_factor = 0.5*sqrt(2.0);
      hcp_packing = HCP_PACKING_ROOT2;
    }
    else if (name == "ONE") {
      hcp_packing_factor = 0.5;
      hcp_packing = HCP_PACKING_ONE;
    }
    else {
      CERR("unrecognized HCP_PACKING: " << name << ". Valid options are ONE (default), ROOT3 and ROOT2.");
    }
    got_hcp_packing = true;

  }

  double getPointsDeltaForLevel(const int level) const {

    // this returns the initial guess for the points delta -- i.e. the
    // sphere inside which all nbrs will be collected and cut against to
    // build the VD...

    //double factor = getDoubleParam("FACTOR");

    assert((level >= 0)&&(level <= HCP_LEVEL_MAX));
    assert(got_hcp_delta);
    assert(got_hcp_packing);

    // note: these strange packing fctors are designed to set the initial
    // sphere for nbr seach large enough to complete the voronoi diagram
    // for a particular packing in one iteration with minimal nbrs...

    switch (hcp_packing) {
    case HCP_PACKING_ONE:
      return hcp_delta/double(1<<level)*1.215;
    case HCP_PACKING_ROOT2:
      return hcp_delta/double(1<<level)*1.405;
    case HCP_PACKING_ROOT3:
      return hcp_delta/double(1<<level)*1.575;
    default:
      assert(0);
    }

  }

  void buildAll(vector<HcpVertex>& vertexVec,const vector<HcpWindowData*> hcpWindowDataVec, const bool forceCart=false, const bool two2one=false) {

    COUT1(" > HcpPointBuilder::buildAll()");
    if (forceCart) COUT1("    > forcing CARTesian points");
    // check that we have hcp_delta...

    if (!got_hcp_delta) {
      CERR("HCP_DELTA not set");
    }

    // -------------------------------------------------------------------------------
    // raytracing the y,z directions is done using an integer pair (j,k)...
    // -------------------------------------------------------------------------------

    if (!got_hcp_packing) {
      hcp_packing_factor = 0.5*sqrt(3.0);
      hcp_packing = HCP_PACKING_ROOT3;
      got_hcp_packing = true;
      COUT1(" > HCP_PACKING set to default: ROOT3");
    }

    // now SCALE hcp_delta depending on the packing such that
    // all packings have the volumetric number-density of ROOT3

    if (hcp_packing == HCP_PACKING_ONE) {
      hcp_delta *= pow(3.0,1.0/3.0);
    }
    else if (hcp_packing == HCP_PACKING_ROOT2) {
      hcp_delta *= pow(3.0/2.0,1.0/3.0);
    }

    // The user can specify one or both of HCP_X0 and/or HCP_DX0 to set
    // the center of the point latice. The default is a small perturbation
    // of the bbox center...

    if (got_hcp_x0) {
      if (got_hcp_dx0) {
	FOR_I3 hcp_x0[i] += hcp_dx0[i];
      }
    }
    else {
      // when hcp_x0 is not provided, use the bbox center as a starting point....
      FOR_I3 hcp_x0[i] = 0.5*(surface->bbmin[i]+surface->bbmax[i]);
      if (got_hcp_dx0) {
	FOR_I3 hcp_x0[i] += hcp_dx0[i];
      }
      else {
        // 2^12 = 4096 and 1/4096 ~ 0.0002441, so I think this supports 12 levels
	FOR_I3 hcp_x0[i] += 1.0E-4*hcp_delta; // apply a small perturbation
      }
    }
    COUT1(" > HCP_X0: " << hcp_x0[0] << " " << hcp_x0[1] << " " << hcp_x0[2]);

    double offset_factor = 1.0;

    if (forceCart) {
      // for cart...
      // not sure if this works -- need to test
      hcp_packing_factor = 1.0; // or 1 for cart
      offset_factor = 0.0;
    }
    const double one_o_hcp_packing_factor = 1.0 / hcp_packing_factor;

    const double delta_max = max(surface->bbmax[0]-surface->bbmin[0],max(surface->bbmax[1]-surface->bbmin[1],surface->bbmax[2]-surface->bbmin[2]));
    const int Nbase = int( log(hcp_delta*hcp_packing_factor/delta_max)/log(2.0) + HCP_BIT_MAX );
    const double dxp = double(1<<Nbase)/(hcp_delta*hcp_packing_factor); // actually dj/dy == dk/dz
    const double one_o_dxp = 1.0/dxp;


    if (checkParam("HCP_POINT_DEV")) {


      MPI_Pause("got HCP_POINT_DEV");

    }



    // ------------------------------------------------------------------------------
    // counts...
    // each type of refinement element is defined by a bounding box. We could these
    // elements in a list that uses the index and type...

    const int n_bbox_type = 2+4*HCP_LEVEL_MAX;
    int8 my_bbox_type_count[n_bbox_type];

    // [0]: error
    // [1]: surface mixedTris -- in/out
    // [2:2+HCP_LEVEL_MAX-1]: mixedTris at each level...
    // [2+HCP_LEVEL_MAX:2+2*HCP_LEVEL_MAX-1]: mixedSpheres at each level...
    // [2+2*HCP_LEVEL_MAX:2+3*HCP_LEVEL_MAX-1]: bloatedSurfaceTris at each level...
    // [2+3*HCP_LEVEL_MAX:2+4*HCP_LEVEL_MAX-1]: bloatedTris at each level...
    //
    // Notes: To save more memory, we could introduce surfaceTri as just an int, so there would be:
    // surfaceTri
    // Tri
    // Sphere
    // bloatedSurfaceTri
    // bloatedTri
    //
    // each of these 5 types could do the integer transforms on its own as needed.
    // ------------------------------------------------------------------------------

    const bool b_bbox_dupl = getBoolParam("DUPLICATE_BBOX", false);

    int bbmin0[2],bbmax0[2]; // the surface (i.e. level 0) bounding box

    int (*bbmin)[2] = NULL;
    int (*bbmax)[2] = NULL;
    vector<int8> indexVec;

    // use shared memory on the node to hold only those refinement elements that
    // overlap our bounding box after partitioning...

    if (mpi_rank_shared == 0) {

      for (int it = 0; it < n_bbox_type; ++it) my_bbox_type_count[it] = 0;

      int8 bbox_count = 0; // the global index of the hcp window element / bbox...
      vector<BboxJK> bboxVec;
      //bboxVec.reserve(2*surface->nst/mpi_size_internode); // helpful?

      {

        int my_bbox[4] = { (1<<HCP_BIT_MAX), (1<<HCP_BIT_MAX), (1<<HCP_BIT_MAX), (1<<HCP_BIT_MAX) };

        for (int ist = 0; ist < surface->nst; ++ist) {
          // all tris participate in the surface limiting...
          int8 index = bbox_count++;
          if (index%mpi_size_internode == mpi_rank_internode) {
            // we own this one. Create and discard a mixed tri just to
            // get the bounding box...
            Surface::MixedTri mt;
            mt.init(surface->xp[surface->spost[ist][0]],
              surface->xp[surface->spost[ist][1]],
              surface->xp[surface->spost[ist][2]],
              hcp_x0,dxp);
              bboxVec.push_back(BboxJK());
              const int it = 1; // this is type 1...
              ++my_bbox_type_count[it];
              bboxVec.back().type_and_index = ( (int8(it)<<48) | int8(index) ); // shift the type into index
              bboxVec.back().density = 1.0;
              mt.setBboxJK(bboxVec.back().jkmin,bboxVec.back().jkmax);
              my_bbox[0] = min(my_bbox[0],bboxVec.back().jkmin[0]);
              my_bbox[1] = min(my_bbox[1],bboxVec.back().jkmin[1]);
              // for max, flip sign so we can use min...
              my_bbox[2] = min(my_bbox[2],-bboxVec.back().jkmax[0]);
              my_bbox[3] = min(my_bbox[3],-bboxVec.back().jkmax[1]);
            }
          }

          // TODO: could store the number of surface bboxes to allow updating (further reducing)
          // of the node-based bboxes beyond splitting...

          int bbox[4];
          MPI_Allreduce(my_bbox,bbox,4,MPI_INT,MPI_MIN,mpi_comm_internode);

          // bbmin0/bbmax0 eventually holds the local (node-based) integer limits.
          // Start with the surface limits...

          bbmin0[0] = bbox[0];
          bbmin0[1] = bbox[1];
          bbmax0[0] = -bbox[2]; // note sign change
          bbmax0[1] = -bbox[3];

        }


        // now process other windows in the same way, but without updating the global bbmin/bbmax. These
        // we leave at the limits of the original surface...

        if (mpi_rank == 0) cout << " > adding bboxes..." << endl;

        for (int iw = 0; iw < hcpWindowDataVec.size(); ++iw) {
          const HcpWindowData * const window = hcpWindowDataVec[iw];
          if (window->type == FAZONE_HCP_WINDOW) {
            surface->clearZoneFlags();
            istringstream iss(window->zones);
            string zonename;
            bool found = false;
            while (std::getline(iss,zonename,',')) {
              COUT2("processing zone: " << zonename);
              if (zonename == "ALL") {
                surface->setAllZoneFlags();
                found = true;
                break;  // no need to process other zones if this is used
              }
              else {
                try {
                  surface->setZoneFlag(zonename);
                  found = true;
                }
                catch ( ...) {
                  COUT1(" > unable to find zone: " << zonename);
                }
              }
            }
            if (!found) continue;
            for (int ist = 0; ist < surface->nst; ++ist) {
              const int izone = surface->znost[ist];
              if ((izone >= 0)&&(surface->getZoneFlag(izone))) {
                // here we add the distance of each new level to delta sum, starting
                // with the finest...
                double delta = 0.0;
                for (int this_level = window->level; this_level >= 1; --this_level) {
                  const double this_delta = hcp_delta*double(window->nlayers)/double(1<<this_level);
                  delta += this_delta;
                  int delta_int = int(delta*dxp); delta_int += delta_int%2; // ensure even so bbox remains odd
                  int8 index = bbox_count++;
                  if (index%mpi_size_internode == mpi_rank_internode) {
                    // we own this one. Create and discard a mixed tri to
                    // get the bounding box...
                    Surface::MixedTri mt;
                    mt.init(surface->xp[surface->spost[ist][0]],surface->xp[surface->spost[ist][1]],surface->xp[surface->spost[ist][2]],hcp_x0,dxp);
                    bboxVec.push_back(BboxJK());
                    // these are bloatedSurfaceTris...
                    const int it = 1+2*HCP_LEVEL_MAX+this_level;
                    ++my_bbox_type_count[it];
                    bboxVec.back().type_and_index = ( (int8(it)<<48) | index );
                    // the density is a parameter that can help to trade between
                    // memory balance of the bbox elements and memory/load balance
                    // with the x-aligned rays. Use the square of the level as a start...
                    //bboxVec.back().density = 1.0; //double(this_level*this_level); // the density
                    bboxVec.back().density = double(this_level); // the density
                    mt.setBboxJK(bboxVec.back().jkmin,bboxVec.back().jkmax);
                    // increase the bounding box by the bloated tri radius "delta"
                    // in integer coordinates...
                    bboxVec.back().jkmin[0] -= delta_int;
                    bboxVec.back().jkmin[1] -= delta_int;
                    bboxVec.back().jkmax[0] += delta_int;
                    bboxVec.back().jkmax[1] += delta_int;
                  }
                }
              }
            }
          }
          else if (window->type == SPHERE_HCP_WINDOW) {
            int min_level = window->level;
            if (window->nlayers >= 1) min_level = 1;
            // if the user has specified nlayers, we add a sphere for each layer...
            double r = window->geom_data[3];
            for (int this_level = window->level; this_level >= min_level; --this_level) {
              // after the first level, increase the radius...
              if (this_level < window->level) {
                const double dr = hcp_delta*double(window->nlayers)/double(1<<this_level);
                r += dr;
              }
              int8 index = bbox_count++;
              if (index%mpi_size_internode == mpi_rank_internode) {
                // we own this one. Create and discard a mixed sphere to
                // get the bounding box...
                Surface::MixedSphere ms;
                ms.init(window->geom_data,r,hcp_x0,dxp);
                bboxVec.push_back(BboxJK());
                // these are mixedSpheres...
                const int it = 1+HCP_LEVEL_MAX+this_level;
                ++my_bbox_type_count[it];
                bboxVec.back().type_and_index = ( (int8(it)<<48) | index );
                bboxVec.back().density = double(this_level); // the density
                ms.setBboxJK(bboxVec.back().jkmin,bboxVec.back().jkmax);
              }
            }
          }
          else if ((window->type == BOX_HCP_WINDOW) || (window->type == TCONE_HCP_WINDOW)|| (window->type == ANNULAR_TCONE_HCP_WINDOW) || (window->type == SBIN_HCP_WINDOW) || (window->type == PRISM_HCP_WINDOW)) {
            // these windows use functionality in TriStuff to build simple windows...
            vector<TriStuff::Tri> triVec;
            switch (window->type) {
              case BOX_HCP_WINDOW:
                TriStuff::initBox(triVec,
                window->geom_data[0],window->geom_data[1],
                window->geom_data[2],window->geom_data[3],
                window->geom_data[4],window->geom_data[5]);
                break;
              case TCONE_HCP_WINDOW:
                TriStuff::initTcone(triVec,
                window->geom_data[0],window->geom_data[1],
                window->geom_data[2],window->geom_data[3],
                window->geom_data[4],window->geom_data[5],
                window->geom_data[6],window->geom_data[7]);
                break;
              case ANNULAR_TCONE_HCP_WINDOW:
                TriStuff::initAnnularTcone(triVec,
                window->geom_data[0],window->geom_data[1],
                window->geom_data[2],window->geom_data[3],
                window->geom_data[4],window->geom_data[5],
                window->geom_data[6],window->geom_data[7],
                window->geom_data[8],window->geom_data[9]); // XXXXX: could/should take a length scale: hcp_delta/double(1<<window->level)
                break;
              case PRISM_HCP_WINDOW:
                TriStuff::initPrism(triVec,
                window->geom_data[0],window->geom_data[1],
                window->geom_data[2],window->geom_data[3],
                window->geom_data[4],window->geom_data[5],
                window->geom_data[6],window->geom_data[7],
                window->geom_data[8],window->geom_data[9],
                window->geom_data[10],window->geom_data[11],
                window->geom_data[12]);
                break;
              case SBIN_HCP_WINDOW:
                TriStuff::initSbin(triVec,window->sbin_filename);
                break;
              default:
                assert(0);
            }
            // add the tris first...
            COUT2("processing triVec");
            for (int itri = 0; itri < triVec.size(); ++itri) {
              int8 index = bbox_count++;
              if (index%mpi_size_internode == mpi_rank_internode) {
                // we own this one. Create and discard a mixed tri to
                // get the bounding box...
                Surface::MixedTri mt;
                mt.init(triVec[itri].x0,triVec[itri].x1,triVec[itri].x2,hcp_x0,dxp);
                bboxVec.push_back(BboxJK());
                // these are mixedSpheres...
                const int it = 1+window->level; // type index
                ++my_bbox_type_count[it];
                bboxVec.back().type_and_index = ( (int8(it)<<48) | index );
                bboxVec.back().density = double(window->level); // the density
                mt.setBboxJK(bboxVec.back().jkmin,bboxVec.back().jkmax);
              }
            }
            // if the HCP_WINDOW has requested layers, then add the layers...
            if (window->nlayers >= 1) {
              double r = 0.0;
              for (int this_level = window->level-1; this_level >= 1; --this_level) {
                const double dr = hcp_delta*double(window->nlayers)/double(1<<this_level);
                r += dr;
                for (int itri = 0; itri < triVec.size(); ++itri) {
                  int8 index = bbox_count++;
                  if (index%mpi_size_internode == mpi_rank_internode) {
                    Surface::BloatedTri bt;
                    bt.init(triVec[itri].x0,triVec[itri].x1,triVec[itri].x2,r);
                    bboxVec.push_back(BboxJK());
                    const int it = 1+3*HCP_LEVEL_MAX+this_level;
                    ++my_bbox_type_count[it];
                    bboxVec.back().type_and_index = ( (int8(it)<<48) | index );
                    bboxVec.back().density = double(this_level); // the density
                    bt.setBboxJK(bboxVec.back().jkmin,bboxVec.back().jkmax,hcp_x0,dxp);
                  }
                }
              }
            }
          }
          else {
            assert(0);
          }
        }
        COUT2("done with windows");
        // report...

        {
          // start with base mixedTris...
          int8 my_mem = sizeof(Surface::MixedTri)*my_bbox_type_count[1];

          // mixedTris at various levels...
          for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
            const int it = 1+level;
            my_mem += sizeof(Surface::MixedTri)*my_bbox_type_count[it];
          }

          // mixedSpheres at various levels...
          for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
            const int it = 1+HCP_LEVEL_MAX+level;
            my_mem += sizeof(Surface::MixedSphere)*my_bbox_type_count[it];
          }

          // bloatedSurfaceTris at various levels...
          for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
            const int it = 1+2*HCP_LEVEL_MAX+level;
            my_mem += sizeof(Surface::BloatedSurfaceTri)*my_bbox_type_count[it];
          }

          // bloatedTris at various levels...
          for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
            const int it = 1+3*HCP_LEVEL_MAX+level;
            my_mem += sizeof(Surface::BloatedTri)*my_bbox_type_count[it];
          }

          int8 mem_sum;
          MPI_Reduce(&my_mem,&mem_sum,1,MPI_INT8,MPI_SUM,0,mpi_comm_internode);
          if (mpi_rank == 0)
          cout << " > unique bbox count: " << bbox_count << ", memory: " <<
          double(mem_sum)/1.0E+6 << " MB, or " <<
          double(mem_sum)/1.0E+6/double(mpi_size_internode) << " MB/node" << endl;

        }


        // done processing other windows...

        int8   * send_buf_int8   = NULL;
        double * send_buf_double = NULL;
        int    * send_buf_int    = NULL;
        int send_count_max = 0;

      int8   * recv_buf_int8   = NULL;
      double * recv_buf_double = NULL;
      int    * recv_buf_int    = NULL;
      int recv_count_max = 0;

      int * send_count = new int[mpi_size_internode];
      int * send_disp = new int[mpi_size_internode];
      int * recv_count = new int[mpi_size_internode];
      int * recv_disp = new int[mpi_size_internode];

      // --------------------------------------------------------------
      // We now have all the bounding boxes. Recursively split in jk
      // space, redistributing the bboxes accordingly. This will produce
      // some bbox duplication.
      // --------------------------------------------------------------

      MPI_Comm mpi_split_comm; MPI_Comm_dup(mpi_comm_internode,&mpi_split_comm);
      int mpi_split_size = mpi_size_internode;

      if (mpi_rank == 0)
	cout << " > recursively split and duplicate.";

      while (mpi_split_size > 1) {

	if (mpi_rank == 0)  {
	  cout << ".";
	  cout.flush();
	}

	// now iterate in both directions to determine best split...
	// choose a direction...

	int mpi_split_rank;
	MPI_Comm_rank(mpi_split_comm, &mpi_split_rank);

	int id = 0;
	if (bbmax0[1]-bbmin0[1] > bbmax0[0]-bbmin0[0])
	  id = 1;
	//const int idt = (id+1)%2;

	//cout << "rank: " << mpi_rank << " splitting as rank: " << mpi_split_rank << " in size: " << mpi_split_size << " id: " << id << endl;

	// split in the middle (or as close to the middle as possible for odd size)...

	int mpi_mid = mpi_split_size/2;

	// and figure out where the bbmid goes to balance the density...

	int bb0 = bbmin0[id];
	int bb1 = bbmax0[id];
	int bbmid;
	int my_count[2];
	do {

	  FOR_I2 my_count[i] = 0;
	  double my_wgt[2] = { 0.0, 0.0 };

	  // set the mid point and wgt...
	  bbmid = (bb0+bb1)/2;
	  if (bbmid%2 == 0) bbmid += 1; // ensure odd

	  for (int ii = 0; ii < bboxVec.size(); ++ii) {

	    /*
	      assert(bboxVec[ii].jkmin[0]%2 == 0);
	      assert(bboxVec[ii].jkmin[1]%2 == 0);
	      assert(bboxVec[ii].jkmax[0]%2 == 0);
	      assert(bboxVec[ii].jkmax[1]%2 == 0);
	    */

	    // each bounding box has a weight. Here we split the weight according to the overlap...
	    if ( (bboxVec[ii].jkmin[id] < bbmid)||(b_bbox_dupl)) {
	      // this bbox has some overlap with the first partition. Add the density times the
	      // overlap area. Note that we limit by the current bbox in the transverse direction...
	      ++my_count[0];
	      my_wgt[0] += bboxVec[ii].density;
	      //my_wgt[0] += bboxVec[ii].density*
	      //	double( min(bbmax0[idt],bboxVec[ii].jkmax[idt]) - max(bbmin0[idt],bboxVec[ii].jkmin[idt]) )*
	      //	double( min(bbmid,      bboxVec[ii].jkmax[id])  - max(bbmin0[id], bboxVec[ii].jkmin[id])  );
	    }

	    if ( (bboxVec[ii].jkmax[id] > bbmid)||(b_bbox_dupl)) {
	      // this bbox has some overlap with the second partition. Add the density times the
	      // overlap area...
	      ++my_count[1];
	      my_wgt[1] += bboxVec[ii].density;
	      //my_wgt[1] += bboxVec[ii].density*
	      //	double( min(bbmax0[idt],bboxVec[ii].jkmax[idt]) - max(bbmin0[idt],bboxVec[ii].jkmin[idt]) )*
	      //	double( min(bbmax0[id], bboxVec[ii].jkmax[id])  - max(bbmid,      bboxVec[ii].jkmin[id])  );
	    }
	  }

	  // reduce wgt. Note that we do not reduce count here. It is used to manage the
	  // memory below...
	  double wgt[2];
	  MPI_Allreduce(my_wgt,wgt,2,MPI_DOUBLE,MPI_SUM,mpi_split_comm);

	  //if (mpi_split_rank == 0)
	  //cout << mpi_rank << " wgts in dim: " << id << " " << wgt[0] << " " << wgt[1] << " dbb: " << bb1-bb0 << endl;

	  if (wgt[0]*double(mpi_split_size-mpi_mid) > wgt[1]*double(mpi_mid)) {
	    bb1 = bbmid;
	  }
	  else {
	    bb0 = bbmid;
	  }

	} while ( (bb1-bb0) > 2 );

	// when we exit from the above loop, split in the direction of lower total wgt (i.e. more efficient split)...

	if (mpi_split_rank < mpi_mid) {

	  // we are in the first half, so our bbox gets modified...
	  // NOTE: we should think more carefully about this to further minimize
	  // the bbox when possible -- e.g. T-shaped domains. We could record the
	  // maximum index of the surface part of the bboxVec (it is always added first)
	  // and then limit appropriately during the following copy/exchange...
	  bbmax0[id] = bbmid;

	  // these guys keep the bboxes in wgt0 and need to send those in wgt1...
	  if (my_count[1] > send_count_max) {
	    if (send_count_max == 0) {
	      send_count_max = my_count[1]; // allocate something
	      assert(send_buf_int8 == NULL);   send_buf_int8   = new int8[send_count_max];
	      assert(send_buf_double == NULL); send_buf_double = new double[send_count_max];
	      assert(send_buf_int == NULL);    send_buf_int    = new int[send_count_max*4];
	    }
	    else {
	      send_count_max = my_count[1];
	      delete[] send_buf_int8;   send_buf_int8   = new int8[send_count_max];
	      delete[] send_buf_double; send_buf_double = new double[send_count_max];
	      delete[] send_buf_int;    send_buf_int    = new int[send_count_max*4];
	    }
	  }

	  int i0 = 0;
	  int i1 = 0;
	  for (int ii = 0; ii < bboxVec.size(); ++ii) {
	    // note that we pack the send buf first, before copying down. bboxes get duplicated, it
	    // is not simply either or...
            if ((bboxVec[ii].jkmax[id] > bbmid)||(b_bbox_dupl)) {
	      send_buf_int8[i1]    = bboxVec[ii].type_and_index;
	      send_buf_double[i1]  = bboxVec[ii].density;
	      send_buf_int[i1*4  ] = bboxVec[ii].jkmin[0];
	      send_buf_int[i1*4+1] = bboxVec[ii].jkmin[1];
	      send_buf_int[i1*4+2] = bboxVec[ii].jkmax[0];
	      send_buf_int[i1*4+3] = bboxVec[ii].jkmax[1];
	      ++i1;
	    }

	    if ((bboxVec[ii].jkmin[id] < bbmid)||(b_bbox_dupl)) {
	      if (i0 != ii) {
		assert(i0 < ii);
		bboxVec[i0].type_and_index  = bboxVec[ii].type_and_index;
		bboxVec[i0].density         = bboxVec[ii].density;
		FOR_I2 bboxVec[i0].jkmin[i] = bboxVec[ii].jkmin[i];
		FOR_I2 bboxVec[i0].jkmax[i] = bboxVec[ii].jkmax[i];
	      }
	      else {
		assert(i0 == ii);
	      }
	      ++i0;
	    }
	  }
	  assert(i0 == my_count[0]);
	  assert(i1 == my_count[1]);
	  bboxVec.resize(i0);

	  // set send count...
	  // here we just send it all to one rank -- no effort to optimize load
	  // distribution. Should not affect end result, but may go through a peak
	  // in local memory usage at some point...
	  for (int rank = 0; rank < mpi_split_size; ++rank)
	    send_count[rank] = 0;
	  assert(mpi_mid+mpi_split_rank < mpi_split_size);
	  send_count[mpi_mid+mpi_split_rank] = i1;

	}
	else {

	  // see comment above...
	  bbmin0[id] = bbmid;

	  // these guys keep the bboxes in wgt1 and need to send those in wgt0...
	  if (my_count[0] > send_count_max) {
	    if (send_count_max == 0) {
	      send_count_max = my_count[0];
	      assert(send_buf_int8 == NULL);   send_buf_int8   = new int8[send_count_max];
	      assert(send_buf_double == NULL); send_buf_double = new double[send_count_max];
	      assert(send_buf_int == NULL);    send_buf_int    = new int[send_count_max*4];
	    }
	    else {
	      send_count_max = my_count[0];
	      delete[] send_buf_int8;   send_buf_int8   = new int8[send_count_max];
	      delete[] send_buf_double; send_buf_double = new double[send_count_max];
	      delete[] send_buf_int;    send_buf_int    = new int[send_count_max*4];
	    }
	  }

	  int i0 = 0;
	  int i1 = 0;
	  for (int ii = 0; ii < bboxVec.size(); ++ii) {
            if ((bboxVec[ii].jkmin[id] < bbmid)||(b_bbox_dupl)) {
	      send_buf_int8[i0]    = bboxVec[ii].type_and_index;
	      send_buf_double[i0]  = bboxVec[ii].density;
	      send_buf_int[i0*4  ] = bboxVec[ii].jkmin[0];
	      send_buf_int[i0*4+1] = bboxVec[ii].jkmin[1];
	      send_buf_int[i0*4+2] = bboxVec[ii].jkmax[0];
	      send_buf_int[i0*4+3] = bboxVec[ii].jkmax[1];
	      ++i0;
	    }

	    if ((bboxVec[ii].jkmax[id] > bbmid)||(b_bbox_dupl)) {
	      if (i1 != ii) {
		assert(i1 < ii);
		bboxVec[i1].type_and_index  = bboxVec[ii].type_and_index;
		bboxVec[i1].density         = bboxVec[ii].density;
		FOR_I2 bboxVec[i1].jkmin[i] = bboxVec[ii].jkmin[i];
		FOR_I2 bboxVec[i1].jkmax[i] = bboxVec[ii].jkmax[i];
	      }
	      else {
		assert(i1 == ii);
	      }
	      ++i1;
	    }
	  }
	  assert(i0 == my_count[0]);
	  assert(i1 == my_count[1]);
	  bboxVec.resize(i1);

	  for (int rank = 0; rank < mpi_split_size; ++rank)
	    send_count[rank] = 0;
	  assert(min(mpi_split_rank-mpi_mid,mpi_mid-1) < mpi_split_size);
	  send_count[min(mpi_split_rank-mpi_mid,mpi_mid-1)] = i0; // for last odd, send to same one as second last
	  // should check if this double messaging accumulates in the last rank of a given comm

	}

	// now do exchange and complete bboxVec's...

	send_disp[0] = 0;
	for (int rank = 1; rank < mpi_split_size; ++rank)
	  send_disp[rank] = send_count[rank-1] + send_disp[rank-1];

	MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_split_comm);

	recv_disp[0] = 0;
	for (int rank = 1; rank < mpi_split_size; ++rank)
	  recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
	const int recv_count_sum = recv_disp[mpi_split_size-1] + recv_count[mpi_split_size-1];

	if (recv_count_sum > recv_count_max) {
	  if (recv_count_max == 0) {
	    recv_count_max = recv_count_sum;
	    assert(recv_buf_int8 == NULL);   recv_buf_int8   = new int8[recv_count_sum];
	    assert(recv_buf_double == NULL); recv_buf_double = new double[recv_count_sum];
	    assert(recv_buf_int == NULL);    recv_buf_int    = new int[recv_count_sum*4];
	  }
	  else {
	    recv_count_max = recv_count_sum;
	    delete[] recv_buf_int8;   recv_buf_int8   = new int8[recv_count_sum];
	    delete[] recv_buf_double; recv_buf_double = new double[recv_count_sum];
	    delete[] recv_buf_int;    recv_buf_int    = new int[recv_count_sum*4];
	  }
	}

	MPI_Alltoallv(send_buf_int8,send_count,send_disp,MPI_INT8,
		      recv_buf_int8,recv_count,recv_disp,MPI_INT8,mpi_split_comm);

	MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		      recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_split_comm);

	for (int rank = 0; rank < mpi_split_size; ++rank) {
	  send_count[rank] *= 4;
	  send_disp[rank] *= 4;
	  recv_count[rank] *= 4;
	  recv_disp[rank] *= 4;
	}

	MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		      recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_split_comm);

	int ii = bboxVec.size();
	bboxVec.resize(ii+recv_count_sum);

	for (int irecv = 0; irecv < recv_count_sum; ++irecv) {
	  bboxVec[ii+irecv].type_and_index = recv_buf_int8[irecv];
	  bboxVec[ii+irecv].density        = recv_buf_double[irecv];
	  bboxVec[ii+irecv].jkmin[0]       = recv_buf_int[irecv*4  ];
	  bboxVec[ii+irecv].jkmin[1]       = recv_buf_int[irecv*4+1];
	  bboxVec[ii+irecv].jkmax[0]       = recv_buf_int[irecv*4+2];
	  bboxVec[ii+irecv].jkmax[1]       = recv_buf_int[irecv*4+3];
	}

	// and split the communicator...

	int mpi_key;
	if (mpi_split_rank < mpi_mid)
	  mpi_key = 0;
	else
	  mpi_key = 1;

	MPI_Comm mpi_split_comm_copy;
	MPI_Comm_dup(mpi_split_comm,&mpi_split_comm_copy);
	MPI_Comm_free(&mpi_split_comm);
	MPI_Comm_split(mpi_split_comm_copy, mpi_key, mpi_split_rank, &mpi_split_comm);
	MPI_Comm_free(&mpi_split_comm_copy);

	// and get the size again...

	MPI_Comm_size(mpi_split_comm,&mpi_split_size);

      }

      if (mpi_rank == 0)
	cout << "done" << endl;

      MPI_Comm_free(&mpi_split_comm);

      DELETE(send_buf_int8);
      DELETE(send_buf_double);
      DELETE(send_buf_int);

      DELETE(recv_buf_int8);
      DELETE(recv_buf_double);
      DELETE(recv_buf_int);

      delete[] send_count;
      delete[] send_disp;
      delete[] recv_count;
      delete[] recv_disp;

      // count the finally distributed bboxes...

      for (int it = 1; it < n_bbox_type; ++it)
	my_bbox_type_count[it] = 0;

      for (int ii = 0; ii < bboxVec.size(); ++ii) {
	const int it = int(bboxVec[ii].type_and_index>>48);
	assert((it >= 1)&&(it < n_bbox_type)); // recall zero reserved for error
	++my_bbox_type_count[it];
      }

      // now report...

      {
	// start with base mixedTris...
	int8 my_mem[2]; // use the first to count bbox's...
	my_mem[0] = sizeof(Surface::MixedTri)*my_bbox_type_count[1];
	my_mem[1] = bboxVec.size();
	int8 bbox_count_check = my_bbox_type_count[1];

	// mixedTris at various levels...
	for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
	  const int it = 1+level;
	  my_mem[0] += sizeof(Surface::MixedTri)*my_bbox_type_count[it];
	  bbox_count_check += my_bbox_type_count[it];
	}

	// mixedSpheres at various levels...
	for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
	  const int it = 1+HCP_LEVEL_MAX+level;
	  my_mem[0] += sizeof(Surface::MixedSphere)*my_bbox_type_count[it];
	  bbox_count_check += my_bbox_type_count[it];
	}

	// bloatedSurfaceTri's...
	for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
	  const int it = 1+2*HCP_LEVEL_MAX+level;
	  my_mem[0] += sizeof(Surface::BloatedSurfaceTri)*my_bbox_type_count[it];
	  bbox_count_check += my_bbox_type_count[it];
	}

	// bloatedTri's...
	for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
	  const int it = 1+3*HCP_LEVEL_MAX+level;
	  my_mem[0] += sizeof(Surface::BloatedTri)*my_bbox_type_count[it];
	  bbox_count_check += my_bbox_type_count[it];
	}

	// check...
	assert(bbox_count_check == bboxVec.size());

	int8 mem_sum[2];
	MPI_Reduce(my_mem,mem_sum,2,MPI_INT8,MPI_SUM,0,mpi_comm_internode);
	if (mpi_rank == 0)
	  cout << " > distributed bbox count: " << mem_sum[1] << ", memory: " <<
	    double(mem_sum[0])/1.0E+6 << " MB, or " <<
	    double(mem_sum[0])/1.0E+6/double(mpi_size_internode) << " MB/node" << endl;
      }

      // now sort the bboxVec into groups, then indices. This should be the order
      // we fill the various structures...

      sort(bboxVec.begin(),bboxVec.end());

      assert(bbmin == NULL); bbmin = new int[bboxVec.size()][2];
      assert(bbmax == NULL); bbmax = new int[bboxVec.size()][2];
      assert(indexVec.empty());
      indexVec.resize(bboxVec.size());

      for (int ii = 0; ii < bboxVec.size(); ++ii) {
	// confirm sort. The sort routine above should have sorted the
	// bboxVwec based on its "<" operator. Note that the less than operator
	// uniqueness assert fails, so it had to be commented out. probably
	// self comparison.
	if (ii > 0) assert(bboxVec[ii-1].type_and_index < bboxVec[ii].type_and_index);
	bbmin[ii][0] = bboxVec[ii].jkmin[0];
	bbmin[ii][1] = bboxVec[ii].jkmin[1];
	bbmax[ii][0] = bboxVec[ii].jkmax[0];
	bbmax[ii][1] = bboxVec[ii].jkmax[1];
	indexVec[ii] = ( bboxVec[ii].type_and_index & ((int8(1)<<48)-1) );
      }

      // resort the index. it is used to decide which refinement elements
      // to add. We could recompute them all, but this is probably faster.

      sort(indexVec.begin(),indexVec.end());

    } // if (mpi_rank_shared == 0)...

    // broadcast the bbox counts to all ranks of this node...

    MPI_Bcast(my_bbox_type_count,n_bbox_type,MPI_INT8,0,mpi_comm_shared);

    // recall the first is used for error checking...

    if (my_bbox_type_count[0] != 0)
      throw(0);

    // now allocate the various structures to do the ray lookups...

    if (mpi_rank == 0)
      cout << " > allocating..." << endl;

    // --------------------------------
    // mixedTris associated with surface tris...
    // --------------------------------
    Surface::MixedTri * mixedTriVec = NULL;
    Adt2dShm<int> * adt0 = NULL;
    if (my_bbox_type_count[1] > 0) { // we need a surface to know where to put the hcp points
      Surface::CTI_Mmap(mixedTriVec,my_bbox_type_count[1]);
      adt0 = new Adt2dShm<int>(my_bbox_type_count[1],bbmin,bbmax); // note that bbmin and bbmax valid on mpi_rank_shared==0 only
    }

    MPI_Bcast(bbmin0,2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(bbmax0,2,MPI_INT,0,mpi_comm_shared);

    assert(my_bbox_type_count[0] == 0);
    int8 offset = my_bbox_type_count[1];
    int level_max = 0;

    // for now, skip the tri and sphere builds, confirming they are all zero...

    // --------------------------------
    // mixedTris...
    // --------------------------------
    Surface::MixedTri * mixedTriPtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * mixedTriAdt[HCP_LEVEL_MAX];
    int mixedTriBbmin[HCP_LEVEL_MAX][2];
    int mixedTriBbmax[HCP_LEVEL_MAX][2];

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      // initialize...
      mixedTriPtr[level-1] = NULL;
      mixedTriAdt[level-1] = NULL;
      FOR_J2 mixedTriBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 mixedTriBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      const int it = 1+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
	level_max = max(level_max,level);
	Surface::CTI_Mmap(mixedTriPtr[level-1],nt);
	if (mpi_rank_shared == 0) {
	  for (int8 ii = 0; ii < nt; ++ii) {
	    FOR_J2 mixedTriBbmin[level-1][j] = min(mixedTriBbmin[level-1][j],bbmin[offset+ii][j]);
	    FOR_J2 mixedTriBbmax[level-1][j] = max(mixedTriBbmax[level-1][j],bbmax[offset+ii][j]);
	  }
	}
	mixedTriAdt[level-1] = new Adt2dShm<int>(nt,bbmin+offset,bbmax+offset); // valid on shared==0 only
	offset += nt;
      }
    }

    MPI_Bcast(mixedTriBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(mixedTriBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    // the raytracing algorithm needs to trace rays through all levels equal or
    // above the level of the ray. i.e. even if the geometry contains just one level 3
    // tri, we still need to trace all level 1,2 AND 3 lines through the tri...

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      // include bbox of all higher levels...
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 mixedTriBbmin[level-1][j] = min(mixedTriBbmin[level-1][j],mixedTriBbmin[level][j]);
	FOR_J2 mixedTriBbmax[level-1][j] = max(mixedTriBbmax[level-1][j],mixedTriBbmax[level][j]);
      }
      // and clip against the node's bbox...
      FOR_J2 mixedTriBbmin[level-1][j] = max(mixedTriBbmin[level-1][j],bbmin0[j]);
      FOR_J2 mixedTriBbmax[level-1][j] = min(mixedTriBbmax[level-1][j],bbmax0[j]);
    }

    // --------------------------------
    // mixedSpheres at various levels...
    // --------------------------------
    Surface::MixedSphere * mixedSpherePtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * mixedSphereAdt[HCP_LEVEL_MAX];
    int mixedSphereBbmin[HCP_LEVEL_MAX][2];
    int mixedSphereBbmax[HCP_LEVEL_MAX][2];

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      // initialize...
      mixedSpherePtr[level-1] = NULL;
      mixedSphereAdt[level-1] = NULL;
      FOR_J2 mixedSphereBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 mixedSphereBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      const int it = 1+HCP_LEVEL_MAX+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
	level_max = max(level_max,level);
	Surface::CTI_Mmap(mixedSpherePtr[level-1],nt);
	if (mpi_rank_shared == 0) {
	  for (int8 ii = 0; ii < nt; ++ii) {
	    FOR_J2 mixedSphereBbmin[level-1][j] = min(mixedSphereBbmin[level-1][j],bbmin[offset+ii][j]);
	    FOR_J2 mixedSphereBbmax[level-1][j] = max(mixedSphereBbmax[level-1][j],bbmax[offset+ii][j]);
	  }
	}
	mixedSphereAdt[level-1] = new Adt2dShm<int>(nt,bbmin+offset,bbmax+offset); // valid on shared==0 only
	offset += nt;
      }
    }

    MPI_Bcast(mixedSphereBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(mixedSphereBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 mixedSphereBbmin[level-1][j] = min(mixedSphereBbmin[level-1][j],mixedSphereBbmin[level][j]);
	FOR_J2 mixedSphereBbmax[level-1][j] = max(mixedSphereBbmax[level-1][j],mixedSphereBbmax[level][j]);
      }
      FOR_J2 mixedSphereBbmin[level-1][j] = max(mixedSphereBbmin[level-1][j],bbmin0[j]);
      FOR_J2 mixedSphereBbmax[level-1][j] = min(mixedSphereBbmax[level-1][j],bbmax0[j]);
    }

    // --------------------------------
    // bloatedSurfaceTris...
    // --------------------------------
    Surface::BloatedSurfaceTri * bloatedSurfaceTriPtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * bloatedSurfaceTriAdt[HCP_LEVEL_MAX];
    int bloatedSurfaceTriBbmin[HCP_LEVEL_MAX][2];
    int bloatedSurfaceTriBbmax[HCP_LEVEL_MAX][2];

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      bloatedSurfaceTriPtr[level-1] = NULL;
      bloatedSurfaceTriAdt[level-1] = NULL;
      FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      const int it = 1+2*HCP_LEVEL_MAX+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
	level_max = max(level_max,level);
	Surface::CTI_Mmap(bloatedSurfaceTriPtr[level-1],nt);
	if (mpi_rank_shared == 0) {
	  for (int8 ii = 0; ii < nt; ++ii) {
	    FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = min(bloatedSurfaceTriBbmin[level-1][j],bbmin[offset+ii][j]);
	    FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = max(bloatedSurfaceTriBbmax[level-1][j],bbmax[offset+ii][j]);
	  }
	}
	bloatedSurfaceTriAdt[level-1] = new Adt2dShm<int>(nt,bbmin+offset,bbmax+offset); // valid on shared==0 only
	offset += nt;
      }
    }

    MPI_Bcast(bloatedSurfaceTriBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(bloatedSurfaceTriBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = min(bloatedSurfaceTriBbmin[level-1][j],bloatedSurfaceTriBbmin[level][j]);
	FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = max(bloatedSurfaceTriBbmax[level-1][j],bloatedSurfaceTriBbmax[level][j]);
      }
      FOR_J2 bloatedSurfaceTriBbmin[level-1][j] = max(bloatedSurfaceTriBbmin[level-1][j],bbmin0[j]);
      FOR_J2 bloatedSurfaceTriBbmax[level-1][j] = min(bloatedSurfaceTriBbmax[level-1][j],bbmax0[j]);
    }

    // --------------------------------
    // bloatedTris...
    // --------------------------------
    Surface::BloatedTri * bloatedTriPtr[HCP_LEVEL_MAX];
    Adt2dShm<int> * bloatedTriAdt[HCP_LEVEL_MAX];
    int bloatedTriBbmin[HCP_LEVEL_MAX][2];
    int bloatedTriBbmax[HCP_LEVEL_MAX][2];

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      bloatedTriPtr[level-1] = NULL;
      bloatedTriAdt[level-1] = NULL;
      FOR_J2 bloatedTriBbmin[level-1][j] = (1<<HCP_BIT_MAX);
      FOR_J2 bloatedTriBbmax[level-1][j] = -(1<<HCP_BIT_MAX);
      const int it = 1+3*HCP_LEVEL_MAX+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
	level_max = max(level_max,level);
	Surface::CTI_Mmap(bloatedTriPtr[level-1],nt);
	if (mpi_rank_shared == 0) {
	  for (int8 ii = 0; ii < nt; ++ii) {
	    FOR_J2 bloatedTriBbmin[level-1][j] = min(bloatedTriBbmin[level-1][j],bbmin[offset+ii][j]);
	    FOR_J2 bloatedTriBbmax[level-1][j] = max(bloatedTriBbmax[level-1][j],bbmax[offset+ii][j]);
	  }
	}
	bloatedTriAdt[level-1] = new Adt2dShm<int>(nt,bbmin+offset,bbmax+offset); // valid on shared==0 only
	offset += nt;
      }
    }

    MPI_Bcast(bloatedTriBbmin,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);
    MPI_Bcast(bloatedTriBbmax,HCP_LEVEL_MAX*2,MPI_INT,0,mpi_comm_shared);

    for (int level = HCP_LEVEL_MAX; level >= 1; --level) {
      if (level < HCP_LEVEL_MAX) {
	FOR_J2 bloatedTriBbmin[level-1][j] = min(bloatedTriBbmin[level-1][j],bloatedTriBbmin[level][j]);
	FOR_J2 bloatedTriBbmax[level-1][j] = max(bloatedTriBbmax[level-1][j],bloatedTriBbmax[level][j]);
      }
      FOR_J2 bloatedTriBbmin[level-1][j] = max(bloatedTriBbmin[level-1][j],bbmin0[j]);
      FOR_J2 bloatedTriBbmax[level-1][j] = min(bloatedTriBbmax[level-1][j],bbmax0[j]);
    }

    // --------------------------------------------------------------------------
    // memory is now allocated, so cycle through on mpi_shared_rank == 0 and
    // initialize elements...
    // --------------------------------------------------------------------------

    if (mpi_rank_shared == 0) {

      delete[] bbmin; bbmin = NULL;
      delete[] bbmax; bbmax = NULL;

      // we need a disp structure to pack everything...

      int8 my_bbox_type_disp[n_bbox_type];
      for (int it = 0; it < n_bbox_type; ++it)
	my_bbox_type_disp[it] = 0;

      int8 bbox_count = 0;
      int8 ii = 0; // index in indexVec...

      // primary mixed tris...

      for (int ist = 0; ist < surface->nst; ++ist) {
	// all tris participate in the surface limiting...
	const int8 index = bbox_count++;
	if ((ii < indexVec.size())&&(index == indexVec[ii])) {
	  // we own this one...
	  ++ii; // next indexVec index
	  const int it = 1; // this is type 1...
	  const int imt = my_bbox_type_disp[it]++;
	  mixedTriVec[imt].init(surface->xp[surface->spost[ist][0]],
				surface->xp[surface->spost[ist][1]],
				surface->xp[surface->spost[ist][2]],
				hcp_x0,dxp);
	}
      }

      // windows...

      for (int iw = 0; iw < hcpWindowDataVec.size(); ++iw) {
	const HcpWindowData * const window = hcpWindowDataVec[iw];
	if (window->type == FAZONE_HCP_WINDOW) {
	  surface->clearZoneFlags();
	  istringstream iss(window->zones);
	  string zonename;
	  bool found = false;
          while (std::getline(iss,zonename,',')) {
            COUT2("processing zone: " << zonename);
            if (zonename == "ALL") {
              surface->setAllZoneFlags();
              found = true;
              break;  // no need to process other zones if this is used
            }
	    else {
              try {
                surface->setZoneFlag(zonename);
                found = true;
              }
	      catch ( ...) {
                COUT1(" > unable to find zone: " << zonename);
              }
            }
          }
	  if (!found) continue;
	  for (int ist = 0; ist < surface->nst; ++ist) {
	    const int izone = surface->znost[ist];
	    if ((izone >= 0)&&(surface->getZoneFlag(izone))) {
	      double delta = 0.0;
	      for (int this_level = window->level; this_level >= 1; --this_level) {
		const double this_delta = hcp_delta*double(window->nlayers)/double(1<<this_level);
		delta += this_delta;
		const int8 index = bbox_count++;
		if ((ii < indexVec.size())&&(index == indexVec[ii])) {
		  // we own this one...
		  ++ii; // next indexVec index
		  const int it = 1+2*HCP_LEVEL_MAX+this_level;
		  const int ibst = my_bbox_type_disp[it]++;
		  bloatedSurfaceTriPtr[this_level-1][ibst].init(ist,delta);
		}
	      }
	    }
	  }
	}
	else if (window->type == SPHERE_HCP_WINDOW) {
	  int min_level = window->level;
	  if (window->nlayers >= 1)
	    min_level = 1;
	  // if the user has specified nlayers, we add a sphere for each layer...
	  double r = window->geom_data[3];
	  for (int this_level = window->level; this_level >= min_level; --this_level) {
	    // after the first level, increase the radius...
	    if (this_level < window->level) {
	      const double dr = hcp_delta*double(window->nlayers)/double(1<<this_level);
	      r += dr;
	    }
	    const int8 index = bbox_count++;
	    if ((ii < indexVec.size())&&(index == indexVec[ii])) {
	      // we own this one...
	      ++ii;
	      const int it = 1+HCP_LEVEL_MAX+this_level;
	      const int ims = my_bbox_type_disp[it]++;
	      mixedSpherePtr[this_level-1][ims].init(window->geom_data,r,hcp_x0,dxp);
	    }
	  }
	}
	else if ((window->type == BOX_HCP_WINDOW)||
		 (window->type == TCONE_HCP_WINDOW)||
		 (window->type == ANNULAR_TCONE_HCP_WINDOW)||
     (window->type == PRISM_HCP_WINDOW)||
                 (window->type == SBIN_HCP_WINDOW)) {
	  vector<TriStuff::Tri> triVec;
	  switch (window->type) {
	  case BOX_HCP_WINDOW:
	    TriStuff::initBox(triVec,
			      window->geom_data[0],window->geom_data[1],
			      window->geom_data[2],window->geom_data[3],
			      window->geom_data[4],window->geom_data[5]);
	    assert(triVec.size() == 12);
	    break;
	  case TCONE_HCP_WINDOW:
	    TriStuff::initTcone(triVec,
				window->geom_data[0],window->geom_data[1],
				window->geom_data[2],window->geom_data[3],
				window->geom_data[4],window->geom_data[5],
				window->geom_data[6],window->geom_data[7]);
	    break;
	  case ANNULAR_TCONE_HCP_WINDOW:
	    TriStuff::initAnnularTcone(triVec,
				       window->geom_data[0],window->geom_data[1],
				       window->geom_data[2],window->geom_data[3],
				       window->geom_data[4],window->geom_data[5],
				       window->geom_data[6],window->geom_data[7],
				       window->geom_data[8],window->geom_data[9]);
	    break;
    case PRISM_HCP_WINDOW:
      TriStuff::initPrism(triVec,
      window->geom_data[0],window->geom_data[1],
      window->geom_data[2],window->geom_data[3],
      window->geom_data[4],window->geom_data[5],
      window->geom_data[6],window->geom_data[7],
      window->geom_data[8],window->geom_data[9],
      window->geom_data[10],window->geom_data[11],
      window->geom_data[12]);
      break;
	  case SBIN_HCP_WINDOW:
	    TriStuff::initSbin(triVec,window->sbin_filename);
	    break;
	  default:
	    assert(0); // inconsistency
	  }
	  // process triVec...
	  for (int itri = 0; itri < triVec.size(); ++itri) {
	    const int8 index = bbox_count++;
	    if ((ii < indexVec.size())&&(index == indexVec[ii])) {
	      // we own this one...
	      ++ii;
	      const int it = 1+window->level;
	      const int imt = my_bbox_type_disp[it]++;
	      mixedTriPtr[window->level-1][imt].init(triVec[itri].x0,triVec[itri].x1,triVec[itri].x2,hcp_x0,dxp);
	    }
	  }
	  if (window->nlayers >= 1) {
	    double r = 0.0;
	    for (int this_level = window->level-1; this_level >= 1; --this_level) {
	      const double dr = hcp_delta*double(window->nlayers)/double(1<<this_level);
	      r += dr;
	      for (int itri = 0; itri < triVec.size(); ++itri) {
		const int8 index = bbox_count++;
		if ((ii < indexVec.size())&&(index == indexVec[ii])) {
		  // we own this one...
		  ++ii;
		  const int it = 1+3*HCP_LEVEL_MAX+this_level;
		  const int ibt = my_bbox_type_disp[it]++;
		  bloatedTriPtr[this_level-1][ibt].init(triVec[itri].x0,triVec[itri].x1,triVec[itri].x2,r);
		}
	      }
	    }
	  }
	}
	else {
	  cout << "XXXXXXXXX: unrecognized window type: " << window->type << endl;
	  assert(0);
	}
      }

      // check that we got through the index...
      assert(ii == indexVec.size());
      // and that the disps were fully advanced...
      for (int it = 0; it < n_bbox_type; ++it) {
	assert(my_bbox_type_disp[it] == my_bbox_type_count[it]);
      }

    }
    MPI_Barrier(mpi_comm_shared);

    // level_max may be different on different nodes. Here we reduce and report the
    // length scales. We want to leave level_max at its local node value because it
    // does not have to trace levels where it has no bboxes...
    {
      int level_max_max;
      MPI_Reduce(&level_max,&level_max_max,1,MPI_INT,MPI_MAX,0,mpi_comm);
      if (mpi_rank == 0) {
	cout << " > level_max: " << level_max_max << endl;
	for (int level = 0; level <= level_max_max; ++level)
	  cout << " > level: " << level << " delta: " << hcp_delta/double(1<<level) << endl;
      }
    }

    // =================================================================================
    // TODO: should split into a second function here so it can be called recursively...
    // =================================================================================

    // Ok -- we have the the mixed tris's in mixedTriVec (shared mem) and
    // we have a shared mem adt2d that can lookup ray intersections fast. Now
    // loop on ray limits for each level...

    int cycle = mpi_rank_shared; // used for sequence-based parallelization on the node...
    vector<Surface::XpIntersection> xpIntersectionVec;

    // generate the points into vertexVec, then copy into the xv,deltav buffer below...
    // recall it was passed into this routine -- should be empty...

    assert(vertexVec.empty());

    // for diagnostics...

    int8 * my_vv_count = new int8[HCP_LEVEL_MAX+1];
    for (int level = 0; level <= HCP_LEVEL_MAX; ++level) my_vv_count[level] = 0;
    const double wtime0 = MPI_Wtime();

    // debugging...

    int j_debug = -1; // to avoid compiler warnings
    bool level_0_j_shift = false;
    bool level_0_k_shift = false;
    int j0_range = 0;
    int k0_range = 0;
    for (int level = 0; level <= level_max; ++level) {

      // as a first step, determine the bbox for this level...

      int bbminL[2] = { (1<<HCP_BIT_MAX), (1<<HCP_BIT_MAX) };
      int bbmaxL[2] = { -(1<<HCP_BIT_MAX), -(1<<HCP_BIT_MAX) };

      if (level == 0) {
        // the level 0 case gets the full bounding box...
        FOR_J2 bbminL[j] = bbmin0[j];
        FOR_J2 bbmaxL[j] = bbmax0[j];
      }
      else {
        // otherwise, the bbox that includes all refinement objects at level and above...
        FOR_J2 bbminL[j] = min( mixedSphereBbmin[level-1][j],min( mixedTriBbmin[level-1][j],min( bloatedSurfaceTriBbmin[level-1][j],bloatedTriBbmin[level-1][j] ) ) );
        FOR_J2 bbmaxL[j] = max( mixedSphereBbmax[level-1][j],max( mixedTriBbmax[level-1][j],max( bloatedSurfaceTriBbmax[level-1][j],bloatedTriBbmax[level-1][j] ) ) );
      }

      // if this is "mesh inspector" mode, limit the bounding box accordingly...

      if (b_mesh_inspector) {
        // centroid of mesh inspector sphere is in x_mi[3]...

        cout << " current bbminL: " << bbminL[0] << " " << bbminL[1] << endl;
        cout << " current bbmaxL: " << bbmaxL[0] << " " << bbmaxL[1] << endl;

        int bbmin_mi[2];
        FOR_J2 {
          bbmin_mi[j] = int( (x_mi[j+1] - r_mi - hcp_x0[j+1])*dxp ); // y = j, z == k
          if (bbmin_mi[j]%2 == 0) bbmin_mi[j] += 1;
        }

        int bbmax_mi[2];
        FOR_J2 {
          bbmax_mi[j] = int( (x_mi[j+1] + r_mi - hcp_x0[j+1])*dxp ); // y = j, z == k
          if (bbmax_mi[j]%2 == 0) bbmax_mi[j] += 1;
        }

        FOR_J2 bbminL[j] = max(bbminL[j],bbmin_mi[j]);
        FOR_J2 bbmaxL[j] = min(bbmaxL[j],bbmax_mi[j]);
      }

      // now loop rays and start building points...

      const int djk = (1<<(Nbase-level));
      int jmin = ( bbminL[0] < 0 ? bbminL[0]-(bbminL[0]%djk) : bbminL[0]-(bbminL[0]%djk)+djk );  assert(jmin > bbminL[0]);
      int jmax = ( bbmaxL[0] < 0 ? bbmaxL[0]-(bbmaxL[0]%djk)-djk : bbmaxL[0]-(bbmaxL[0]%djk) );  assert(jmax <= bbmaxL[0]); // added == because zero is possible
      int kmin = ( bbminL[1] < 0 ? bbminL[1]-(bbminL[1]%djk) : bbminL[1]-(bbminL[1]%djk)+djk );  assert(kmin > bbminL[1]);
      int kmax = ( bbmaxL[1] < 0 ? bbmaxL[1]-(bbmaxL[1]%djk)-djk : bbmaxL[1]-(bbmaxL[1]%djk) );  assert(kmax <= bbmaxL[1]);

      if (false && forceCart && two2one) {
        // offset adjustment relative to bbox; only do if odd number of points relative to global bbox...?
        //TODO see if we need to protect against double/floor behavior of this division
        if ( (((jmax-jmin)/djk) & 1) == 1) {
          jmin += int(floor(double(djk)*0.5));
          jmax += int(floor(double(djk)*0.5));
        }
        if ( (((kmax-kmin)/djk) & 1) == 1) {
          kmin += int(floor(double(djk)*0.5));
          kmax += int(floor(double(djk)*0.5));
        }
      }

      if ( b_bbox_dupl) {

        // we're going to round-robin the rays, so we need to get the global extents of the search space ..
        // everyone has the same bbox information at this stage ...

        int jmin_global, jmax_global, kmin_global, kmax_global;
        MPI_Allreduce(&jmin,&jmin_global,1,MPI_INT,MPI_MIN,mpi_comm);
        MPI_Allreduce(&kmin,&kmin_global,1,MPI_INT,MPI_MIN,mpi_comm);
        MPI_Allreduce(&jmax,&jmax_global,1,MPI_INT,MPI_MAX,mpi_comm);
        MPI_Allreduce(&kmax,&kmax_global,1,MPI_INT,MPI_MAX,mpi_comm);

        jmin = jmin_global;
        jmax = jmax_global;
        kmin = kmin_global;
        kmax = kmax_global;

      }

      int ray_count = 0;

      if (checkParam("YMIN_DEBUG")) {
        if (level == 0) j_debug = jmin;
        jmin = jmax = j_debug;
      }
      if (checkParam("YMID_DEBUG")) {
        jmin = jmax = 0;
      }
      if (checkParam("ZMID_DEBUG")) {
        kmin = kmax = 0;
      }

      // checking...
      if (mpi_rank == 0) cout << " > working on level " << level;
      int jcheck = jmin;
      int djcheck = (jmax-jmin)/8;

      for (int j = jmin; j <= jmax; j += djk) {

        // reporting...
        if ((mpi_rank == 0)&&(j >= jcheck)) {
          cout << ".";
          cout.flush();
          jcheck += djcheck;
        }

        for (int k = kmin; k <= kmax; k += djk) {

          if ((level == 0)||(j%(2*djk) != 0)||(k%(2*djk) != 0)||forceCart) {
            // ====================================================================
            // the cycle int is used to decide which rank takes this (j,k) ray...
            // it gets updated below...
            // ====================================================================

            bool b_own_ray;
            if ( b_bbox_dupl) {
              b_own_ray = (ray_count%mpi_size == mpi_rank);
            } else {
              b_own_ray = (cycle == 0);
            }

            if ( b_own_ray) {
              assert(xpIntersectionVec.empty());
              // add level0 intersections first...
              surface->addXpIntersections(xpIntersectionVec,j,k,adt0,mixedTriVec,0);
              // only continue if there are level0 intersections...
              if (!xpIntersectionVec.empty()) {
                // add intersections for all levels >= level...
                for (int sphere_level = max(level,1); sphere_level <= level_max; ++sphere_level) {
                  if (mixedSpherePtr[sphere_level-1] != NULL) {
                    assert(mixedSphereAdt[sphere_level-1] != NULL);
                    surface->addXpIntersections(xpIntersectionVec,j,k,mixedSphereAdt[sphere_level-1],mixedSpherePtr[sphere_level-1],sphere_level,dxp);
                  }
                }
                for (int tri_level = max(level,1); tri_level <= level_max; ++tri_level) {
                  if (mixedTriPtr[tri_level-1] != NULL) {
                    assert(mixedTriAdt[tri_level-1] != NULL);
                    surface->addXpIntersections(xpIntersectionVec,j,k,mixedTriAdt[tri_level-1],mixedTriPtr[tri_level-1],tri_level);
                  }
                }
                for (int bst_level = max(level,1); bst_level <= level_max; ++bst_level) {
                  if (bloatedSurfaceTriPtr[bst_level-1] != NULL) {
                    assert(bloatedSurfaceTriAdt[bst_level-1] != NULL);
                    surface->addXpIntersections(xpIntersectionVec,j,k,bloatedSurfaceTriAdt[bst_level-1],bloatedSurfaceTriPtr[bst_level-1],bst_level,hcp_x0,dxp);
                  }
                }
                for (int bt_level = max(level,1); bt_level <= level_max; ++bt_level) {
                  if (bloatedTriPtr[bt_level-1] != NULL) {
                    assert(bloatedTriAdt[bt_level-1] != NULL);
                    surface->addXpIntersections(xpIntersectionVec,j,k,bloatedTriAdt[bt_level-1],bloatedTriPtr[bt_level-1],bt_level,hcp_x0,dxp);
                  }
                }
                // sort along xp...
                sort(xpIntersectionVec.begin(),xpIntersectionVec.end());
                // process intersections...
                int level_count[level_max+1];
                for (int ilevel = 0; ilevel <= level_max; ++ilevel) level_count[ilevel] = 0;

                // for cartesian points need to determine whether we shift globally or not based on entire surface extent, so process first and last intersections
                //TODO how does this do with angled boundaries? some rays offset and others not....
                bool cart_shift = false;
                if (forceCart) {
                  bool first = false;
                  int i0,i1;
                  for (int ii = 0,limit=xpIntersectionVec.size(); ii < limit; ++ii) {
                    if (!first && (xpIntersectionVec[ii].level == 0) && (xpIntersectionVec[ii].sign > 0)) {
                      i0 = int( (xpIntersectionVec[ii].xp - hcp_x0[0] + offset_factor*double(j-k)*one_o_dxp*0.5*one_o_hcp_packing_factor)*(dxp*hcp_packing_factor) );
                      first = true;
                    }
                    else if ((xpIntersectionVec[ii].level == 0) && (xpIntersectionVec[ii].sign < 0)) {
                      i1 = int( (xpIntersectionVec[ii].xp - hcp_x0[0] + offset_factor*double(j-k)*one_o_dxp*0.5*one_o_hcp_packing_factor)*(dxp*hcp_packing_factor) );
                    }
                  }
                  const int di = (1<<(Nbase-level));  // make shift relative to this level and entire surface extents along ray
                  const int imin = ( i0 < 0 ? i0-(i0%di) : i0-(i0%di)+di );  assert(imin > i0);
                  const int imax = ( i1 < 0 ? i1-(i1%di)-di : i1-(i1%di) );  assert(imax < i1);
                  assert(imin%di == 0);
                  assert(imax%di == 0);

                  if ( (((imax-imin)/djk) & 1) == 1) cart_shift = true;
                }

                int i1 = 0; // doesn't matter -- not used in below logic until after first time through
                for (int ii = 0,limit=xpIntersectionVec.size(); ii < limit; ++ii) {
                  const double xp_end = xpIntersectionVec[ii].xp;
                  const int i0 = i1;
                  // i1 = int( ( (xp_end - hcp_x0[0] + offset_factor*double(j-k)/(dxp*2.0*hcp_packing_factor))*(dxp*hcp_packing_factor) ) );
                  i1 = int( (xp_end - hcp_x0[0] + offset_factor*double(j-k)*one_o_dxp*0.5*one_o_hcp_packing_factor)*(dxp*hcp_packing_factor) );
                  if (i1%2 == 0) i1 += 1;
                  // add points in this gap as appropriate...
                  // to start, find the highest level where we have a positive count...
                  int ilevel;
                  for (ilevel = level_max; ilevel > 0; --ilevel) {
                    if (level_count[ilevel] > 0) break;
                  }

                  if ((level_count[0] > 0)&&(ilevel >= level)) {
                    // it is possible that with extreme optimization, the fact that xpIntersectionVec[ii].xp are sorted still
                    // doesn't ensure monotonic i0,i1, etc...
                    if (i1 < i0) i1 = i0;
                    // now build the imin/imax values for this level...
                    const int di = (1<<(Nbase-ilevel));
                    const int imin = ( i0 < 0 ? i0-(i0%di) : i0-(i0%di)+di );  assert(imin > i0);
                    const int imax = ( i1 < 0 ? i1-(i1%di)-di : i1-(i1%di) );  assert(imax < i1);
                    assert(imin%di == 0);
                    assert(imax%di == 0);

                    // if ( (((imax-imin)/djk) & 1) == 1) shift = true;

                    int count = 0;
                    for (int i = imin; i <= imax; i += di) {
                      double xp[3];
                      // xp[0] = hcp_x0[0] - offset_factor*double(j-k)/(dxp*2.0*hcp_packing_factor) + double(i)/(dxp*hcp_packing_factor);
                      xp[0] = hcp_x0[0] - offset_factor*double(j-k)*one_o_dxp*0.5*one_o_hcp_packing_factor + double(i)*one_o_dxp*one_o_hcp_packing_factor;
                      xp[1] = hcp_x0[1] + double(j)*one_o_dxp;
                      xp[2] = hcp_x0[2] + double(k)*one_o_dxp;

                      // if (forceCart && two2one && cart_shift) {
                      if (forceCart && two2one) {
                        // j,k offset already handled in ray origination routine
                        for (int index=0; index<1; ++index) xp[index] += floor(double(djk)*0.5)*one_o_dxp*one_o_hcp_packing_factor;
                      }
                      // skip if this if outside the mesh_inspector sphere...
                      if ((b_mesh_inspector)&&(DIST2(xp,x_mi) > r_mi*r_mi)) continue;

                      if (forceCart) {
                        // don't add this point if window criteria not obeyed
                        if (ilevel > level) continue;
                      }

                      ++count;
                      vertexVec.push_back(HcpVertex(xp,ilevel));
                      assert((ilevel >= 0)&&(ilevel <= HCP_LEVEL_MAX));
                      my_vv_count[ilevel] += 1; // and level-based count
                    }
                  }
                  // and update the level count...
                  assert(xpIntersectionVec[ii].level <= level_max);
                  level_count[xpIntersectionVec[ii].level] += xpIntersectionVec[ii].sign;
                }
                // check that level_count has been returned to 0...
                for (int ilevel = 0; ilevel <= level_max; ++ilevel) {
                  if (!(level_count[ilevel] == 0))
                  cout << "warning: got level_count[" << ilevel << "] = " << level_count[ilevel] << " for j,k: " << j << " " << k << endl;
                  assert(level_count[ilevel] == 0);
                }
                // and clear the vec for the next ray...
                xpIntersectionVec.clear();
              }
            }

            // update the cycle int...
            ++cycle;
            if (cycle == mpi_size_shared)
            cycle = 0;

            ++ray_count;
            if ( ray_count == mpi_size) // just to prevent overflow of the int...
            ray_count = 0;
          }
        }
      }

      if (mpi_rank == 0) cout << "OK" << endl;

    }

    double rank_time = MPI_Wtime() - wtime0;
    dumpNodeAvgReport(rank_time,"point generation timings");

    // clean up...

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      // initialize...
      const int it = 1+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
        assert(mixedTriPtr[level-1] != NULL);
        Surface::CTI_Munmap(mixedTriPtr[level-1],nt);
        assert(mixedTriAdt[level-1] != NULL);
        delete mixedTriAdt[level-1];
      }
      else {
        assert(mixedTriPtr[level-1] == NULL);
        assert(mixedTriAdt[level-1] == NULL);
      }
    }

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      // initialize...
      const int it = 1+HCP_LEVEL_MAX+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
        assert(mixedSpherePtr[level-1] != NULL);
        Surface::CTI_Munmap(mixedSpherePtr[level-1],nt);
        assert(mixedSphereAdt[level-1] != NULL);
        delete mixedSphereAdt[level-1];
      }
      else {
        assert(mixedSpherePtr[level-1] == NULL);
        assert(mixedSphereAdt[level-1] == NULL);
      }
    }

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      // initialize...
      const int it = 1+2*HCP_LEVEL_MAX+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
        assert(bloatedSurfaceTriPtr[level-1] != NULL);
        Surface::CTI_Munmap(bloatedSurfaceTriPtr[level-1],nt);
        assert(bloatedSurfaceTriAdt[level-1] != NULL);
        delete bloatedSurfaceTriAdt[level-1];
      }
      else {
        assert(bloatedSurfaceTriPtr[level-1] == NULL);
        assert(bloatedSurfaceTriAdt[level-1] == NULL);
      }
    }

    for (int level = 1; level <= HCP_LEVEL_MAX; ++level) {
      // initialize...
      const int it = 1+3*HCP_LEVEL_MAX+level;
      const int8 nt = my_bbox_type_count[it]; // number of this type
      if (nt > 0) {
        assert(bloatedTriPtr[level-1] != NULL);
        Surface::CTI_Munmap(bloatedTriPtr[level-1],nt);
        assert(bloatedTriAdt[level-1] != NULL);
        delete bloatedTriAdt[level-1];
      }
      else {
        assert(bloatedTriPtr[level-1] == NULL);
        assert(bloatedTriAdt[level-1] == NULL);
      }
    }

    // and clean the root-level stuff...

    if (my_bbox_type_count[1] > 0) {
      Surface::CTI_Munmap(mixedTriVec,my_bbox_type_count[1]);
      delete adt0;
    }

    // =======================================
    // proximity check for periodicity...
    // for now we just hack it. In the future we need to
    // actually eliminate points close to periodic boundaries.
    // =======================================

    if (Param * param = getParam("PERIODIC_CYL_X_HACK")) {
      // -----------------------------------------------------
      // PERIODIC_CYL_X_HACK theta_min theta_max
      // -----------------------------------------------------
      const double theta_min_degrees = param->getDouble(0);
      const double theta_max_degrees = param->getDouble(1);
      if (mpi_rank == 0)
	cout << " > PERIODIC_CYL_X_HACK " << theta_min_degrees << " " << theta_max_degrees << endl;
      int np_final = 0;
      for (int iv = 0; iv < vertexVec.size(); ++iv) {
	const double theta = atan2(vertexVec[iv].x[2],vertexVec[iv].x[1]);
	const double dtheta = min(fabs(theta-theta_min_degrees*M_PI/180.0),fabs(theta_max_degrees*M_PI/180.0-theta));
	const double r = sqrt(vertexVec[iv].x[1]*vertexVec[iv].x[1] + vertexVec[iv].x[2]*vertexVec[iv].x[2]);
	// if the point is within 1/4 of the delta, then get rid of it...
	if ( r*dtheta > 0.25*hcp_delta/double(1<<vertexVec[iv].level) ) {
	  // keep this one...
	  if (np_final != iv) {
	    vertexVec[np_final].x[0]  = vertexVec[iv].x[0];
	    vertexVec[np_final].x[1]  = vertexVec[iv].x[1];
	    vertexVec[np_final].x[2]  = vertexVec[iv].x[2];
	    vertexVec[np_final].level = vertexVec[iv].level;
	  }
	  ++np_final;
	}
      }
      int my_elim_count = vertexVec.size()-np_final;
      int elim_count;
      MPI_Reduce(&my_elim_count,&elim_count,1,MPI_INT,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0)
	cout << " >> points eliminated by periodic proximity check: " << elim_count << endl;
      vertexVec.resize(np_final);
    }

    // stats...

    dumpNodeSumReport((double)vertexVec.size(),"points per node: NP");

    int8 * vv_count = NULL;
    if (mpi_rank == 0)
      vv_count = new int8[HCP_LEVEL_MAX+1];
    MPI_Reduce(my_vv_count,vv_count,HCP_LEVEL_MAX+1,MPI_INT8,MPI_SUM,0,mpi_comm);
    delete[] my_vv_count;
    if (mpi_rank == 0) {
      int8 np_global = 0;
      for (int level = 0; level <= HCP_LEVEL_MAX; ++level)
	np_global += vv_count[level];
      cout << " > hcp point count: " << np_global << endl;
      cout << " > hcp point distribution per level:" << endl;
      for (int level = 0; level <= HCP_LEVEL_MAX; ++level) {
	if (vv_count[level] > 0)
	  cout << " > level: " << level << " count: " << vv_count[level] << " (" << double(vv_count[level])/double(np_global)*100.0 << "%)" << endl;
      }
      delete[] vv_count;
    }

    /*
      int8 np = vertexVec.size();
      int8 np_global;
      MPI_Reduce(&np,&np_global,1,MPI_INT8,MPI_SUM,0,mpi_comm);
      // stats...
      {
      assert(vertexVec.size() == debug_count[1]);
      int8 np_node;
      MPI_Reduce(&np,&np_node,1,MPI_INT8,MPI_SUM,0,mpi_comm_shared);
      int8 np_node_max;
      if (mpi_rank_shared == 0)
      MPI_Reduce(&np_node,&np_node_max,1,MPI_INT8,MPI_MAX,0,mpi_comm_internode);
      if (mpi_rank == 0)
      cout << " > hcp point count: " << np_global << ", node imbalance (max/avg): " <<
      double(np_node_max)/double(np_global)*double(mpi_size_internode) << endl;
      }
    */

  }

  void writeHcpPoints(vector<HcpVertex>& vertexVec) {

    FOR_PARAM_MATCHING("WRITE_HCP_POINTS") {

      const int np = vertexVec.size();

      bool bIsPlane = false;  // turn into an enum
      bool bIsAll = false;

      double xplane[3] = { 0.0, 0.0, 0.0 };
      double nplane[3] = { 0.0, 1.0, 0.0 };
      string filename = "points";  // filetype suffix appended during parse
      int format=0;  // default to tecplot...

      int iarg = 0;
      while (iarg < param->size()) {
	string token = param->getString(iarg++);
	if (token == "GEOM") {
	  string geom = param->getString(iarg++);
	  if (geom == "PLANE") {
	    bIsPlane = true;
	    FOR_I3 xplane[i] = param->getDouble(iarg++);
	    FOR_I3 nplane[i] = param->getDouble(iarg++);
	  }
	  else if (geom == "ALL") {
	    bIsAll = true;
	  }
	  else {
	    CWARN("unrecognized GEOM \"" << geom << "\"; skipping");
	  }
	}
	else if (token == "NAME") {
	  filename = param->getString(iarg++);
	}
	else if (token == "FORMAT") {
	  string filetype = param->getString(iarg++);
	  if (filetype == "TECPLOT") {
	    format=0;
	    filename.append(".dat");
	  }
	  else if (filetype == "PBIN" || filetype == "BIN") {
	    format = 1;
	    filename.append(".pbin");
	  }
	  else {
	    CWARN("unrecognized filetype \"" << filetype << "\"; defaulting to Tecplot (ascii)");
	    filename.append(".dat");
	  }
	}
	else {
	  CWARN("unrecognized token \"" << token << "\"");
	}
      }

      // flag points to be written
      int * p_flag = new int[np];
      int np_flagged = 0;

      if (bIsPlane) {
	for (int ip = 0; ip < np; ++ip) {
	  const double level = double(vertexVec[ip].level);
	  const double r = hcp_delta/pow(2.0,level)*1.5*1.0/3.0;
	  // if the distance of this point to the plane is less than r, then
	  // write it...
	  const double dx[3] = DIFF(vertexVec[ip].x,xplane);
	  const double dist = DOT_PRODUCT(dx,nplane);
	  if (fabs(dist) <= r) {
	    ++np_flagged;
	    p_flag[ip] = 1;
	  } else {
	    p_flag[ip] = 0;
	  }
	}
      }
      else if (bIsAll) {
	for (int ip = 0; ip < np; ++ip) p_flag[ip] = 1;
	np_flagged = np;
      }
      else {
	for (int ip = 0; ip < np; ++ip) p_flag[ip] = 0;
      }

      int8 my_np = np_flagged;
      int8 np_flagged_global;
      MPI_Allreduce(&my_np,&np_flagged_global,1,MPI_INT8,MPI_SUM,mpi_comm);

      if (format == 0) {
	COUT1("writing HCP points to Tecplot (ascii) file \"" << filename << "\"");
	COUT2(" > total points: " << np_flagged_global);

	FILE * fp;
	if ( mpi_rank == 0 ) {
	  fp = fopen(filename.c_str(),"w");
	  assert(fp != NULL);
	  fprintf(fp,"TITLE = \"plane\"\n");
	  fprintf(fp,"VARIABLES = \"X\"\n");
	  fprintf(fp,"\"Y\"\n");
	  fprintf(fp,"\"Z\"\n");
	  fprintf(fp,"\"DELTA\"\n");
	}
	else {
	  int dummy;
	  MPI_Status status;
	  MPI_Recv(&dummy,1,MPI_INT,mpi_rank-1,1234,mpi_comm,&status);
	  fp = fopen(filename.c_str(),"a");
	  assert(fp != NULL);
	}

	for (int ip = 0; ip < np; ++ip) {
	  if (p_flag[ip] == 1) {
	    const double level = double(vertexVec[ip].level);
	    const double delta = hcp_delta/pow(2.0,level);
	    fprintf(fp,"%18.15le %18.15le %18.15le %18.15le\n",
		    vertexVec[ip].x[0],
		    vertexVec[ip].x[1],
		    vertexVec[ip].x[2],
		    delta);
	  }
	}
	fclose(fp);

	if ( mpi_rank < mpi_size-1 ) {
	  int dummy = 1;
	  MPI_Send(&dummy,1,MPI_INT,mpi_rank+1,1234,mpi_comm);
	}

	MPI_Barrier(mpi_comm);

      }
      else if (format == 1) {

	COUT1("writing HCP points to pbin file \"" << filename << "\"");
	COUT2(" > total points: " << np_flagged_global);

	char dummy[128]; assert(filename.length() < 128);
	sprintf(dummy,"%s",filename.c_str());
	MPI_File_delete(dummy,MPI_INFO_NULL);

	MPI_File fh;
	MPI_File_open(mpi_comm,dummy,MPI_MODE_WRONLY|MPI_MODE_CREATE,MPI_INFO_NULL,&fh);

	const int POINTS_IO_VERSION_ = 2;
	const int POINTS_IO_MAGIC_NUMBER_ = 1235813;
	if (mpi_rank == 0) {
	  int8 ibuf[4] = { POINTS_IO_MAGIC_NUMBER_, POINTS_IO_VERSION_, np_flagged_global, 1 }; // last is include delta or not maybe?
	  MPI_File_write_at(fh,0,ibuf,4,MPI_INT8,MPI_STATUS_IGNORE);
	}

	// xp...
	double (*xp)[3] = new double[np_flagged][3];
	double *delta = new double[np_flagged];

	int count = 0;
	for (int ip=0; ip < np; ++ip) {
	  if (p_flag[ip] == 1) {
	    FOR_I3 xp[count][i] = vertexVec[ip].x[i];
	    const double level = double(vertexVec[ip].level);
	    delta[count] = hcp_delta/pow(2.0,level)*1.5;
	    count++;
	  }
	}
	assert(count == np_flagged);

	int8 my_disp;
	MPI_Scan(&my_np,&my_disp,1,MPI_INT8,MPI_SUM,mpi_comm);
	assert( (mpi_rank != mpi_size-1) || (my_disp == np_flagged_global) );
	assert(my_disp > 0 && my_disp <= np_flagged_global);
	MPI_Offset offset = (my_disp-my_np)*3*8 + 4*8;
	MPI_File_write_at_all(fh,offset,xp,np_flagged*3,MPI_DOUBLE,MPI_STATUS_IGNORE);

	// delta...

	offset = np_flagged_global*3*8 + 4*8 + (my_disp-my_np)*8;
	MPI_File_write_at_all(fh,offset,delta,np_flagged,MPI_DOUBLE,MPI_STATUS_IGNORE);

	// and close...

	MPI_File_close(&fh);
	DELETE(xp);
	DELETE(delta);
      }
      DELETE(p_flag);
    }

  }

#undef HCP_BIT_MAX
#undef HCP_LEVEL_MAX

};

#endif // #ifndef _HCP_POINT_BUILDER_HPP_

inline void cholesky_fac(double* L, const double* A, const int n) { 

  // for now , we're not going to overwrite A
  // but we can always change that later..
  for (int i =0; i < n*n; ++i) 
    L[i] = A[i];

#define L(i,j) L[(j)*n + i]
  
  for (int j = 0; j < n; ++j) { 
    for (int k = 0; k < j; ++k) 
      for (int i = 0; i < n; ++i) 
        L(i,j) -= L(i,k)*L(j,k);
    
    L(j,j) = sqrt(L(j,j));
    for (int k = j+1; k < n; ++k) 
      L(k,j) /= L(j,j); 
  }
    
#undef L
}

inline void cholesky_solve(double* r, const double *L, const int n) { 
  // solve LL^T[x] = r

#define L(i,j) L[(j)*n + i]

  // solve Ly = r
  for(int i = 0; i < n; ++i) {
    for(int j = 0; j < i; ++j) {                                      
      r[i] -= L(i,j)*r[j]; 
    }
    r[i] = r[i]/L(i,i); 
  }

  // solve L^Tx = y, overwrite r..
  for (int i = n-1; i >= 0; --i) { 
    for (int j = n-1; j > i; --j) 
      r[i] -= L(j,i)*r[j];
    r[i] = r[i]/L(i,i);
  }

#undef L
}

inline void normalize(double* vec, const int n) { 
  double sum = 0.0;
  for (int i =0; i < n ; ++i) 
    sum += vec[i]*vec[i];

  assert( sum > 0.0);
  sum = 1.0/sqrt(sum);
  for (int i =0 ; i <n ; ++i) 
    vec[i] *= sum;


  // check...
  sum = 0.0;
  for (int i =0; i < n ; ++i) 
    sum += vec[i]*vec[i];
  assert( abs(sum-1.0) < 1.0e-12);
}

inline double dot_product(const double* vec1, const double* vec2, const int n) { 
  double sum = 0.0;
  for (int i =0; i < n ; ++i) 
    sum += vec1[i]*vec2[i];
  return sum;
}

class StaticSolverOps : public StaticSolver {
private:

  VoronoiPart * voronoiPart;
  
public:

  StaticSolverOps() {
    COUT1("StaticSolverOps()");
    voronoiPart = NULL;
  }
  
  virtual ~StaticSolverOps() {
    COUT1("~StaticSolverOps()");
    if (voronoiPart) delete voronoiPart;
  }

  void init() {
    
    // use the Voronoi part to init the solver base class

    assert(voronoiPart == NULL);
    FOR_PARAM_MATCHING("PART") {
      if (param->getString() == "main") {
	voronoiPart = new VoronoiPart(&*param);
	break;
      }
    }
    if (voronoiPart == NULL) {
      CERR("PART main not found");
    }
    voronoiPart->init();
    voronoiPart->writeRestart("restart.les");
    if (Param * param = getParam("WRITE_RESTART_V3")) 
      voronoiPart->writeRestart("restart_v3.les",3);

    //MPI_Pause("YOU REALLY ROCK");

    voronoiPart->initStaticSolver(this);
    StaticSolver::init();

    MPI_Barrier(mpi_comm);
    double wtime0 = MPI_Wtime();

    buildExtendedFaces();

    MPI_Barrier(mpi_comm);
    double wtime = MPI_Wtime();
    if (mpi_rank == 0)
      cout << "Elapsed time just for extended faces build: " << wtime-wtime0 << endl;

    checkGclExtended();
    
    buildCv2Prcomm(); // also extends x_cv into second layer of ghosts 
    
    checkGradExtended();

    MPI_Barrier(mpi_comm);
    wtime = MPI_Wtime();
    if (mpi_rank == 0)
      cout << "Elapsed time for operator build: " << wtime-wtime0 << endl;
    
    //MPI_Pause("HOW long was that?");
    
  }

  void writePointTecplot(const string& filename,const double x[3]) {
    
    FILE * fp = fopen(filename.c_str(),"w");
    fprintf(fp,"TITLE = \"%s\"\n","debug.dat");
    fprintf(fp,"VARIABLES = \"X\"\n");
    fprintf(fp,"\"Y\"\n");
    fprintf(fp,"\"Z\"\n");
    
    fprintf(fp,"ZONE T=\"point\"\n");
    fprintf(fp,"I=1, J=1, K=1\n");
    
    fprintf(fp,"%18.15e %18.15e %18.15e\n",x[0],x[1],x[2]);

    fclose(fp);

  }
  
  void writeVoronoiTecplot(const string& filename) {

    COUT1("writeVoronoiTecplot(" << filename << ")");
    
    assert(mpi_size == 1);
    FILE * fp = fopen(filename.c_str(),"w");
    fprintf(fp,"TITLE = \"%s\"\n","debug.dat");
    fprintf(fp,"VARIABLES = \"X\"\n");
    fprintf(fp,"\"Y\"\n");
    fprintf(fp,"\"Z\"\n");
    
    assert(voronoiPart);
    assert(voronoiPart->points->np == ncv);
    
    for (int icv = 0; icv < ncv; ++icv) {
      voronoiPart->writeFullCvTecplotZone(fp,icv,voronoiPart->points->xp[icv]);
    }
    
    fclose(fp);

  }

  class Coeff {
  public:
    uint8 rbi,rbi_nbr;
    double coeff[3];
    bool transpose;
    Coeff() {
      transpose = false;
    }
    Coeff(const uint8 rbi,const uint8 rbi_nbr,const double coeff[3]) {
      this->rbi = rbi;
      this->rbi_nbr = rbi_nbr;
      this->coeff[0] = coeff[0];
      this->coeff[1] = coeff[1];
      this->coeff[2] = coeff[2];
      transpose = false;
    }
    void copy(const Coeff& other) {
      rbi       = other.rbi;
      rbi_nbr   = other.rbi_nbr;
      coeff[0]  = other.coeff[0];
      coeff[1]  = other.coeff[1];
      coeff[2]  = other.coeff[2];
      transpose = other.transpose;
    }
    bool operator<(const Coeff& other) const { 
      return (rbi < other.rbi)||((rbi == other.rbi)&&(rbi_nbr < other.rbi_nbr)); 
    }
  };

#include "define_coeff.hpp"
  
  void buildExtendedFaces() {
    
    COUT1("StaticSolverOps::buildExtendedFaces()");

    //assert(b_cvPrcomm);
    assert(fa2 == NULL);
    
    // build 1-sided reconstructions for each face...
    
    /*
      const double x_debug[3] = { 0.0, 0.0, 0.52 };
      int icv_debug = MiscUtils::getClosestPoint(x_debug,x_cv,ncv);
      if (icv_debug >= 0) cout << "[" << mpi_rank << "] got icv_debug: " << icv_debug << 
      " at x_cv: " << COUT_VEC(x_cv[icv_debug]) << " dist: " << DIST(x_debug,x_cv[icv_debug]) << endl;
    */
    int icv_debug = -1;


    // the new ops use a regularized, constrained polynomial integration
    // of the voronoi diagram cvs (including their orphans) and thus
    // cannot live at the StaticSolver level...
    
    assert(voronoiPart);

    // step 1: we need the 14 quadrature coeff's in the ghost cvs of our
    // interprocessor faces where we don't have local voronoi data...

    int * send_count = new int[mpi_size];
    FOR_RANK send_count[rank] = 0;
    
    // at the same time that we count how much data we need to send/recv, also
    // figure out the maximum local side of the cvocv_i/v CSR structure: i.e.
    // what is the maximum local nbr count...

    int coc_max = 0;
    for (int icv = 0; icv < ncv; ++icv) {
      coc_max = max(coc_max,cvocv_i[icv+1]-cvocv_i[icv]);
      // loop on faces first -- we are going to build the one-sided reconstruction operator...
      for (int foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
	const int ifa = faocv_v[foc];
	assert((cvofa[ifa][0] == icv)||(cvofa[ifa][1] == icv));
	// for each face, we are going to build a linear system to compute the reconstruction coefficients...
	for (int coc = cvocv_i[icv]; coc != cvocv_i[icv+1]; ++coc) {
	  const int icv_nbr = cvocv_v[coc];
	  if (icv_nbr >= ncv) {
	    int rank,bits,index;
	    BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_nbr-ncv]);
	    assert(rank != mpi_rank);
	    assert(bits == 0);
	    ++send_count[rank];
	  }
	}
      }
    }
    
    int * send_disp = new int[mpi_size];
    send_disp[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
    int send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
    
    int * send_buf_int = new int[send_count_sum*4]; // for the icv, r,b,i nbr (for the face)...
    double * send_buf_double = new double[send_count_sum*14]; // 12 for the 3 components of e0,e1,e2, plus dx and 14 for the returned coeff, so use 14...

    double fa_sign;
    for (int icv = 0; icv < ncv; ++icv) {
      coc_max = max(coc_max,cvocv_i[icv+1]-cvocv_i[icv]);
      // loop on faces first -- we are going to build the one-sided reconstruction operator...
      for (int foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
	const int ifa = faocv_v[foc];
	assert((cvofa[ifa][0] == icv)||(cvofa[ifa][1] == icv));
	// for each face, we are going to build a linear system to compute the reconstruction coefficients...
	for (int coc = cvocv_i[icv]; coc != cvocv_i[icv+1]; ++coc) {
	  const int icv_nbr = cvocv_v[coc];
	  if (icv_nbr >= ncv) {
	    int rank,bits,index;
	    BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_nbr-ncv]);
	    assert(rank != mpi_rank);
	    assert(bits == 0);
	    int inverse_bits = 0;
	    send_buf_int[send_disp[rank]*4  ] = index; // icv on rank
	    send_buf_int[send_disp[rank]*4+1] = mpi_rank; // our rank
	    send_buf_int[send_disp[rank]*4+2] = inverse_bits;
	    send_buf_int[send_disp[rank]*4+3] = icv;
	    setFaceVectors(send_buf_double+send_disp[rank]*12,
			   send_buf_double+send_disp[rank]*12+3,
			   send_buf_double+send_disp[rank]*12+6,
			   fa_sign,ifa,icv);
	    // the face associated with this icv->icv_nbr connection is not 
	    // necessarily ifa (although it can be)...
	    const int ifa_nbr = faocv_v[coc-cvocv_i[icv]-1+faocv_i[icv]];
	    assert((cvofa[ifa_nbr][0] == icv)&&(cvofa[ifa_nbr][1] == icv_nbr)); // outward pointing by definition
	    // when computing the coefficients locally, we use a dx vector relative to
	    // the reconstruction face "ifa", so put the first part of this vector in
	    // dx. We add the rest on the processor that knows about the voronoi diagram.
	    FOR_I3 send_buf_double[send_disp[rank]*12+9+i] = fa[ifa_nbr].x[i] - fa[ifa].x[i];
	    // transform the vectors if periodic?...
	    assert(bits == 0);
	    ++send_disp[rank];
	  }
	}
      }
    }

    // rewind send_disp...
    
    send_disp[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      send_disp[rank] = send_count[rank-1] + send_disp[rank-1];
    
    // and share with recv side...
    
    int * recv_count = new int[mpi_size];
    MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
    
    int * recv_disp = new int[mpi_size];
    recv_disp[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
    int recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
    
    FOR_RANK {
      send_count[rank] *= 4;
      send_disp[rank]  *= 4;
      recv_count[rank] *= 4;
      recv_disp[rank]  *= 4;
    }
    
    int * recv_buf_int = new int[recv_count_sum*4];
    MPI_Alltoallv(send_buf_int,send_count,send_disp,MPI_INT,
		  recv_buf_int,recv_count,recv_disp,MPI_INT,mpi_comm);
    
    delete[] send_buf_int; 
    
    FOR_RANK {
      send_count[rank] = (send_count[rank]/4)*12;
      send_disp[rank]  = (send_disp[rank]/4)*12;
      recv_count[rank] = (recv_count[rank]/4)*12;
      recv_disp[rank]  = (recv_disp[rank]/4)*12;
    }

    double * recv_buf_double = new double[recv_count_sum*14]; // same argument for sizing as above
    MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		  recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
    
    // cycle backwards on the recv side to allow repacking of the recv_buf_double
    // from 12 to 14 without overwriting...
    
    for (int irecv = recv_count_sum-1; irecv >= 0; --irecv) {
      const int icv = recv_buf_int[irecv*4]; assert((icv >= 0)&&(icv < ncv));
      const uint8 rbi = BitUtils::packRankBitsIndex(recv_buf_int[irecv*4+1],recv_buf_int[irecv*4+2],recv_buf_int[irecv*4+3]);
      // given icv and rbi, find the corresponding nbr including the common face...
      int ifa = -1,foc;
      for (foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
	ifa = faocv_v[foc];
	const int icv_nbr = cvofa[ifa][1]; // the inter-processor faces will always be outward pointing
	if ((icv_nbr >= ncv)&&(rbi == rbi_g[icv_nbr-ncv])) {
	  break;
	}
      }
      assert(foc != faocv_i[icv+1]); // ensure found
      assert(ifa != -1);
      double e0[3]; FOR_I3 e0[i] = recv_buf_double[irecv*12+i];
      double e1[3]; FOR_I3 e1[i] = recv_buf_double[irecv*12+3+i];
      double e2[3]; FOR_I3 e2[i] = recv_buf_double[irecv*12+6+i];
      // for the dx vector, the recv_buf already has the vector from the reconstruction face 
      // to the common face ifa: we need to add the vector from the common
      // face to the Voronoi point...
      double dx[3]; FOR_I3 dx[i] = recv_buf_double[irecv*12+9+i] + voronoiPart->points->xp[icv][i] - fa[ifa].x[i];
      // now we can compute the coeffs directly into the recv_buf...
      voronoiPart->calcQuadratureTerms(recv_buf_double+irecv*14,icv,dx,e0,e1,e2);
    }
    
    delete[] recv_buf_int;

    FOR_RANK {
      send_count[rank] = (send_count[rank]/12)*14;
      send_disp[rank]  = (send_disp[rank]/12)*14;
      recv_count[rank] = (recv_count[rank]/12)*14;
      recv_disp[rank]  = (recv_disp[rank]/12)*14;
    }

    MPI_Alltoallv(recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,
		  send_buf_double,send_count,send_disp,MPI_DOUBLE,
		  mpi_comm);
    
    delete[] recv_buf_double; recv_buf_double = NULL;
    
    // =================================================
    // data required for the local matrix math...
    // =================================================
    
    double A[5][5],C[3][5];
    double LU[8][8];
    double (*rhs)[8] = new double[coc_max][8];
    double e0[3],e1[3],e2[3];
    double coeff[14];
    const double coeff_zero = 1.0E-15; // was 1.0E-5 // at what point do we zero the reconstruction coefficients

    double Q[5*5], R[3*3]; // Gram-Schmidt C^T = Q*R
    double T[3*3]; // project A to orthogonal to C T = Q2^T*A*Q2, T is symmetric because A is symm.
    double L[3*3]; // CholeskyT = L^T*L
    // note that R is 2x2 and L/T is 3x3 for nc = 2, and R is 3x3 and L/T is 2x2 for nx = 3
    // NOTE: can probably remove these guys and use R speed, also make GS MGS
    double theta0[5], theta1[5], theta2[5];
    double zeta_inv[9]; // nc = 2 : 2x2, nc = 3 : 3x3

    vector<Coeff> coeffVec;
    coeffVec.reserve(ncv*28); // can be 5x this or more, but even this helps timing
    
    //
    // the polynomial is centered about the face, and in local face-normal 
    // cordinates with form
    //
    // P(x,y,z) = c5 + c4*x + c3*x*x + c2*y + c1*z
    //
    // and cP,cQ (and cNbr in some cases) are the constraints associated with the 
    // lagrange multipliers
    //
    // the coefficients are reversed to minimize the work required to compute
    // the desired value of c5 during back-substitution in the LU decomposition.
    //
    // we are going to set up the (KKT?) matrix problem:
    //
    // [ A C^T ] [c1,c2,c3,c4,c5,cP,cQ]^T  =  [g] [PP,PQ,Pnbr,...]
    // [ C  0  ]                              [h]
    //

    for (int icv = 0; icv < ncv; ++icv) {

      // HACK - debug all...

      //icv_debug = icv;
      icv_debug = -1;
      
      if ((mpi_rank == 0)&&(icv%(ncv/10) == 0)) {
	cout << " > " << icv/(ncv/10)*10 << "%" << endl;
      }
      
      // we are building coefficients for this row in the global matrix... 

      const uint8 rbi = BitUtils::packRankBitsIndex(mpi_rank,0,icv);
      
      // just internal faces for now...
      
      for (int foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
	const int ifa = faocv_v[foc];
	
	// compute the polynomial basis vectors in the face coodinate system...
	setFaceVectors(e0,e1,e2,fa_sign,ifa,icv);
	
	// the nbr cv associated with the face...
	const int icv_fa_nbr = cvocv_v[foc-faocv_i[icv]+cvocv_i[icv]+1];

	// check orinetation is as expected...
	if (fa_sign == 1.0) {
	  assert((cvofa[ifa][0] == icv)&&(cvofa[ifa][1] == icv_fa_nbr));
	}
	else {
	  assert(fa_sign == -1.0);
	  assert((cvofa[ifa][1] == icv)&&(cvofa[ifa][0] == icv_fa_nbr));
	}
	
	uint8 rbi_fa_nbr;
	if (icv_fa_nbr < ncv) {
	  rbi_fa_nbr = BitUtils::packRankBitsIndex(mpi_rank,0,icv_fa_nbr);
	}
	else {
	  rbi_fa_nbr = rbi_g[icv_fa_nbr-ncv];
	}

	if (icv == icv_debug) cout << "\n\nworking on icv_debug,ifa: " << ifa << endl;

	// zero A...
	for (int i = 0; i < 5; ++i)
	  for (int j = 0; j < 5; ++j)
	    A[i][j] = 0.0;

	double wgt0=0.0,wgt1=0.0;
	
	int nc = 2; // number of constraints...
	const int ncoc = cvocv_i[icv+1]-cvocv_i[icv];
	
	// for each face, we are going to build a linear system to compute the reconstruction coefficients...
	for (int coc = 0; coc < ncoc; ++coc) {
	  
	  const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	  if (icv_nbr < ncv) {
	    // this is a local nbr. compute the coeff matrix here...
	    const double dx[3] = DIFF(voronoiPart->points->xp[icv_nbr],fa[ifa].x);
	    voronoiPart->calcQuadratureTerms(coeff,icv_nbr,dx,e0,e1,e2);
	  }
	  else {
	    // this is an inter-processor nbr where the coeff's have been pre-computed and reduced above...
	    int rank,bits,index;
	    BitUtils::unpackRankBitsIndex(rank,bits,index,rbi_g[icv_nbr-ncv]);
	    assert(rank != mpi_rank);
	    for (int i = 0; i < 14; ++i)
	      coeff[i] = send_buf_double[send_disp[rank]+i]; // send_disp already 14-stride
	    send_disp[rank] += 14;

	    if (icv == icv_debug) cout << "XXXXXX icv_debug has a ghost nbr" << endl;

	  }

	  // top left matrix is A[][]...

	  const double factor = 2.0E-7*coeff[SW]; // note we include coeff[SW] here to get correct scaling
	  
	  A[0][0] += factor*coeff[SWZZ];
	  A[0][1] += factor*coeff[SWYZ];
	  A[0][2] += factor*coeff[SWXXZ];
	  A[0][3] += factor*coeff[SWXZ];
	  A[0][4] += factor*coeff[SWZ];
      
	  A[1][0] += factor*coeff[SWYZ];
	  A[1][1] += factor*coeff[SWYY];
	  A[1][2] += factor*coeff[SWXXY];
	  A[1][3] += factor*coeff[SWXY];
	  A[1][4] += factor*coeff[SWY];
	  
	  A[2][0] += factor*coeff[SWXXZ];
	  A[2][1] += factor*coeff[SWXXY];
	  A[2][2] += factor*coeff[SWXXXX];
	  A[2][3] += factor*coeff[SWXXX];
	  A[2][4] += factor*coeff[SWXX];
	  
	  A[3][0] += factor*coeff[SWXZ];
	  A[3][1] += factor*coeff[SWXY];
	  A[3][2] += factor*coeff[SWXXX];
	  A[3][3] += factor*coeff[SWXX];
	  A[3][4] += factor*coeff[SWX];
	  
	  A[4][0] += factor*coeff[SWZ];
	  A[4][1] += factor*coeff[SWY];
	  A[4][2] += factor*coeff[SWXX];
	  A[4][3] += factor*coeff[SWX];
	  A[4][4] += factor*coeff[SW];
	  
	  // rhs...
	  
	  rhs[coc][0] = factor*coeff[SWZ];
	  rhs[coc][1] = factor*coeff[SWY];
	  rhs[coc][2] = factor*coeff[SWXX];
	  rhs[coc][3] = factor*coeff[SWX];
	  rhs[coc][4] = factor*coeff[SW];

	  // least-squares formulation...
	  // different formulation...

	  const double factor2 = 2.0; // was 2.0

	  A[0][0] += factor2*coeff[SWZ]*coeff[SWZ];
	  A[1][0] += factor2*coeff[SWZ]*coeff[SWY];
	  A[2][0] += factor2*coeff[SWZ]*coeff[SWXX];
	  A[3][0] += factor2*coeff[SWZ]*coeff[SWX];
	  A[4][0] += factor2*coeff[SWZ]*coeff[SW];

	  A[0][1] += factor2*coeff[SWY]*coeff[SWZ];
	  A[1][1] += factor2*coeff[SWY]*coeff[SWY];
	  A[2][1] += factor2*coeff[SWY]*coeff[SWXX];
	  A[3][1] += factor2*coeff[SWY]*coeff[SWX];
	  A[4][1] += factor2*coeff[SWY]*coeff[SW];
	  
	  A[0][2] += factor2*coeff[SWXX]*coeff[SWZ];
	  A[1][2] += factor2*coeff[SWXX]*coeff[SWY];
	  A[2][2] += factor2*coeff[SWXX]*coeff[SWXX];
	  A[3][2] += factor2*coeff[SWXX]*coeff[SWX];
	  A[4][2] += factor2*coeff[SWXX]*coeff[SW];
	  
	  A[0][3] += factor2*coeff[SWX]*coeff[SWZ];
	  A[1][3] += factor2*coeff[SWX]*coeff[SWY];
	  A[2][3] += factor2*coeff[SWX]*coeff[SWXX];
	  A[3][3] += factor2*coeff[SWX]*coeff[SWX];
	  A[4][3] += factor2*coeff[SWX]*coeff[SW];
	  
	  A[0][4] += factor2*coeff[SW]*coeff[SWZ];
	  A[1][4] += factor2*coeff[SW]*coeff[SWY];
	  A[2][4] += factor2*coeff[SW]*coeff[SWXX];
	  A[3][4] += factor2*coeff[SW]*coeff[SWX];
	  A[4][4] += factor2*coeff[SW]*coeff[SW];
	  
	  rhs[coc][0] += factor2*coeff[SW]*coeff[SWZ];
	  rhs[coc][1] += factor2*coeff[SW]*coeff[SWY];
	  rhs[coc][2] += factor2*coeff[SW]*coeff[SWXX];
	  rhs[coc][3] += factor2*coeff[SW]*coeff[SWX];
	  rhs[coc][4] += factor2*coeff[SW]*coeff[SW];

	  if (icv_nbr == icv) {
	    
	    // this is the first constraint -- it is always present...
	    
	    C[0][0] = coeff[SWZ];
	    C[0][1] = coeff[SWY];
	    C[0][2] = coeff[SWXX];
	    C[0][3] = coeff[SWX];
	    C[0][4] = coeff[SW];
	
	    rhs[coc][5] = coeff[SW];
	    rhs[coc][6] = 0.0;
	    rhs[coc][7] = 0.0;

	    // use the projection along e0 to determine one of the
	    // wgt coefficients used to build the face reconstruction...

	    assert(coeff[SWX] < 0.0);
	    assert(wgt0 == 0.0);
	    wgt0 = -coeff[SWX]/coeff[SW];
	
	  }
	  else if (icv_nbr == icv_fa_nbr) {
	    
	    // this is the second constraint -- it is also always present on 
	    // internal faces...

	    C[1][0] = coeff[SWZ];
	    C[1][1] = coeff[SWY];
	    C[1][2] = coeff[SWXX];
	    C[1][3] = coeff[SWX];
	    C[1][4] = coeff[SW];
	    
	    rhs[coc][5] = 0.0;
	    rhs[coc][6] = coeff[SW];
	    rhs[coc][7] = 0.0;

	    assert(coeff[SWX] > 0.0);
	    assert(wgt1 == 0.0);
	    wgt1 = coeff[SWX]/coeff[SW];
	    
	  }
	  else {

	    // this is not one of the two automatically constrained nbrs, but 
	    // we should still constrain it if it's centroid is sufficiently along the 
	    // e0 vector...
	    
	    const double dp = -coeff[SWX]/sqrt(coeff[SWX]*coeff[SWX] + coeff[SWY]*coeff[SWY] + coeff[SWZ]*coeff[SWZ]);
	    
	    if (icv == icv_debug) {
	      cout << "other nbr dp: " << dp << endl;
	    }

	    //cout << "HACKHACK hacking additional contrainst" << endl;
	    if (dp > 0.8) { // 0.78? 0.8?
	    //if (true) {
	    //if (false) {
	      
	      const double wgt = 1.0; // use a bump function here in the future....
	      
	      if (nc == 2) {
		C[2][0] = wgt*coeff[SWZ];
		C[2][1] = wgt*coeff[SWY];
		C[2][2] = wgt*coeff[SWXX];
		C[2][3] = wgt*coeff[SWX];
		C[2][4] = wgt*coeff[SW];
		nc = 3;
	      }
	      else {
		assert(nc == 3);
		C[2][0] += wgt*coeff[SWZ];
		C[2][1] += wgt*coeff[SWY];
		C[2][2] += wgt*coeff[SWXX];
		C[2][3] += wgt*coeff[SWX];
		C[2][4] += wgt*coeff[SW];
	      }
	      
	      rhs[coc][5] = 0.0;
	      rhs[coc][6] = 0.0;
	      rhs[coc][7] = wgt*coeff[SW];
	      
	    }
	    else {

	      rhs[coc][5] = 0.0;
	      rhs[coc][6] = 0.0;
	      rhs[coc][7] = 0.0;

	    }
	    
	  }

	}
	  
	if (icv == icv_debug) {
	  cout << "done coeff build. nc = " << nc << endl;
	}
	
	// matricies are all complete. Now solve the equality-constrained minimization problem...

	// ==============================================================
	// build LU using doolittle's method?...
	// must be a better way that uses Schur Complement... later
	// ==============================================================

        //======================================================================================
        // stb nc = 2
        //======================================================================================
	if (nc == 2) {

          // first, lets build the QR factorization of the C^T
          // i actually don't need R, i just need the Q2 part of Q = [Q1 Q2] 
          // C^T is a 5X2 matrix.. 

          /*
#define Q(i,j) Q[(j)*5 + (i)]

          double z0z0    = 0.0;
          double z1z1    = 0.0;
          double z0z1    = 0.0;

          // store some information about C.. 
          for (int i = 0; i <5 ; ++i) { 
            z0z0 += C[0][i]*C[0][i];
            z0z1 += C[0][i]*C[1][i];
            z1z1 += C[1][i]*C[1][i];
          }

          for (int i = 0; i < 5; ++i) { 
            theta0[i] = 0.0;
            theta1[i] = 0.0;
            for (int j =0; j < 5; ++j) { 
              theta0[i] += A[i][j]*C[0][j];
              theta1[i] += A[i][j]*C[1][j];
            }
          }

          double det_zeta = z0z0*z1z1 - z0z1*z0z1; 
          zeta_inv[(0)*2+0] = z1z1/det_zeta;
          zeta_inv[(0)*2+1] = -z0z1/det_zeta;
          zeta_inv[(1)*2+0] = -z0z1/det_zeta;
          zeta_inv[(1)*2+1] = z0z0/det_zeta;

          // set the first vecotr..
          for (int i =0; i < 5; ++i)  
            Q(i,0) = C[0][i]; // first column of C^T 
          normalize(&Q(0,0),5);
          
          // second vector.. 
          for (int i =0; i <5 ; ++i) 
            Q(i,1) = C[1][i]; // sec col of C^T

          double dot0 = dot_product(&Q(0,0),&Q(0,1),5);
          for (int i = 0; i < 5; ++i) 
            Q(i,1) -= dot0*Q(i,0);
          normalize(&Q(0,1),5);

          // remaining vectors .. lets assume that we can use the identity matrix
          // to produce a rank(5) basis..
          for (int j = 0; j < 3; ++j) { 

            // set the initial identity vector..
            for (int i =0; i <5; ++i) { 
              if ( i == j ) 
                Q(i,j+2) = 1.0;
              else 
                Q(i,j+2) = 0.0;
            }

            // gram-schmidt thyme
            for (int jj = 0; jj < j+2; ++jj) { 
              const double dot0 = dot_product(&Q(0,j+2),&Q(0,jj),5);
              for (int i =0; i < 5; ++i) 
                Q(i,j+2) -= dot0*Q(i,jj);
            }
            normalize(&Q(0,j+2),5);
          }//j


          // now lets check to make sure we're orthogonal..
          for (int jj0 = 0; jj0 < 5; ++jj0) { 
            for (int jj1 = 0; jj1 < 5; ++jj1) { 
              
              const double dot0 = dot_product(&Q(0,jj0),&Q(0,jj1),5);
              if ( jj0 == jj1) { 
                assert( abs(dot0-1.0) < 1.0e-12);
              } else { 
                assert( abs(dot0) < 1.0e-12);
              }
            }
          }

          // also check the orthogonality with the cols of C^T (rows of C)
          for (int j = 0; j < 3; ++j) { 
            double dp0 = 0.0;
            double dp1 = 0.0;
            for (int i =0; i < 5; ++i) { 
              dp0 += Q(i,j+2)*C[0][i];
              dp1 += Q(i,j+2)*C[1][i];
            }
            assert( abs(dp0) < 1.0e-12);
            assert( abs(dp1) < 1.0e-12);
          }

          if ( icv == icv_debug) { 
            cout << "null space ok. " << endl;
            //getchar();
          }

          
          // now build T = Q2^T*A*Q2 .. 
          // consider re-ordering this loop as two matrix multiplies, instead 
          // of condensing the operations..
#define T(i,j) T[(j)*3 + i]
          for (int j = 0; j < 3; ++j) { 
            for (int i = 0; i < 3 ; ++i) { 
              T(i,j) = 0.0;
              for (int n = 0; n < 5; ++n) { 
                for (int k = 0; k < 5; ++k) { 
                  T(i,j) += Q(n,i+2)*A[n][k]*Q(k,j+2);
                }
              }
            }
          }
#undef T
          */

          // compute the cholesky factorization of T..
          /*
          {
            int info;
            char uplo='l';
            int nn = 3;
            dpotrf_(&uplo,&nn,T,&nn,&info);
            if ( info != 0 ) 
              assert(0);
          }
          */
          //cholesky_fac(L,T,3); // compute the cholesky factorization manually..

          // make a copy of the rhs...
 //         for (int i = 0; i < coc_max; ++i) { 
 //           for (int j = 0; j < 7; ++j) 
 //             rhs_cpy[i][j] = rhs[i][j];
 //         }
	  
	  /*

	  cout << "about to try linear..." << endl;
	  {

	    // eliminate row and col 2 from A and C...

	    LU[0][0] = A[0][0];
	    LU[0][1] = A[0][1];
	    LU[0][2] = A[0][3];
	    LU[0][3] = A[0][4];
	    LU[0][4] = C[0][0];
	    LU[0][5] = C[1][0];
    
	    assert(LU[0][0] != 0.0);
	    LU[1][0] = A[1][0]/LU[0][0];
	    LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
	    LU[1][2] = A[1][3] - LU[0][2]*LU[1][0];
	    LU[1][3] = A[1][4] - LU[0][3]*LU[1][0];
	    LU[1][4] = C[0][1] - LU[0][4]*LU[1][0];
	    LU[1][5] = C[1][1] - LU[0][5]*LU[1][0];
	
	    LU[2][0] = A[3][0]/LU[0][0];
	    assert(LU[1][1] != 0.0);
	    LU[2][1] = (A[3][1] - LU[0][1]*LU[2][0])/LU[1][1];
	    LU[2][2] = A[3][3] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
	    LU[2][3] = A[3][4] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
	    LU[2][4] = C[0][3] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
	    LU[2][5] = C[1][3] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
	
	    LU[3][0] = A[4][0]/LU[0][0];
	    LU[3][1] = (A[4][1] - LU[0][1]*LU[3][0])/LU[1][1];
	    assert(LU[2][2] != 0.0);
	    LU[3][2] = (A[4][3] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
	    LU[3][3] = A[4][4] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
	    LU[3][4] = C[0][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
	    LU[3][5] = C[1][4] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];

	    LU[4][0] = C[0][0]/LU[0][0];
	    LU[4][1] = (C[0][1] - LU[0][1]*LU[4][0])/LU[1][1];
	    LU[4][2] = (C[0][3] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
	    assert(LU[3][3] != 0.0);
	    LU[4][3] = (C[0][4] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
	    LU[4][4] = - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
	    LU[4][5] = - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
	
	    LU[5][0] = C[1][0]/LU[0][0];
	    LU[5][1] = (C[1][1] - LU[0][1]*LU[5][0])/LU[1][1];
	    LU[5][2] = (C[1][3] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
	    LU[5][3] = (C[1][4] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
	    assert(LU[4][4] != 0.0);
	    LU[5][4] = (- LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
	    LU[5][5] = - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];

	    // adjust rhs...
	    for (int coc = 0; coc < ncoc; ++coc) {
	      for (int i = 3; i < 5+nc; ++i) {
		rhs[coc][i-1] = rhs[coc][i];
	      }
	    }

	    double sum = 0.0;
	    double nonzero_sum = 0.0;
	    for (int coc = 0; coc < ncoc; ++coc) {
	      const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	      // overwrite rhs...
	      for (int i = 1; i < 4+nc; ++i) 
		for (int j = 0; j < i; ++j)
		  rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	      // and back substitute to solve...
	      rhs[coc][4+nc-1] /= LU[4+nc-1][4+nc-1];
	      for (int i = 4+nc-2; i >= 3; --i) {
		for (int j = i+1; j < 4+nc; ++j)
		  rhs[coc][i] -= LU[i][j]*rhs[coc][j];
		rhs[coc][i] /= LU[i][i];
	      }
	      // the coeff is in rhs[coc][3]...
	      sum += rhs[coc][3]; 
	      if (fabs(rhs[coc][3]) < coeff_zero) {
		rhs[coc][3] = 0.0;
	      }
	      else {
		nonzero_sum += rhs[coc][3];
	      }
	      if (icv == icv_debug) {
		cout << "coc: " << coc << " rhs: " << rhs[coc][3] << " at dx: " << 
		  x_cv[icv_nbr][0]-x_cv[icv][0] << " " << 
		  x_cv[icv_nbr][1]-x_cv[icv][1] << " " << 
		  x_cv[icv_nbr][2]-x_cv[icv][2] << endl;
	      }
	    }

	    assert(mpi_size == 1);
	    double x_check[3] = { 0.0, 0.0, 0.0 };
	
	    for (int coc = 0; coc < ncoc; ++coc) {
	      if (rhs[coc][3] != 0.0) {
		const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
		assert(icv_nbr < ncv);
		FOR_I3 x_check[i] += rhs[coc][3]/nonzero_sum*x_cv[icv_nbr][i];
	      }
	    }
	    
	    // compare x_check and fa[ifa].x...
	    cout << "x_check: " << COUT_VEC(x_check) << " fa[ifa].x: " << COUT_VEC(fa[ifa].x) << " dist: " << DIST(x_check,fa[ifa].x) << endl;
	    cout << "HOW WAS THAT?" << endl;
	    getchar();
	    

	  }

	  */
	  
	  LU[0][0] = A[0][0];
	  LU[0][1] = A[0][1];
	  LU[0][2] = A[0][2];
	  LU[0][3] = A[0][3];
	  LU[0][4] = A[0][4];
	  LU[0][5] = C[0][0];
	  LU[0][6] = C[1][0];
    
	  assert(LU[0][0] != 0.0);
	  LU[1][0] = A[1][0]/LU[0][0];
	  LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
	  LU[1][2] = A[1][2] - LU[0][2]*LU[1][0];
	  LU[1][3] = A[1][3] - LU[0][3]*LU[1][0];
	  LU[1][4] = A[1][4] - LU[0][4]*LU[1][0];
	  LU[1][5] = C[0][1] - LU[0][5]*LU[1][0];
	  LU[1][6] = C[1][1] - LU[0][6]*LU[1][0];
	
	  LU[2][0] = A[2][0]/LU[0][0];
	  assert(LU[1][1] != 0.0);
	  LU[2][1] = (A[2][1] - LU[0][1]*LU[2][0])/LU[1][1];
	  LU[2][2] = A[2][2] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
	  LU[2][3] = A[2][3] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
	  LU[2][4] = A[2][4] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
	  LU[2][5] = C[0][2] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
	  LU[2][6] = C[1][2] - LU[0][6]*LU[2][0] - LU[1][6]*LU[2][1];
	
	  LU[3][0] = A[3][0]/LU[0][0];
	  LU[3][1] = (A[3][1] - LU[0][1]*LU[3][0])/LU[1][1];
	  assert(LU[2][2] != 0.0);
	  LU[3][2] = (A[3][2] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
	  LU[3][3] = A[3][3] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
	  LU[3][4] = A[3][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
	  LU[3][5] = C[0][3] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];
	  LU[3][6] = C[1][3] - LU[0][6]*LU[3][0] - LU[1][6]*LU[3][1] - LU[2][6]*LU[3][2];
	
	  LU[4][0] = A[4][0]/LU[0][0];
	  LU[4][1] = (A[4][1] - LU[0][1]*LU[4][0])/LU[1][1];
	  LU[4][2] = (A[4][2] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
	  assert(LU[3][3] != 0.0);
	  LU[4][3] = (A[4][3] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
	  LU[4][4] = A[4][4] - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
	  LU[4][5] = C[0][4] - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
	  LU[4][6] = C[1][4] - LU[0][6]*LU[4][0] - LU[1][6]*LU[4][1] - LU[2][6]*LU[4][2] - LU[3][6]*LU[4][3];
	
	  LU[5][0] = C[0][0]/LU[0][0];
	  LU[5][1] = (C[0][1] - LU[0][1]*LU[5][0])/LU[1][1];
	  LU[5][2] = (C[0][2] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
	  LU[5][3] = (C[0][3] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
	  assert(LU[4][4] != 0.0);
	  LU[5][4] = (C[0][4] - LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
	  LU[5][5] = - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];
	  LU[5][6] = - LU[0][6]*LU[5][0] - LU[1][6]*LU[5][1] - LU[2][6]*LU[5][2] - LU[3][6]*LU[5][3] - LU[4][6]*LU[5][4];
	
	  LU[6][0] = C[1][0]/LU[0][0];
	  LU[6][1] = (C[1][1] - LU[0][1]*LU[6][0])/LU[1][1];
	  LU[6][2] = (C[1][2] - LU[0][2]*LU[6][0] - LU[1][2]*LU[6][1])/LU[2][2];
	  LU[6][3] = (C[1][3] - LU[0][3]*LU[6][0] - LU[1][3]*LU[6][1] - LU[2][3]*LU[6][2])/LU[3][3];
	  LU[6][4] = (C[1][4] - LU[0][4]*LU[6][0] - LU[1][4]*LU[6][1] - LU[2][4]*LU[6][2] - LU[3][4]*LU[6][3])/LU[4][4];
	  assert(LU[5][5] != 0.0);
	  LU[6][5] = (- LU[0][5]*LU[6][0] - LU[1][5]*LU[6][1] - LU[2][5]*LU[6][2] - LU[3][5]*LU[6][3] - LU[4][5]*LU[6][4])/LU[5][5];
	  LU[6][6] = - LU[0][6]*LU[6][0] - LU[1][6]*LU[6][1] - LU[2][6]*LU[6][2] - LU[3][6]*LU[6][3] - LU[4][6]*LU[6][4] - LU[5][6]*LU[6][5];
	  assert(LU[6][6] != 0.0);
	
	  // check...

	  for (int i = 0; i < 7; ++i) {
	    for (int j = 0; j < 7; ++j) {
	      double coeff;
	      if (i < 5) {
		if (j < 5) {
		  coeff = A[i][j];
		}
		else {
		  coeff = C[j-5][i];
		}
	      }
	      else if (j < 5) {
		coeff = C[i-5][j];
	      }
	      else {
		coeff = 0.0;
	      }
	      // now compute the L*U...
	      {
		double l[7];
		for (int k = 0; k < i; ++k) l[k] = LU[i][k];
		l[i] = 1.0;
		for (int k = i+1; k < 7; ++k) l[k] = 0.0;
		double u[7];
		for (int k = 0; k <= j; ++k) u[k] = LU[k][j];
		for (int k = j+1; k < 7; ++k) u[k] = 0.0;
		double sum = 0.0;
		for (int k = 0; k < 7; ++k) sum += l[k]*u[k];
		//cout << coeff-sum << " ";
		if (!(fabs(coeff-sum) < 1.0E-12)) {
		  cout << "WARNING: sum problem L*U: " << coeff-sum << endl;
		}
		//assert(fabs(coeff-sum) < 1.0E-12);
	      }
	    }
	    //cout << endl;
	  }
	  //cout << "was this matrix zero?" << endl;

	}
	else if (nc == 3) {

          /*
          // first, lets build the QR factorization of the C^T
          // i actually don't need R, i just need the Q2 part of Q = [Q1 Q2] 
          // C^T is a 5X3 matrix.. 

#define Q(i,j) Q[(j)*5 + (i)]

          double z0z0 = 0.0;
          double z0z1 = 0.0;
          double z0z2 = 0.0;
          double z1z1 = 0.0;
          double z1z2 = 0.0;
          double z2z2 = 0.0;

          // store some information about C.. 
          for (int i = 0; i < 5 ; ++i) { 
            z0z0 += C[0][i]*C[0][i];
            z0z1 += C[0][i]*C[1][i];
            z0z2 += C[0][i]*C[2][i];
            z1z1 += C[1][i]*C[1][i];
            z1z2 += C[1][i]*C[2][i];
            z2z2 += C[2][i]*C[2][i];
          }

          for (int i = 0; i < 5; ++i) { 
            theta0[i] = 0.0;
            theta1[i] = 0.0;
            theta2[i] = 0.0;
            for (int j =0; j < 5; ++j) { 
              theta0[i] += A[i][j]*C[0][j];
              theta1[i] += A[i][j]*C[1][j];
              theta2[i] += A[i][j]*C[2][j];
            }
          }

          double det_zeta = z0z0*(z2z2*z1z1-z1z2*z1z2)
                           -z0z1*(z2z2*z0z1-z1z2*z0z2)
                           +z0z2*(z1z2*z0z1-z1z1*z0z2);
          zeta_inv[(0)*3+0] = (z2z2*z1z1-z1z2*z1z2)/det_zeta;
          zeta_inv[(0)*3+1] = (z0z2*z1z2-z2z2*z0z1)/det_zeta;
          zeta_inv[(0)*3+2] = (z0z1*z1z2-z0z2*z1z1)/det_zeta;
          zeta_inv[(1)*3+0] = zeta_inv[(0)*3+1];
          zeta_inv[(1)*3+1] = (z2z2*z0z0-z0z2*z0z2)/det_zeta;
          zeta_inv[(1)*3+2] = (z0z1*z0z2-z0z0*z1z2)/det_zeta;
          zeta_inv[(2)*3+0] = zeta_inv[(0)*3+2];
          zeta_inv[(2)*3+1] = zeta_inv[(1)*3+2];
          zeta_inv[(2)*3+2] = (z0z0*z1z1-z0z1*z0z1)/det_zeta;

          // set the first vecotr..
          for (int i = 0; i < 5; ++i)  
            Q(i,0) = C[0][i]; // first column of C^T 
          normalize(&Q(0,0),5);
          
          // second vector.. 
          for (int i = 0; i < 5 ; ++i) 
            Q(i,1) = C[1][i]; // sec col of C^T

          double dot01 = dot_product(&Q(0,0),&Q(0,1),5);
          for (int i = 0; i < 5; ++i) 
            Q(i,1) -= dot01*Q(i,0);
          normalize(&Q(0,1),5);

          // third vector...
          for (int i = 0; i < 5 ; ++i) 
            Q(i,2) = C[2][i]; // third col of C^T

          double dot02 = dot_product(&Q(0,0),&Q(0,2),5);
          double dot12 = dot_product(&Q(0,1),&Q(0,2),5);
          for (int i = 0; i < 5; ++i) { 
            Q(i,2) -= dot02*Q(i,0);
            Q(i,2) -= dot12*Q(i,1);
          }
          normalize(&Q(0,2),5);

          // remaining vectors .. lets assume that we can use the identity matrix
          // to produce a rank(5) basis..
          for (int j = 0; j < 2; ++j) { 

            // set the initial identity vector..
            for (int i =0; i < 5; ++i) { 
              if ( i == j ) 
                Q(i,j+3) = 1.0;
              else 
                Q(i,j+3) = 0.0;
            }

            // gram-schmidt thyme
            for (int jj = 0; jj < j+3; ++jj) { 
              const double dot0 = dot_product(&Q(0,j+3),&Q(0,jj),5);
              for (int i = 0; i < 5; ++i) 
                Q(i,j+3) -= dot0*Q(i,jj);
            }
            normalize(&Q(0,j+3),5);
          }//j


          // now lets check to make sure we're orthogonal..
          for (int jj0 = 0; jj0 < 5; ++jj0) { 
            for (int jj1 = 0; jj1 < 5; ++jj1) { 
              
              const double dot0 = dot_product(&Q(0,jj0),&Q(0,jj1),5);
              if ( jj0 == jj1) { 
                assert( abs(dot0-1.0) < 1.0e-12);
              } else { 
                assert( abs(dot0) < 1.0e-12);
              }
            }
          }

          // also check the orthogonality with the cols of C^T (rows of C)
          for (int j = 0; j < 2; ++j) { 
            double dp0 = 0.0;
            double dp1 = 0.0;
            double dp2 = 0.0;
            for (int i = 0; i < 5; ++i) { 
              dp0 += Q(i,j+3)*C[0][i];
              dp1 += Q(i,j+3)*C[1][i];
              dp2 += Q(i,j+3)*C[2][i];
            }
            assert( abs(dp0) < 1.0e-12);
            assert( abs(dp1) < 1.0e-12);
            assert( abs(dp2) < 1.0e-12);
          }

          if ( icv == icv_debug) { 
            cout << "null space ok. " << endl;
            //getchar();
          }

          
          // now build T = Q2^T*A*Q2 .. 
          // consider re-ordering this loop as two matrix multiplies, instead 
          // of condensing the operations..
#define T(i,j) T[(j)*2 + i]
          for (int j = 0; j < 2; ++j) { 
            for (int i = 0; i < 2 ; ++i) { 
              T(i,j) = 0.0;
              for (int n = 0; n < 5; ++n) { 
                for (int k = 0; k < 5; ++k) { 
                  T(i,j) += Q(n,i+3)*A[n][k]*Q(k,j+3);
                }
              }
            }
          }
#undef T
          */

          // compute the cholesky factorization of T..
          /*
          {
            int info;
            char uplo='l';
            int nn = 3;
            dpotrf_(&uplo,&nn,T,&nn,&info);
            if ( info != 0 ) 
              assert(0);
          }
          */
          //cholesky_fac(L,T,2); // compute the cholesky factorization manually..

          // make a copy of the rhs...
       //   for (int i = 0; i < coc_max; ++i) { 
       //     for (int j = 0; j < 8; ++j) 
       //       rhs_cpy[i][j] = rhs[i][j];
       //   }

          // FRANKS VERSION
	  
	  LU[0][0] = A[0][0];
	  LU[0][1] = A[0][1];
	  LU[0][2] = A[0][2];
	  LU[0][3] = A[0][3];
	  LU[0][4] = A[0][4];
	  LU[0][5] = C[0][0];
	  LU[0][6] = C[1][0];
	  LU[0][7] = C[2][0];
    
	  assert(LU[0][0] != 0.0);
	  LU[1][0] = A[1][0]/LU[0][0];
	  LU[1][1] = A[1][1] - LU[0][1]*LU[1][0];
	  LU[1][2] = A[1][2] - LU[0][2]*LU[1][0];
	  LU[1][3] = A[1][3] - LU[0][3]*LU[1][0];
	  LU[1][4] = A[1][4] - LU[0][4]*LU[1][0];
	  LU[1][5] = C[0][1] - LU[0][5]*LU[1][0];
	  LU[1][6] = C[1][1] - LU[0][6]*LU[1][0];
	  LU[1][7] = C[2][1] - LU[0][7]*LU[1][0];
	
	  LU[2][0] =  A[2][0]/LU[0][0];
	  assert(LU[1][1] != 0.0);
	  LU[2][1] = (A[2][1] - LU[0][1]*LU[2][0])/LU[1][1];
	  LU[2][2] =  A[2][2] - LU[0][2]*LU[2][0] - LU[1][2]*LU[2][1];
	  LU[2][3] =  A[2][3] - LU[0][3]*LU[2][0] - LU[1][3]*LU[2][1];
	  LU[2][4] =  A[2][4] - LU[0][4]*LU[2][0] - LU[1][4]*LU[2][1];
	  LU[2][5] =  C[0][2] - LU[0][5]*LU[2][0] - LU[1][5]*LU[2][1];
	  LU[2][6] =  C[1][2] - LU[0][6]*LU[2][0] - LU[1][6]*LU[2][1];
	  LU[2][7] =  C[2][2] - LU[0][7]*LU[2][0] - LU[1][7]*LU[2][1];
	
	  LU[3][0] =  A[3][0]/LU[0][0];
	  LU[3][1] = (A[3][1] - LU[0][1]*LU[3][0])/LU[1][1];
	  assert(LU[2][2] != 0.0);
	  LU[3][2] = (A[3][2] - LU[0][2]*LU[3][0] - LU[1][2]*LU[3][1])/LU[2][2];
	  LU[3][3] =  A[3][3] - LU[0][3]*LU[3][0] - LU[1][3]*LU[3][1] - LU[2][3]*LU[3][2];
	  LU[3][4] =  A[3][4] - LU[0][4]*LU[3][0] - LU[1][4]*LU[3][1] - LU[2][4]*LU[3][2];
	  LU[3][5] =  C[0][3] - LU[0][5]*LU[3][0] - LU[1][5]*LU[3][1] - LU[2][5]*LU[3][2];
	  LU[3][6] =  C[1][3] - LU[0][6]*LU[3][0] - LU[1][6]*LU[3][1] - LU[2][6]*LU[3][2];
	  LU[3][7] =  C[2][3] - LU[0][7]*LU[3][0] - LU[1][7]*LU[3][1] - LU[2][7]*LU[3][2];
	
	  LU[4][0] =  A[4][0]/LU[0][0];
	  LU[4][1] = (A[4][1] - LU[0][1]*LU[4][0])/LU[1][1];
	  LU[4][2] = (A[4][2] - LU[0][2]*LU[4][0] - LU[1][2]*LU[4][1])/LU[2][2];
	  assert(LU[3][3] != 0.0);
	  LU[4][3] = (A[4][3] - LU[0][3]*LU[4][0] - LU[1][3]*LU[4][1] - LU[2][3]*LU[4][2])/LU[3][3];
	  LU[4][4] =  A[4][4] - LU[0][4]*LU[4][0] - LU[1][4]*LU[4][1] - LU[2][4]*LU[4][2] - LU[3][4]*LU[4][3];
	  LU[4][5] =  C[0][4] - LU[0][5]*LU[4][0] - LU[1][5]*LU[4][1] - LU[2][5]*LU[4][2] - LU[3][5]*LU[4][3];
	  LU[4][6] =  C[1][4] - LU[0][6]*LU[4][0] - LU[1][6]*LU[4][1] - LU[2][6]*LU[4][2] - LU[3][6]*LU[4][3];
	  LU[4][7] =  C[2][4] - LU[0][7]*LU[4][0] - LU[1][7]*LU[4][1] - LU[2][7]*LU[4][2] - LU[3][7]*LU[4][3];
	
	  LU[5][0] =  C[0][0]/LU[0][0];
	  LU[5][1] = (C[0][1] - LU[0][1]*LU[5][0])/LU[1][1];
	  LU[5][2] = (C[0][2] - LU[0][2]*LU[5][0] - LU[1][2]*LU[5][1])/LU[2][2];
	  LU[5][3] = (C[0][3] - LU[0][3]*LU[5][0] - LU[1][3]*LU[5][1] - LU[2][3]*LU[5][2])/LU[3][3];
	  assert(LU[4][4] != 0.0);
	  LU[5][4] = (C[0][4] - LU[0][4]*LU[5][0] - LU[1][4]*LU[5][1] - LU[2][4]*LU[5][2] - LU[3][4]*LU[5][3])/LU[4][4];
	  LU[5][5] =          - LU[0][5]*LU[5][0] - LU[1][5]*LU[5][1] - LU[2][5]*LU[5][2] - LU[3][5]*LU[5][3] - LU[4][5]*LU[5][4];
	  LU[5][6] =          - LU[0][6]*LU[5][0] - LU[1][6]*LU[5][1] - LU[2][6]*LU[5][2] - LU[3][6]*LU[5][3] - LU[4][6]*LU[5][4];
	  LU[5][7] =          - LU[0][7]*LU[5][0] - LU[1][7]*LU[5][1] - LU[2][7]*LU[5][2] - LU[3][7]*LU[5][3] - LU[4][7]*LU[5][4];
	
	  LU[6][0] =  C[1][0]/LU[0][0];
	  LU[6][1] = (C[1][1] - LU[0][1]*LU[6][0])/LU[1][1];
	  LU[6][2] = (C[1][2] - LU[0][2]*LU[6][0] - LU[1][2]*LU[6][1])/LU[2][2];
	  LU[6][3] = (C[1][3] - LU[0][3]*LU[6][0] - LU[1][3]*LU[6][1] - LU[2][3]*LU[6][2])/LU[3][3];
	  LU[6][4] = (C[1][4] - LU[0][4]*LU[6][0] - LU[1][4]*LU[6][1] - LU[2][4]*LU[6][2] - LU[3][4]*LU[6][3])/LU[4][4];
	  assert(LU[5][5] != 0.0);
	  LU[6][5] = (        - LU[0][5]*LU[6][0] - LU[1][5]*LU[6][1] - LU[2][5]*LU[6][2] - LU[3][5]*LU[6][3] - LU[4][5]*LU[6][4])/LU[5][5];
	  LU[6][6] =          - LU[0][6]*LU[6][0] - LU[1][6]*LU[6][1] - LU[2][6]*LU[6][2] - LU[3][6]*LU[6][3] - LU[4][6]*LU[6][4] - LU[5][6]*LU[6][5];
	  LU[6][7] =          - LU[0][7]*LU[6][0] - LU[1][7]*LU[6][1] - LU[2][7]*LU[6][2] - LU[3][7]*LU[6][3] - LU[4][7]*LU[6][4] - LU[5][7]*LU[6][5];
	  
	  LU[7][0] =  C[2][0]/LU[0][0];
	  LU[7][1] = (C[2][1] - LU[0][1]*LU[7][0])/LU[1][1];
	  LU[7][2] = (C[2][2] - LU[0][2]*LU[7][0] - LU[1][2]*LU[7][1])/LU[2][2];
	  LU[7][3] = (C[2][3] - LU[0][3]*LU[7][0] - LU[1][3]*LU[7][1] - LU[2][3]*LU[7][2])/LU[3][3];
	  LU[7][4] = (C[2][4] - LU[0][4]*LU[7][0] - LU[1][4]*LU[7][1] - LU[2][4]*LU[7][2] - LU[3][4]*LU[7][3])/LU[4][4];
	  LU[7][5] = (        - LU[0][5]*LU[7][0] - LU[1][5]*LU[7][1] - LU[2][5]*LU[7][2] - LU[3][5]*LU[7][3] - LU[4][5]*LU[7][4])/LU[5][5];
	  assert(LU[6][6] != 0.0);
	  LU[7][6] = (        - LU[0][6]*LU[7][0] - LU[1][6]*LU[7][1] - LU[2][6]*LU[7][2] - LU[3][6]*LU[7][3] - LU[4][6]*LU[7][4] - LU[5][6]*LU[7][5])/LU[6][6];
	  LU[7][7] =          - LU[0][7]*LU[7][0] - LU[1][7]*LU[7][1] - LU[2][7]*LU[7][2] - LU[3][7]*LU[7][3] - LU[4][7]*LU[7][4] - LU[5][7]*LU[7][5] - LU[6][7]*LU[7][6];
	  assert(LU[7][7] != 0.0);
	  	
	  // check...

	  for (int i = 0; i < 8; ++i) {
	    for (int j = 0; j < 8; ++j) {
	      double coeff;
	      if (i < 5) {
		if (j < 5) {
		  coeff = A[i][j];
		}
		else {
		  coeff = C[j-5][i];
		}
	      }
	      else if (j < 5) {
		coeff = C[i-5][j];
	      }
	      else {
		coeff = 0.0;
	      }
	      // now compute the L*U...
	      {
		double l[8];
		for (int k = 0; k < i; ++k) l[k] = LU[i][k];
		l[i] = 1.0;
		for (int k = i+1; k < 8; ++k) l[k] = 0.0;
		double u[8];
		for (int k = 0; k <= j; ++k) u[k] = LU[k][j];
		for (int k = j+1; k < 8; ++k) u[k] = 0.0;
		double sum = 0.0;
		for (int k = 0; k < 8; ++k) sum += l[k]*u[k];
		//cout << coeff-sum << " ";
		if (!(fabs(coeff-sum) < 1.0E-12)) {
		  cout << "WARNING: LU problem: " << coeff-sum << endl;
		}
		//assert(fabs(coeff-sum) < 1.0E-12);
	      }
	    }
	    //cout << endl;
	  }
	  //cout << "was this matrix zero?" << endl;
	  //getchar();

	}
	else {
	  // nc == 2 or nc == 3 only
	  assert(0);
	}

	// =========================================
	// now build the coeff's...
	// =========================================

	if (icv == icv_debug) {
	  cout << "got nc: " << nc << endl;
	}

	assert(wgt0 > 0.0);
	assert(wgt1 > 0.0);
	
	double sum = 0.0;
	double nonzero_sum = 0.0;
	for (int coc = 0; coc < ncoc; ++coc) {
	  const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];
	  // overwrite rhs...
	  for (int i = 1; i < 5+nc; ++i) 
	    for (int j = 0; j < i; ++j)
	      rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	  // and back substitute to solve...
	  rhs[coc][5+nc-1] /= LU[5+nc-1][5+nc-1];
	  for (int i = 5+nc-2; i >= 4; --i) {
	    for (int j = i+1; j < 5+nc; ++j)
	      rhs[coc][i] -= LU[i][j]*rhs[coc][j];
	    rhs[coc][i] /= LU[i][i];
	  }
	  // the coeff is in rhs[coc][4]...
	  sum += rhs[coc][4]; 
	  if (fabs(rhs[coc][4]) < coeff_zero) {
	    rhs[coc][4] = 0.0;
	  }
	  else {
	    nonzero_sum += rhs[coc][4];
	  }
          /*
	  if (icv == icv_debug) {
	    cout << "coc: " << coc << " rhs: " << rhs[coc][4] << " at dx: " << 
	      x_cv[icv_nbr][0]-x_cv[icv][0] << " " << 
	      x_cv[icv_nbr][1]-x_cv[icv][1] << " " << 
	      x_cv[icv_nbr][2]-x_cv[icv][2] << endl;
	  }
          */
	}
	if (fabs(sum-1.0) > 1.0E-12) {
	  cout << "WARNING: non-zero sum in coeffs: " << sum-1.0 << endl;
	}
	//assert(fabs(sum-1.0) < 1.0E-12);
	assert(nonzero_sum != 0.0);
	
        //======================================================
        // stb pt 2.. now we need to compute the solution based 
        // on our null space approach..
        //======================================================
        /*
        if (nc == 2) {

          for (int coc = 0, ncoc = cvocv_i[icv+1]-cvocv_i[icv]; coc < ncoc; ++coc) { 
            if ( (abs(rhs_cpy[coc][5]) < 1.0e-12) && ( abs(rhs_cpy[coc][6]) < 1.0e-12)) { 
              
              // for these cases where the constraint vectors are in fact 0
              // then we do not need a particular solution and can proceed..
              double rhs_thin[3];
              for (int j = 0; j <3 ; ++j) { 
                rhs_thin[j] = 0.0;
                for (int i = 0; i < 5; ++i) { 
                  rhs_thin[j] += Q(i,j+2)*rhs_cpy[coc][i];
                }
              }

              // solve T[z] = rhs_thin ; note we've already computed the cholesky factorization of T..
              {
                //char uplo='l';
                //int nn   = 3;
                //int nrhs = 1;
                //int info;
                //dpotrs_(&uplo,&nn,&nrhs,T,&nn,rhs_thin,&nn,&info);

                //if ( info != 0 )
                  //assert(0);

                cholesky_solve(rhs_thin,L,3);
                //cholesky_solve(rhs_thin,T,3);
                
                // and now check the solution.. i need x[4].. 
                double sol = Q(4,2)*rhs_thin[0] + Q(4,3)*rhs_thin[1] + Q(4,4)*rhs_thin[2];

                if ( icv == icv_debug) { 
                  cout << "check1: " << sol << "   " << rhs[coc][4] << "   " << abs(sol-rhs[coc][4]) << endl;
                }

              }
            } else { 
              
              // solve a 2x2 system for the particular solution.. 
              double a[2];
              a[0] = zeta_inv[0]*rhs_cpy[coc][5] + zeta_inv[2]*rhs_cpy[coc][6];
              a[1] = zeta_inv[1]*rhs_cpy[coc][5] + zeta_inv[3]*rhs_cpy[coc][6];

              double xhat[5]; 
              for (int i =0; i <5; ++i) 
                xhat[i] = a[0]*C[0][i] + a[1]*C[1][i];
              

              double tmp[2] = {0.0,0.0};
              for (int i =0; i <5; ++i) {
                tmp[0] += C[0][i]*xhat[i];
                tmp[1] += C[1][i]*xhat[i];
              }

              double Axhat[5];
              for (int i =0; i < 5; ++i) { 
                Axhat[i] = 0.0;
                for (int j =0; j < 5; ++j) 
                  Axhat[i] += A[i][j]*xhat[j];
              }

              //if ( icv == icv_debug) { 
              //  cout << " checking constrained neighbor.. " << endl;
              //  cout << tmp[0] << "   " << rhs_cpy[coc][5] << "   " << abs(tmp[0] - rhs_cpy[coc][5]) << endl;
              //  cout << tmp[1] << "   " << rhs_cpy[coc][6] << "   " << abs(tmp[1] - rhs_cpy[coc][6]) << endl;

              //  cout << "Axhat.. " << endl;
              //  for (int i =0; i <5 ; ++i) { 
              //    double blah = a[0]*theta0[i] + a[1]*theta1[i];
              //    cout << "[ " << i << "]  " << Axhat[i] << "   " << blah << "   " << abs(Axhat[i]-blah) << endl;
              //  }
              //  cout << "...." << endl;

              //  getchar();
             // }

              // now include the particular solution...
              double rhs_thin[3];
              for (int j = 0; j <3 ; ++j) { 
                rhs_thin[j] = 0.0;
                for (int i = 0; i < 5; ++i) { 
                  //rhs_thin[j] += Q(i,j+2)*(rhs_cpy[coc][i] - Axhat[i]);
                  rhs_thin[j] += Q(i,j+2)*(rhs_cpy[coc][i] - a[0]*theta0[i] - a[1]*theta1[i]);
                }
              }
              
              // solve T[z] = rhs_thin ; note we've already computed the cholesky factorization of T..
              {
                //char uplo='l';
                //int nn   = 3;
                //int nrhs = 1;
                //int info;
                //dpotrs_(&uplo,&nn,&nrhs,T,&nn,rhs_thin,&nn,&info);
                
                //if ( info != 0 )
                //  assert(0);

                cholesky_solve(rhs_thin,L,3);
                //cholesky_solve(rhs_thin,T,3);

                // and now check the solution.. i need x[4].. 
                double sol = Q(4,2)*rhs_thin[0] + Q(4,3)*rhs_thin[1] + Q(4,4)*rhs_thin[2];
                //sol += xhat[4]; // the particular solution..
                sol += a[0]*C[0][4] + a[1]*C[1][4];

                if ( icv == icv_debug) { 
                  cout << " check2: " << sol << "   " << rhs[coc][4] << "   " << abs(sol-rhs[coc][4]) << endl;
                }
              }
              
            }
          }

        }
        else if (nc == 3) {

          for (int coc = 0, ncoc = cvocv_i[icv+1]-cvocv_i[icv]; coc < ncoc; ++coc) { 
            if ( (abs(rhs_cpy[coc][5]) < 1.0e-12) && ( abs(rhs_cpy[coc][6]) < 1.0e-12)&& ( abs(rhs_cpy[coc][7]) < 1.0e-12)) { 
              
              // for these cases where the constraint vectors are in fact 0
              // then we do not need a particular solution and can proceed..
              double rhs_thin[2];
              for (int j = 0; j < 2 ; ++j) { 
                rhs_thin[j] = 0.0;
                for (int i = 0; i < 5; ++i) { 
                  rhs_thin[j] += Q(i,j+3)*rhs_cpy[coc][i];
                }
              }

              // solve T[z] = rhs_thin ; note we've already computed the cholesky factorization of T..
              {
                //char uplo='l';
                //int nn   = 3;
                //int nrhs = 1;
                //int info;
                //dpotrs_(&uplo,&nn,&nrhs,T,&nn,rhs_thin,&nn,&info);

                //if ( info != 0 )
                  //assert(0);

                cholesky_solve(rhs_thin,L,2);
                //cholesky_solve(rhs_thin,T,3);
                
                // and now check the solution.. i need x[4].. 
                double sol = Q(4,3)*rhs_thin[0] + Q(4,4)*rhs_thin[1]; 

                if ( icv == icv_debug) { 
                  cout << "check1: " << sol << "   " << rhs[coc][4] << "   " << abs(sol-rhs[coc][4]) << endl;
                }

              }
            } else { 
              
              // solve a 3x3 system for the particular solution.. 
              double a[3];
              a[0] = zeta_inv[0]*rhs_cpy[coc][5] + zeta_inv[1]*rhs_cpy[coc][6] + zeta_inv[2]*rhs_cpy[coc][7];
              a[1] = zeta_inv[3]*rhs_cpy[coc][5] + zeta_inv[4]*rhs_cpy[coc][6] + zeta_inv[5]*rhs_cpy[coc][7];
              a[2] = zeta_inv[6]*rhs_cpy[coc][5] + zeta_inv[7]*rhs_cpy[coc][6] + zeta_inv[8]*rhs_cpy[coc][7];

              double xhat[5]; 
              for (int i =0; i <5; ++i) 
                xhat[i] = a[0]*C[0][i] + a[1]*C[1][i] + a[2]*C[2][i];
              

              double tmp[3] = {0.0,0.0,0.0};
              for (int i =0; i <5; ++i) {
                tmp[0] += C[0][i]*xhat[i];
                tmp[1] += C[1][i]*xhat[i];
                tmp[2] += C[2][i]*xhat[i];
              }

              double Axhat[5];
              for (int i =0; i < 5; ++i) { 
                Axhat[i] = 0.0;
                for (int j =0; j < 5; ++j) 
                  Axhat[i] += A[i][j]*xhat[j];
              }

              
             // if ( icv == icv_debug) { 
             //   cout << " checking constrained neighbor.. " << endl;
             //   cout << tmp[0] << "   " << rhs_cpy[coc][5] << "   " << abs(tmp[0] - rhs_cpy[coc][5]) << endl;
             //   cout << tmp[1] << "   " << rhs_cpy[coc][6] << "   " << abs(tmp[1] - rhs_cpy[coc][6]) << endl;

              //  cout << "Axhat.. " << endl;
              //  for (int i =0; i <5 ; ++i) { 
             //     double blah = a[0]*theta0[i] + a[1]*theta1[i];
             //     cout << "[ " << i << "]  " << Axhat[i] << "   " << blah << "   " << abs(Axhat[i]-blah) << endl;
             //   }
             //   cout << "...." << endl;

             //   getchar();
             // }

              // now include the particular solution...
              double rhs_thin[2];
              for (int j = 0; j < 2 ; ++j) { 
                rhs_thin[j] = 0.0;
                for (int i = 0; i < 5; ++i) { 
                  //rhs_thin[j] += Q(i,j+2)*(rhs_cpy[coc][i] - Axhat[i]);
                  rhs_thin[j] += Q(i,j+3)*(rhs_cpy[coc][i] - a[0]*theta0[i] - a[1]*theta1[i] - a[2]*theta2[i]);
                }
              }
              
              // solve T[z] = rhs_thin ; note we've already computed the cholesky factorization of T..
              {
                //char uplo='l';
                //int nn   = 3;
                //int nrhs = 1;
                //int info;
                //dpotrs_(&uplo,&nn,&nrhs,T,&nn,rhs_thin,&nn,&info);
                
                //if ( info != 0 )
                //  assert(0);

                cholesky_solve(rhs_thin,L,2);
                //cholesky_solve(rhs_thin,T,3);

                // and now check the solution.. i need x[4].. 
                double sol = Q(4,3)*rhs_thin[0] + Q(4,4)*rhs_thin[1];
                //sol += xhat[4]; // the particular solution..
                sol += a[0]*C[0][4] + a[1]*C[1][4] + a[2]*C[2][4];

                if ( icv == icv_debug) { 
                  cout << " check2: " << sol << "   " << rhs[coc][4] << "   " << abs(sol-rhs[coc][4]) << endl;
                }
              }
              
            }
          }

        }
        else {
          assert(0);
        }
        */
        

        //======================================================
        // end stb pt 2
        //======================================================

	// the weighting associated with this face is motivated by the
	// optimal higher-order weight from the 1-d problem of:
	// (dxR+dxRR)/(dxLL+dxL+dxR+dxRR)
	// note that we clip it to the range 0.25..0.75. In the future
	// we may want to do something with this wgt to minimize symmetry.

	//const double wgt = max(0.25,min(0.75,wgt1/(wgt0+wgt1)));
	const double wgt = 0.5;
	
        /*
	assert(mpi_size == 1);
	double x_check[3] = { 0.0, 0.0, 0.0 };
	
	FILE * fp = fopen("check.dat","w");
	fprintf(fp,"%18.15le %18.15le %18.15le\n",fa[ifa].x[0],fa[ifa].x[1],fa[ifa].x[2]);

	FILE * fp2 = fopen("vor.dat","w");
	fprintf(fp2,"TITLE = \"%s\"\n","debug.dat");
	fprintf(fp2,"VARIABLES = \"X\"\n");
	fprintf(fp2,"\"Y\"\n");
	fprintf(fp2,"\"Z\"\n");
        */

	for (int coc = 0; coc < ncoc; ++coc) {
	  if (rhs[coc][4] != 0.0) {
	    const int icv_nbr = cvocv_v[coc+cvocv_i[icv]];

	    uint8 rbi_nbr;
	    if (icv_nbr < ncv) {
	      rbi_nbr = BitUtils::packRankBitsIndex(mpi_rank,0,icv_nbr);
	    }
	    else {
	      rbi_nbr = rbi_g[icv_nbr-ncv];
	    }
	    
	   // assert(icv_nbr < ncv);
	   // FOR_I3 x_check[i] += rhs[coc][4]/nonzero_sum*x_cv[icv_nbr][i];
	   // fprintf(fp,"%18.15le %18.15le %18.15le\n",x_cv[icv_nbr][0],x_cv[icv_nbr][1],x_cv[icv_nbr][2]);
	   // voronoiPart->writeFullCvTecplotZone(fp2,icv_nbr,voronoiPart->points->xp[icv_nbr]);
	    
	    double coeff[3];
	    FOR_I3 coeff[i] = rhs[coc][4]/nonzero_sum*wgt*fa_sign*fa[ifa].area*fa[ifa].unit_n[i];
	    coeffVec.push_back(Coeff(rbi,rbi_nbr,coeff));
	    FOR_I3 coeff[i] = -coeff[i];
	    coeffVec.push_back(Coeff(rbi_fa_nbr,rbi_nbr,coeff));
	  }
	}

        /*
	fprintf(fp,"%18.15le %18.15le %18.15le\n",x_check[0],x_check[1],x_check[2]);
	fclose(fp);
	fclose(fp2);
	
	// compare x_check and fa[ifa].x...
	cout << "x_check: " << COUT_VEC(x_check) << " fa[ifa].x: " << COUT_VEC(fa[ifa].x) << " dist: " << DIST(x_check,fa[ifa].x) << endl;
	//getchar();
        */
	
      } // face loop
    } // icv loop

    delete[] rhs;
    delete[] send_buf_double; send_buf_double = NULL;

    sort(coeffVec.begin(),coeffVec.end());

    // compress...
    
    int nii_new = 0;
    for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
      assert(!coeffVec[ii].transpose);
      if ((nii_new == 0)||(coeffVec[ii].rbi != coeffVec[nii_new-1].rbi)||(coeffVec[ii].rbi_nbr != coeffVec[nii_new-1].rbi_nbr)) {
	coeffVec[nii_new].rbi     = coeffVec[ii].rbi;
	coeffVec[nii_new].rbi_nbr = coeffVec[ii].rbi_nbr;
	FOR_I3 coeffVec[nii_new].coeff[i] = coeffVec[ii].coeff[i];
	++nii_new;
      }
      else {
	FOR_I3 coeffVec[nii_new-1].coeff[i] += coeffVec[ii].coeff[i];
      }
    }
    
    // ==============================================
    // hack -- check serial gradient...
    // ==============================================
    
    /*{

      assert(mpi_size == 1);
      assert(ncv_g == ncv);
      assert(ncv_g2 == ncv);

      const double grad_check[3] = { 1.1234, -1.3243, 1.5321 }; // some order-1 gradient
      //const double grad_check[3] = { 1.0, 1.0, 1.0 }; 
    
      double * phi = new double[ncv_g2];
      for (int icv = 0; icv < ncv_g2; ++icv) 
	phi[icv] = DOT_PRODUCT(x_cv[icv],grad_check);
    
      double (*grad_phi)[3] = new double[ncv][3];
      FOR_ICV FOR_I3 grad_phi[icv][i] = 0.0;
    
      for (int icv = 0; icv < ncv; ++icv) {
	FOR_I3 grad_phi[icv][i] /= vol_cv[icv]*grad_check[i]; // to produce 1
      }
    
      dumpRange(grad_phi,ncv,"extended grad");
    
      delete[] grad_phi;
      delete[] phi;
      
      MPI_Pause("OKOK");
      

    }
    */
















    // and add transpose...

    coeffVec.resize(nii_new*2);
    for (int ii=0; ii < nii_new;  ++ii) {
      coeffVec[nii_new+ii].rbi             = coeffVec[ii].rbi_nbr;
      coeffVec[nii_new+ii].rbi_nbr         = coeffVec[ii].rbi;
      FOR_I3 coeffVec[nii_new+ii].coeff[i] = coeffVec[ii].coeff[i];
      coeffVec[nii_new+ii].transpose       = true;
    }
    
    // now exchange parallel parts...

    FOR_RANK send_count[rank] = 0;

    for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
      int rank,bits,icv;
      BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
      if (rank != mpi_rank)
	++send_count[rank];
    }
    
    send_disp[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      send_disp[rank] = send_disp[rank-1] + send_count[rank-1];
    send_count_sum = send_disp[mpi_size-1] + send_count[mpi_size-1];
    
    uint8 * send_buf_uint8 = new uint8[send_count_sum*2];
    assert(send_buf_double == NULL); send_buf_double = new double[send_count_sum*3];
    
    int ii_new = 0;
    for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
      int rank,bits,icv;
      BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
      assert(bits == 0);
      if (rank != mpi_rank) {
	// since the row's bits are ALWAYS zero, use them to store the transpose bool... 
	if (coeffVec[ii].transpose) 
	  send_buf_uint8[send_disp[rank]*2  ] = BitUtils::packRankBitsIndex(rank,1,icv);
	else
	  send_buf_uint8[send_disp[rank]*2  ] = coeffVec[ii].rbi;
	// and the column...
	send_buf_uint8[send_disp[rank]*2+1] = coeffVec[ii].rbi_nbr;
	// and the coeff...
	FOR_I3 send_buf_double[send_disp[rank]*3+i] = coeffVec[ii].coeff[i];
	++send_disp[rank];
      }
      else {
	if (ii_new != ii) coeffVec[ii_new].copy(coeffVec[ii]);
	++ii_new;
      }
    }
    
    // rewind send_disp...
    
    send_disp[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      send_disp[rank] = send_disp[rank-1] + send_count[rank-1];
    
    // setup recv side...
    
    MPI_Alltoall(send_count,1,MPI_INT,recv_count,1,MPI_INT,mpi_comm);
    
    recv_disp[0] = 0;
    for (int rank = 1; rank < mpi_size; ++rank)
      recv_disp[rank] = recv_count[rank-1] + recv_disp[rank-1];
    recv_count_sum = recv_disp[mpi_size-1] + recv_count[mpi_size-1];
    
    coeffVec.resize(ii_new+recv_count_sum);
    
    FOR_RANK {
      send_count[rank] *= 2;
      send_disp[rank] *= 2;
      recv_count[rank] *= 2;
      recv_disp[rank] *= 2;
    }
    
    uint8 * recv_buf_uint8 = new uint8[recv_count_sum*2];
    MPI_Alltoallv(send_buf_uint8,send_count,send_disp,MPI_UINT8,
		  recv_buf_uint8,recv_count,recv_disp,MPI_UINT8,mpi_comm);
    delete[] send_buf_uint8; 
    
    FOR_RANK {
      send_count[rank] = (send_count[rank]/2)*3;
      send_disp[rank]  = (send_disp[rank]/2)*3;
      recv_count[rank] = (recv_count[rank]/2)*3;
      recv_disp[rank]  = (recv_disp[rank]/2)*3;
    }
    
    assert(recv_buf_double == NULL); recv_buf_double = new double[recv_count_sum*3];
    MPI_Alltoallv(send_buf_double,send_count,send_disp,MPI_DOUBLE,
		  recv_buf_double,recv_count,recv_disp,MPI_DOUBLE,mpi_comm);
    delete[] send_buf_double;

    // unpack...
    
    for (int irecv = 0; irecv < recv_count_sum; ++irecv) {
      int rank,bits,icv;
      BitUtils::unpackRankBitsIndex(rank,bits,icv,recv_buf_uint8[irecv*2]);
      assert(rank == mpi_rank);
      if (bits == 1) {
	coeffVec[ii_new].rbi = BitUtils::packRankBitsIndex(rank,0,icv); 
	coeffVec[ii_new].transpose = true;
      }
      else {
	assert(bits == 0);
	coeffVec[ii_new].rbi = recv_buf_uint8[irecv*2];
	coeffVec[ii_new].transpose = false;
      }
      // and the nbr...
      coeffVec[ii_new].rbi_nbr = recv_buf_uint8[irecv*2+1];
      // and the coeff...
      FOR_I3 coeffVec[ii_new].coeff[i] = recv_buf_double[irecv*3+i];
      ++ii_new;
    }

    assert(ii_new == coeffVec.size());
    delete[] recv_buf_double;
    delete[] recv_buf_uint8;

    delete[] recv_disp;
    delete[] recv_count;
    delete[] send_disp;
    delete[] send_count;
    
    // final sort...
    
    sort(coeffVec.begin(),coeffVec.end());
    
    // now build HO faces [0:nfa2)...
    // first count...
    
    nfa_i2 = 0;
    int nfa_b2 = 0;    
    uint8 rbi_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv); // does not exist
    uint8 rbi_nbr_current = rbi_current;
    int ncv_check = 0;
    int icv;
    for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
      if (coeffVec[ii].rbi != rbi_current) {
	rbi_current = coeffVec[ii].rbi;
	int rank,bits;
	BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
	assert(rank == mpi_rank);
	assert(bits == 0);
	assert(icv == ncv_check); // because of sort, should be monotonic in icv
	++ncv_check;
	rbi_nbr_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv);
      }
      if (coeffVec[ii].rbi != coeffVec[ii].rbi_nbr) {
	if (coeffVec[ii].rbi_nbr != rbi_nbr_current) {
	  rbi_nbr_current = coeffVec[ii].rbi_nbr;
	  int rank_nbr,bits_nbr,icv_nbr;
	  BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,icv_nbr,coeffVec[ii].rbi_nbr);
	  if ((rank_nbr == mpi_rank)&&(bits_nbr == 0)) {
	    // only count a new internal face when its index is larger than ours...
	    assert(icv_nbr != icv);
	    if (icv_nbr > icv)
	      ++nfa_i2;
	  }
	  else {
	    ++nfa_b2;
	  }
	}
      }
    }
    assert(ncv_check == ncv);
    
    nfa2 = nfa_i2+nfa_b2;
    //cout << "nfa_i2: " << nfa_i2 << " nfa_b2: " << nfa_b2 << " average nfa2/cv: " << double(nfa2)/double(ncv) << endl;
    
    assert(cvofa2 == NULL); cvofa2 = new int[nfa2][2];
    assert(fa2 == NULL); fa2 = new FaBase[nfa2];

    // build a map that relates rbi to the ghost index...
    map<const uint8,int> rbiMap;
    for (int icv = ncv; icv < ncv_g; ++icv)
      rbiMap[rbi_g[icv-ncv]] = icv;

    ncv_g2 = ncv_g;
    
    // these are used temporarily to lookup faces...
    int * faocv_i2 = new int[ncv+1];
    int * faocv_v2 = new int[nfa_i2]; // internal outward faces only for this temporary lookup
    
    faocv_i2[0] = 0;
    nfa_b2 = nfa_i2;
    nfa_i2 = 0;
    int ifa2;
    double fa2_sign;
    rbi_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv); // does not exist
    rbi_nbr_current = rbi_current;
    ncv_check = 0;
    for (int ii=0,nii=coeffVec.size(); ii < nii;  ++ii) {
      if (coeffVec[ii].rbi != rbi_current) {
	rbi_current = coeffVec[ii].rbi;
	int rank,bits;
	BitUtils::unpackRankBitsIndex(rank,bits,icv,coeffVec[ii].rbi);
	assert(rank == mpi_rank);
	assert(bits == 0);
	assert(icv == ncv_check); // because of sort, should be monotonic in icv
	++ncv_check;
	faocv_i2[icv+1] = faocv_i2[icv];
	rbi_nbr_current = BitUtils::packRankBitsIndex(mpi_rank,0,ncv);
      }
      if (coeffVec[ii].rbi != coeffVec[ii].rbi_nbr) {
	// off-diagonal coeff...
	if (coeffVec[ii].rbi_nbr != rbi_nbr_current) {
	  rbi_nbr_current = coeffVec[ii].rbi_nbr;
	  int rank_nbr,bits_nbr,icv_nbr;
	  BitUtils::unpackRankBitsIndex(rank_nbr,bits_nbr,icv_nbr,coeffVec[ii].rbi_nbr);
	  if ((rank_nbr == mpi_rank)&&(bits_nbr == 0)) {
	    // only count a new internal face when its index is larger than ours...
	    assert(icv_nbr != icv);
	    if (icv_nbr > icv) {
	      // this is a new face...
	      ifa2 = nfa_i2++;
	      fa2_sign = 1.0;
	      faocv_v2[faocv_i2[icv+1]] = ifa2;
	      ++faocv_i2[icv+1];
	      cvofa2[ifa2][0] = icv;
	      cvofa2[ifa2][1] = icv_nbr;
	    }
	    else {
	      // this should be an existing face already associated with the lower cv...
	      int foc_nbr;
	      for (foc_nbr = faocv_i2[icv_nbr]; foc_nbr != faocv_i2[icv_nbr+1]; ++foc_nbr) {
		ifa2 = faocv_v2[foc_nbr];
		if ((cvofa2[ifa2][0] == icv_nbr)&&(cvofa2[ifa2][1] == icv))
		  break;
	      }
	      assert(foc_nbr != faocv_i2[icv_nbr+1]); // make sure we found one...
	      fa2_sign = -1.0; // flip sign
	    }
	  }
	  else {
	    assert(bits_nbr == 0);
	    assert(rank_nbr != mpi_rank);
	    // this is always a new outward-pointing face...
	    ifa2 = nfa_b2++;
	    fa2_sign = 2.0;
	    cvofa2[ifa2][0] = icv;
	    // figure out the ghost index associated with this rbi_nbr...
	    map<const uint8,int>::const_iterator iter = rbiMap.find(coeffVec[ii].rbi_nbr);
	    if (iter == rbiMap.end()) {
	      rbiMap[coeffVec[ii].rbi_nbr] = cvofa2[ifa2][1] = ncv_g2++;
	    }
	    else {
	      cvofa2[ifa2][1] = iter->second;
	    }
	  }
	}
	// we should have ifa2 and fa2_sign set...
	// 0.5*(D-DT) goes in unit_n (area-weighted normal for now)...
	if (coeffVec[ii].transpose) {
	  FOR_I3 fa2[ifa2].unit_n[i] -= 0.5*fa2_sign*coeffVec[ii].coeff[i];
	}
	else {
	  FOR_I3 fa2[ifa2].unit_n[i] += 0.5*fa2_sign*coeffVec[ii].coeff[i];
	}
	// 0.5*(D+DT) goes in c[i] - note that this part is independent of the orientation of the face (i.e. not
	// dependent on fa2_sign). ...
	if (fa2_sign == 2.0) {
	  // inter-processor face...
	  FOR_I3 fa2[ifa2].c[i] += coeffVec[ii].coeff[i];
	}
	else {
	  FOR_I3 fa2[ifa2].c[i] += 0.5*coeffVec[ii].coeff[i];
	}
      }
    }
    assert(ncv_check == ncv);
    assert(nfa_b2 == nfa2);
    
    delete[] faocv_i2;
    delete[] faocv_v2;

    // finally normalize the faces...
    
    for (int ifa2 = 0; ifa2 < nfa2; ++ifa2) {
      assert(fa2[ifa2].area == 0.0);
      fa2[ifa2].area = MAG(fa2[ifa2].unit_n);
      if (fa2[ifa2].area > 0.0)
	FOR_I3 fa2[ifa2].unit_n[i] /= fa2[ifa2].area;
      else 
	FOR_I3 fa2[ifa2].unit_n[i] = 0.0;
    }
    
    assert(ncv_g2-ncv == rbiMap.size());
    int * cv_flag_g2 = new int[ncv_g2-ncv];
    assert(rbi_g2 == NULL); rbi_g2 = new uint8[ncv_g2-ncv_g];
    int icv2 = ncv_g;
    for (map<const uint8,int>::const_iterator iter = rbiMap.begin(); iter != rbiMap.end(); ++iter) {
      if (iter->second >= ncv_g) {
	rbi_g2[icv2-ncv_g] = iter->first;
	cv_flag_g2[iter->second-ncv_g] = icv2++;
      }
    }
    assert(icv2 == ncv_g2);
    rbiMap.clear();
    
    // modify the references to cvofa2 in the second ghost range...
    
    for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
      const int icv_nbr = cvofa2[ifa2][1];
      if (icv_nbr >= ncv_g) {
	assert(icv_nbr < ncv_g2);
	cvofa2[ifa2][1] = cv_flag_g2[icv_nbr-ncv_g];
      }
    }
    
    delete[] cv_flag_g2;

    // ---------------------------------------------------
    // finally, copy the compact area_over_delta into
    // the extended area_over_delta for matched faces
    // so the viscous closure will work as well...
    // ---------------------------------------------------
    
    for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
      assert(fa2[ifa2].area_over_delta == 0.0);
      const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
      const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
      assert(icv1 > icv0);
      if (icv1 < ncv_g) {
	// this face has an internal or level-1 ghost neighbor, so there MAY
	// be a compact face with the same 1cv0->icv1 pair...
	for (int foc = faocv_i[icv]; foc != faocv_i[icv+1]; ++foc) {
	  const int ifa = faocv_v[foc];
	  assert(cvofa[ifa][1] > cvofa[ifa][0]);
	  if ((icv0 == cvofa[ifa][0])&&(icv1 == cvofa[ifa][1])) {
	    fa2[ifa2].area_over_delta = fa[ifa].area_over_delta;
	    break;
	  }
	}
      }
    }

    {
      int8 my_count[5] = { ncv, nfa_i, nfa-nfa_i, nfa_i2, nfa2-nfa_i2 };
      int8 count[5];
      MPI_Reduce(my_count,count,5,MPI_INT8,MPI_SUM,0,mpi_comm);
      if (mpi_rank == 0) {
	// the boundary faces should be doubled (i.e. represented on both ranks)...
	assert(count[2]%2 == 0);
	assert(count[4]%2 == 0);
	cout << " > global ncv: " << count[0] << 
	  " nfa: " << count[1]+count[2]/2 << 
	  " nfa/ncv: " << double(count[1]+count[2]/2)/double(count[0]) << 
	  " nfa2: " << count[3]+count[4]/2 << 
	  " nfa2/ncv: " << double(count[3]+count[4]/2)/double(count[0]) << 
	  " nfa2/nfa: " << double(count[3]+count[4]/2)/double(count[1]+count[2]/2) << endl; 
      }
    }
      
  }

#include "undef_coeff.hpp"

private:

  void setFaceVectors(double e0[3],double e1[3],double e2[3],double& fa_sign,const int ifa,const int icv) {

    // we want to produce a normalization that leads to O(1) values for
    // the coordinate points used in integrations/quadrature, so divide the unit normal
    // by a characteristic length scale. Here we use the points->delta, 
    
    assert((icv >= 0)&&(icv < ncv));

    const double inv_L = 1.0/voronoiPart->points->delta[icv];
    
    if (cvofa[ifa][0] == icv) {
      // face is already outward-pointing with respect to icv...
      FOR_I3 e0[i] = fa[ifa].unit_n[i]*inv_L;
      fa_sign = 1.0;
    }
    else {
      assert(cvofa[ifa][1] == icv);
      // face is inward pointing, so reverse e0...
      FOR_I3 e0[i] = -fa[ifa].unit_n[i]*inv_L;
      fa_sign = -1.0;
    }
    
    if (fabs(e0[0]) <= min(fabs(e0[1]),fabs(e0[2]))) {
      // the x-direction of the normal is the smallest, so use [1,0,0] to cross the 
      // normal and produce e1...
      e1[0] = 0.0;
      e1[1] = e0[2];
      e1[2] = -e0[1];
    }
    else if (fabs(e0[1]) <= fabs(e0[2])) {
      // the y-direction of the normal is the smallest, so use [0,1,0] to cross the 
      // normal and produce e1...
      e1[0] = -e0[2];
      e1[1] = 0.0;
      e1[2] = e0[0];
    }
    else {
      // the z-direction of the normal is the smallest, so use [0,0,1] to cross the 
      // normal and produce e1...
      e1[0] = e0[1];
      e1[1] = -e0[0];
      e1[2] = 0.0;
    }
    const double mag = MAG(e1);
    FOR_I3 e1[i] *= inv_L/mag;
    
    // note e0 and e1 are already orthogonal and of mag inv_L, so the
    // cross will have mag inv_L**2, so just divide out inv_L once...
    
    const double e2_[3] = CROSS_PRODUCT(e0,e1);
    FOR_I3 e2[i] = e2_[i]/inv_L;

  }

  void checkGclExtended() {

    COUT1("StaticSolver::checkGclExtended()");

    assert(fa2);

    double (*gcl)[3] = new double[ncv][3];
    FOR_ICV FOR_I3 gcl[icv][i] = 0.0;
    
    for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
      const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
      const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= 0)&&(icv1 < ncv));
      assert(icv1 > icv0);
      FOR_I3 gcl[icv0][i] += fa2[ifa2].area*fa2[ifa2].unit_n[i];
      FOR_I3 gcl[icv1][i] -= fa2[ifa2].area*fa2[ifa2].unit_n[i];
    }

    for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
      const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
      const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
      assert(icv1 > icv0);
      FOR_I3 gcl[icv0][i] += fa2[ifa2].area*fa2[ifa2].unit_n[i];
    }
    
    // all boundaries are outward-pointing...
    FOR_ICV {
      for (int boc = bfocv_i[icv]; boc != bfocv_i[icv+1]; ++boc) {
	const int ibf = bfocv_v[boc];
	FOR_I3 gcl[icv][i] += bf[ibf].area*bf[ibf].unit_n[i];
      }
    }

    /*
      {
      char filename[128];
      sprintf(filename,"gcl.%03d.dat",mpi_rank);
      FILE * fp = fopen(filename,"w");
      FOR_ICV {
      fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
      x_cv[icv][0],x_cv[icv][1],x_cv[icv][2],
      gcl[icv][0],gcl[icv][1],gcl[icv][2]);
      }
      fclose(fp);
      }
    */

    dumpRange(gcl,ncv,"GCL (should be small)");
    
    delete[] gcl;
    
  }

  void checkGradExtended() {
    
    COUT1("StaticSolverOps::checkGradExtended()");
    
    //assert(b_cv2Prcomm);
    
    const double grad_check[3] = { 1.1234, -1.3243, 1.5321 }; // some order-1 gradient
    //const double grad_check[3] = { 1.0, 1.0, 1.0 }; 
    
    double * phi = new double[ncv_g2];
    for (int icv = 0; icv < ncv_g2; ++icv) 
      phi[icv] = DOT_PRODUCT(x_cv[icv],grad_check);
    
    double (*grad_phi)[3] = new double[ncv][3];
    FOR_ICV FOR_I3 grad_phi[icv][i] = 0.0;
    
    for (int ifa2 = 0; ifa2 < nfa_i2; ++ifa2) {
      const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
      const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= 0)&&(icv1 < ncv));
      double flux[3];	FOR_I3 flux[i] = 0.5*fa2[ifa2].area*fa2[ifa2].unit_n[i]*(phi[icv0]+phi[icv1]) + 0.5*fa2[ifa2].c[i]*(phi[icv1]-phi[icv0]);
      FOR_I3 grad_phi[icv0][i] += flux[i];
      FOR_I3 grad_phi[icv1][i] -= flux[i];
    }
      
    for (int ifa2 = nfa_i2; ifa2 < nfa2; ++ifa2) {
      const int icv0 = cvofa2[ifa2][0]; assert((icv0 >= 0)&&(icv0 < ncv));
      const int icv1 = cvofa2[ifa2][1]; assert((icv1 >= ncv)&&(icv1 < ncv_g2));
      double flux[3];	FOR_I3 flux[i] = 0.5*fa2[ifa2].area*fa2[ifa2].unit_n[i]*(phi[icv0]+phi[icv1]) + 0.5*fa2[ifa2].c[i]*(phi[icv1]-phi[icv0]);
      FOR_I3 grad_phi[icv0][i] += flux[i];
    }
    
    // and close the gradient at the boundary...
    
    for (int ibf = 0; ibf < nbf; ++ibf) {
      const int icv = cvobf[ibf];
      const double phi_bf = DOT_PRODUCT(bf[ibf].x,grad_check);
      FOR_I3 grad_phi[icv][i] += phi_bf*bf[ibf].area*bf[ibf].unit_n[i];
    }
      
    for (int icv = 0; icv < ncv; ++icv) {
      FOR_I3 grad_phi[icv][i] /= vol_cv[icv]*grad_check[i]; // to produce 1
    }
    
    dumpRange(grad_phi,ncv,"extended grad");
    
    FILE * fp = fopen("grad.dat","w");
    FOR_ICV {
      fprintf(fp,"%18.15le %18.15le %18.15le %18.15le %18.15le %18.15le\n",
	      x_cv[icv][0],x_cv[icv][1],x_cv[icv][2],
	      grad_phi[icv][0],grad_phi[icv][1],grad_phi[icv][2]);
    }
    fclose(fp);
    
    delete[] grad_phi;
    delete[] phi;
    
    //MPI_Pause("OKOK");
  
  }


};


