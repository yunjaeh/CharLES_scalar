
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <string>
#include <assert.h>
#include "Defs.hpp"
#include "Adt.hpp"
#include "ByteSwap.hpp"

using namespace std;

namespace SurfVarNames {

  string pressure_var_name = "proj(p)";
  string delta_var_name    = "proj(r_vv)";
};

//===========================================================================
// the sles file that we are operating on can be generated by a command
//
//WRITE_SNAPSHOT NAME surf_snap VARS WING:x_bf() WING:proj(r_vv) WING:proj(p)
//
//==========================================================================

class WingSection {
public:
  double xs[3];
  double chord;
  double eta;

  WingSection() {

    xs[0] = 0.0;
    xs[1] = 0.0;
    xs[2] = 0.0;
    chord = 0.0;
    eta   = 0.0;

  }

  WingSection(const double _x, const double _y, const double _z,
              const double _c, const double _eta) {

    xs[0] = _x;
    xs[1] = _y;
    xs[2] = _z;
    chord = _c;
    eta   = _eta;

  }

  void convertToScaleMeters() {

    // ran the scaled lab model in meters...
    const double fax = 0.0006861131255;
    for (int i = 0; i < 3; ++i)
      xs[i] *= fax;
    chord *= fax;

    // eta is a non-dimensional measure...no scaling required.
  }

};


string extract_zone_name(const string& hdr_str) {
  size_t colon_found = hdr_str.find(":");
  assert( colon_found != string::npos);
  return hdr_str.substr(0,colon_found);
}

string extract_var_name(const string& hdr_str) {
  size_t colon_found = hdr_str.find(":");
  assert( colon_found != string::npos);
  return hdr_str.substr(colon_found+1,string::npos);
}


class SurfaceWS {
public:

  vector<WingSection> ws_vec;
  double (*x_bf)[3]; // aggregate x_bf; assumes that the x_bf entries as distinct...
  double *p;
  int nbf;
  int *bfozn;
  map<string,pair<int,int> > zone_map;

  Adt<double>* x_adt;

  SurfaceWS(vector<WingSection>& _ws_vec) : ws_vec(_ws_vec) {

    x_bf  = NULL;
    p     = NULL;
    nbf   = 0;
    bfozn = NULL;
    zone_map.clear();
    x_adt = NULL;


  }

  int init(const char* filename) {

    using namespace SurfVarNames;

    FILE *fp = fopen(filename, "rb");
    if ( !fp ) {
      cerr << " > unable to find a file.. " << filename << endl;
      return -1;
    }

    bool byte_swap = false;
    int itmp[2];
    fread(itmp,sizeof(int),2,fp);
    if ((itmp[0] != UGP_IO_MAGIC_NUMBER)&&(itmp[0] != UGP_IO_MAGIC_NUMBER+1)) {
      ByteSwap::byteSwap(itmp,2);
      if ((itmp[0] != UGP_IO_MAGIC_NUMBER)&&(itmp[0] != UGP_IO_MAGIC_NUMBER+1)) {
        cerr << "Error: file does not start as expected. aborting."<< endl;
        fclose(fp);
        return -1;
      }
      cout << "File requires byte swapping." << endl;
      byte_swap = true;
    }


    nbf           = 0;
    double * r_bf = NULL;

    for (int iter = 0; iter < 2; ++iter) {

      int8 offset = sizeof(int)*2;

      Header header;
      while (1) {

        fseek(fp, offset, SEEK_SET);
        fread(&header,sizeof(Header),1,fp);
        if ( byte_swap) ByteSwap::byteSwapHeader(&header,1);
        assert( header.skip > 0);

        if ( header.id == UGP_IO_EOF) {
          break;
        }

        string hdr_str(header.name);

        if ( iter == 0) {

          // first pass through we only need to grab the x_bf data..

          if ( (header.id == UGP_IO_BF_D2) && (hdr_str.find("x_bf") != string::npos) ) {

            string zone_name = extract_zone_name(hdr_str);
            if ( zone_map.find(zone_name) != zone_map.end()) {
              cerr << " oops: double defined boundary.. " << zone_name << "   " << hdr_str << endl;
              return -1;

            } else {

              cout << " > got x_bf for zone : " << zone_name << endl;

            }

            assert( header.idata[0] < TWO_BILLION);
            zone_map[zone_name] = pair<int,int>(header.idata[0],-1);
            nbf                += header.idata[0];

          }

        } else {


          // second pass through -- read the x_bf and p data ...

          if ( (header.id == UGP_IO_BF_D2) && (hdr_str.find(":x_bf") != string::npos) ) {

            const string zone_name        = extract_zone_name(hdr_str);
            map<string,pair<int,int> >::iterator  it = zone_map.find(zone_name);
            assert( it != zone_map.end());

            const int izn  = it->second.second;
            assert( header.idata[0] == it->second.first);  // make sure that the zone info matches...

            cout << " > reading " << hdr_str << " ... " ;
            fread(&(x_bf[bfozn[izn]][0]),sizeof(double),3*header.idata[0],fp);
            cout << " ok. " << endl;

          } else if ( (header.id == UGP_IO_BF_D1) && (hdr_str.find(":") != string::npos)) {

            // we actually need a more stringent check of the name here ...

            const string zone_name        = extract_zone_name(hdr_str);
            const string var_name         = extract_var_name(hdr_str);

            //cout << " XXXX " << hdr_str << "    " << var_name << endl;

            if ( var_name == pressure_var_name) {

              map<string,pair<int,int> >::iterator it = zone_map.find(zone_name);
              assert( it != zone_map.end());

              const int izn = it->second.second;
              assert( header.idata[0] == it->second.first);

              cout << " > reading " << hdr_str << " ... " ;
              fread(&p[bfozn[izn]],sizeof(double),header.idata[0],fp);
              cout << " ok. " << endl;

            } else if ( var_name == delta_var_name) {

              map<string,pair<int,int> >::iterator it = zone_map.find(zone_name);
              assert( it != zone_map.end());

              const int izn = it->second.second;
              assert( header.idata[0] == it->second.first);

              cout << " > reading " << hdr_str << " ... " ;
              fread(&r_bf[bfozn[izn]],sizeof(double),header.idata[0],fp);
              cout << " ok. " << endl;

            }
          }
        }

        offset += header.skip;

      }

      if ( iter == 0) {

        assert( nbf > 0 );
        cout << " > total number of nbf: " << nbf << endl;
        cout << " > total number of zns: " << zone_map.size() << endl;

        assert( x_bf == NULL);  x_bf = new double[nbf][3];
        assert( p    == NULL);  p    = new double[nbf];
        assert( r_bf == NULL);  r_bf = new double[nbf];

        // set the zone ordering by the order they appear in the zone map.

        assert( bfozn == NULL); bfozn = new int[zone_map.size()+1];
        bfozn[0] = 0;
        int izn = 0;
        for (map<string,pair<int,int> >::iterator it = zone_map.begin(); it != zone_map.end(); ++it) {
          bfozn[izn+1]      = it->second.first + bfozn[izn];
          it->second.second = izn;
          ++izn;
        }
        assert(bfozn[zone_map.size()] == nbf);

      }

    }//iter..

    fclose(fp);

    if ( byte_swap) {
      ByteSwap::byteSwap(x_bf,nbf);
      ByteSwap::byteSwap(p,nbf);
      ByteSwap::byteSwap(r_bf,nbf);
    }
    
    // lastly build the adt we need to find the points...
    // since the span is along the y coordinate --- we are building
    // an adt with inflated boxes in the other two dimensions.

    double (*bbmin)[3] = new double[nbf][3];
    double (*bbmax)[3] = new double[nbf][3];

    for (int ibf = 0; ibf < nbf; ++ibf) {

      // wing coord is along y ..

      bbmin[ibf][1] = x_bf[ibf][1] - 2.0*r_bf[ibf];
      bbmax[ibf][1] = x_bf[ibf][1] + 2.0*r_bf[ibf];

      bbmin[ibf][0] = -1.0e+20;
      bbmax[ibf][0] =  1.0e+20;

      bbmin[ibf][2] = -1.0e+20;
      bbmax[ibf][2] =  1.0e+20;

    }

    cout << " > building adt... " ; cout.flush();

    x_adt = new Adt<double>(nbf,bbmin,bbmax);

    cout << " ok. " << endl;

    delete[] bbmin;
    delete[] bbmax;
    delete[] r_bf;

    return 0;

  }

  void extract() {

    for (int iws = 0, nws = ws_vec.size(); iws < nws; ++iws) {

      cout << " > iws, working on point: " << iws+1 << " ,  "
                                           << ws_vec[iws].xs[0] << "    "
                                           << ws_vec[iws].xs[1] << "    "
                                           << ws_vec[iws].xs[2] << endl;

      vector<int> idx_vec;
      x_adt->buildListForPoint(idx_vec,ws_vec[iws].xs);

      char filename[128];
      sprintf(filename,"ws%d_extract.dat",iws+1);
      FILE * fp = fopen(filename,"w");

      for (int ii = 0, nn = idx_vec.size(); ii < nn; ++ii) {

        const int ibf = idx_vec[ii];
        fprintf(fp, "%12.8g   %12.8g   %12.8g   %12.8g\n",
                x_bf[ibf][0], x_bf[ibf][2], (x_bf[ibf][0] - ws_vec[iws].xs[0])/ws_vec[iws].chord,
                p[ibf]);

      }

      fclose(fp);

    }

  }

  ~SurfaceWS() {

    if ( x_bf != NULL) delete[] x_bf;
    if ( p    != NULL) delete[] p;
    delete x_adt;

  }
};

int main(const int argc, const char* argv[]) {

  // sample wing sections from the nasa common research model...
  // instantiate the wing sections from the nasa dpw data ...

  vector<WingSection> ws_vec;
  ws_vec.push_back(WingSection(993.728, 121.459, 176.053,466.466,0.1050));  // station 1.
  ws_vec.push_back(WingSection(1002.168, 133.026, 176.306,459.571,0.1150)); // station 2.
  ws_vec.push_back(WingSection(1010.656, 144.594, 176.539,452.687,0.1250)); // station 3.
  ws_vec.push_back(WingSection(1015.435, 151.074, 176.659,448.836,0.1306)); // station 4.
  ws_vec.push_back(WingSection(1076.873, 232.444, 177.509,400.743,0.2009)); // station 5.
  ws_vec.push_back(WingSection(1148.974, 327.074, 178.606,344.991,0.2828)); // station 6.
  ws_vec.push_back(WingSection(1202.038, 396.765, 180.222,304.101,0.3430)); // station 7.
  ws_vec.push_back(WingSection(1225.822, 427.998, 181.162,285.806,0.3700)); // station 8.
  ws_vec.push_back(WingSection(1249.711, 459.370, 182.250,278.111,0.3971)); // station 9.
  ws_vec.push_back(WingSection(1342.440, 581.148, 188.658,248.312,0.5024)); // station 10.
  ws_vec.push_back(WingSection(1430.914, 697.333, 198.060,219.904,0.6028)); // station 11.
  ws_vec.push_back(WingSection(1540.091, 840.704, 213.659,184.844,0.7268)); // station 12.
  ws_vec.push_back(WingSection(1644.738, 978.148, 233.317,151.235,0.8456)); // station 13.
  ws_vec.push_back(WingSection(1736.708,1098.926, 253.727,121.735,0.9500)); // station 14.
  ws_vec.push_back(WingSection(1754.313,1122.048, 257.777,116.095,0.9700)); // station 15.
  ws_vec.push_back(WingSection(1771.927,1145.183, 261.823,110.452,0.9900)); // station 16.


  // because the grid we used is scaled in meters based on the lab scaled model,
  // we need to covert the units...

  for (int iws = 0, nws = ws_vec.size(); iws < nws; ++iws) {

    ws_vec[iws].convertToScaleMeters();

  }

  // load a snapshot field that contains the x_bf, p average..

  if ( argc < 2) {

    cerr << " Usage: ./ws_post <snapshot-field> " << endl;
    return 1;

  }

  SurfaceWS sectional(ws_vec);
  sectional.init(argv[1]);
  sectional.extract();

  return 0;
}
