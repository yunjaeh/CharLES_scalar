#include "SimpleSurface.hpp"

void SimpleSurface::writeStitchInputFile(const string& filename, const bool withHelp) const {
  COUT1("Surface::writeStitchInputFile(" << filename << ")");

  FILE * fp = fopen(filename.c_str(),"w");
  vector<string> input_file = buildStitchInputFile(withHelp);

  const string slash = "\\\\";

  for (vector<string>::iterator it=input_file.begin(); it!=input_file.end(); ++it) {
    string line = *it;

    // replace 4x slash with 2x slash (appropriate for json vs. fprintf of a "\")
    std::size_t found = line.find(slash);
    while (found != string::npos) {
      line.replace(found,slash.length(),"\\");
      found = line.find(slash);
    }
    fprintf(fp,"%s\n",line.c_str());
  }

  fclose(fp);

}

vector<string> SimpleSurface::buildStitchInputFile(const bool withHelp) const {

  COUT2("Surface::buildStitchInputFile()");

  vector<string> input_file;

  // header section
  input_file.push_back("# template Stitch.in generated by Surfer");
  input_file.push_back("# NOTE: commands are interpreted in order from top to bottom;");
  input_file.push_back("#       subsequent commands may overwrite previous information");

  if (withHelp) input_file.push_back("# Including the VERBOSE flag will enhance the information printed to stdout");
  input_file.push_back("VERBOSE");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# This template assumes a single mesh part is being constructed");
  }
  input_file.push_back("PART \\\\");
  input_file.push_back("  SURF=SBIN <surface file> \\\\");

  if (zone_level_hcp_delta > 0.0) {
    const string hcp_delta = static_cast<ostringstream*>( &(stringstream().flush() << "PTS=HCP HCP_DELTA=" << zone_level_hcp_delta) )->str();
    input_file.push_back(hcp_delta);
  }
  else input_file.push_back("  PTS=HCP  # optional specification; HCP is used by default");
  input_file.push_back("");
  if (withHelp) input_file.push_back("# specify the background (i.e., coarsest) length scale");
  input_file.push_back("HCP_DELTA=<lengthscale>");

  // refinement windows
  if (withHelp) {
    input_file.push_back("# available boundary zone refinement windows are listed below. Uncomment");
    input_file.push_back("# a line and adjust the parameters to specify a local refinement region.");
    input_file.push_back("# * LEVEL <level> refers to the refinement relative to HCP_DELTA by powers of 0.5^{level}");
    input_file.push_back("# * NLAYERS <n> refers to cell thickness of nested refinement windows");
  }

  // use suggested Level-per-zone if found
  if (zone_level_hcp_delta > 0.0) {
    for (int izone=0, limit=zoneVec.size(); izone < limit; ++izone) {
      const string izone_window = static_cast<ostringstream*>( &(stringstream().flush() << "HCP_WINDOW FAZONE " << zoneVec[izone].getName() << " LEVEL=" << zoneVec[izone].getLevel() << " NLAYERS=5" ) )->str();
      if (zoneVec[izone].getLevel() == 0) input_file.push_back("#"+izone_window);  // comment out refinement windows that do nothing (level=0)
      else input_file.push_back(izone_window);
    }
  }
  else {
    for (int izone=0, limit=zoneVec.size(); izone < limit; ++izone) {
      input_file.push_back("#HCP_WINDOW FAZONE " + zoneVec[izone].getName() + " LEVEL=1 NLAYERS=5");
    }
  }
  // list available geometric refinement windows here?
  if (withHelp) {
    input_file.push_back("# refinement windows based on geometric primitives are also available");
    input_file.push_back("# refer to the CWI Knowledge Base for more information");
  }

  if (withHelp) {
    input_file.push_back("");
    input_file.push_back("# to interact with Stitch after seeding but before mesh generation, pause via:");
    input_file.push_back("#INTERACTIVE");
  }

  input_file.push_back("");
  if (withHelp) input_file.push_back("# Lloyd iteration controls and rendering of the mesh");
  input_file.push_back("NSMOOTH = 10");

  if (withHelp) {
    input_file.push_back("");
    input_file.push_back("# to interact with Stitch after the mesh has been rendered pause via:");
    input_file.push_back("#INTERACTIVE");
  }

  // output section
  input_file.push_back("");
  if (withHelp) {
    input_file.push_back("# Uncomment these lines to write result files valid with legacy CTI tools:");
    input_file.push_back("#WRITE_RESTART_V4 restart_v4.les  # compatible with \"nextgen\" solvers");
    input_file.push_back("#WRITE_RESTART_V4 restart_v3.les  # compatible with \"cti_core/cti_solver\" solvers");

    input_file.push_back("# Write a mesh file:");
  }
  input_file.push_back("WRITE_MLES <mesh-filename>.mles");

  return input_file;
}

void SimpleSurface::writeCharlesInputFile(const string& filename, const int eos, const bool withHelp) const {
  COUT1("Surface::writeCharlesInputFile(" << filename << ")");

  FILE * fp = fopen(filename.c_str(),"w");
  vector<string> input_file = buildCharlesInputFile(eos,withHelp);

  for (vector<string>::iterator it=input_file.begin(); it!=input_file.end(); ++it) {
    string line = *it;
    fprintf(fp,"%s\n",line.c_str());
  }
  fclose(fp);

}

vector<string> SimpleSurface::buildCharlesInputFile(const int eos, const bool withHelp) const {

  COUT2("Surface::buildCharlesInputFile()");
  vector<string> input_file;

  // header section
  input_file.push_back("# template Charles.in generated by Surfer");
  input_file.push_back("");


  if (withHelp) input_file.push_back("# Including the VERBOSE flag will enhance the information printed to stdout");
  input_file.push_back("VERBOSE");

  input_file.push_back("");
  if (withHelp) input_file.push_back("# Restart file can be specified by just a mesh or from both a mesh and corresponding solution");
  input_file.push_back("RESTART = <restart.mles> <restart.sles>");

  if (withHelp) input_file.push_back("# If only a mesh is specified via RESTART, the user can optionally initialize the flow from a previous solution (from a different mesh) via interpolation");
  input_file.push_back("# INTERP_FROM_RESTART = <restart-to-interpolate>");

  input_file.push_back("");
  if (withHelp) {
    input_file.push_back("# Time integration specifications:");
    input_file.push_back("# CHECK_INTERVAL specifies how frequently information is logged via stdout");
    input_file.push_back("CHECK_INTERVAL=<interval>");
    input_file.push_back("# valid TIMESTEP options are:");
    input_file.push_back("# - DT=<constant dt>");
    input_file.push_back("# - CFL=<constant cfl>");
  }
  input_file.push_back("TIMESTEP DT=<dt>");

  input_file.push_back("");
  if (withHelp) input_file.push_back("# valid simulation runtime control options, to use simply uncomment one of the below options:");
  input_file.push_back("#NSTEPS=<fixed number of time steps>");
  input_file.push_back("#RUNTIME=<wallclock time limit>");

  input_file.push_back("");
  if (withHelp) input_file.push_back("# specification of the sub-gridscale model:");
  input_file.push_back("SGS_MODEL=VREMAN");

  input_file.push_back("");
  if (eos == 0) {
    buildIdealGasInputOptions(input_file,withHelp);
  }
  else if (eos == 1) {
    buildPremixedInputOptions(input_file,withHelp);
  }
  else if (eos == 2) {
    buildNonPremixedInputOptions(input_file,withHelp);
  }
  else {
    if (eos != -1) CWARN("problem parsing eos; defaulting to IDEAL_GAS");
    buildIdealGasInputOptions(input_file,withHelp);
  }

  input_file.push_back("");
  if (withHelp) {
    input_file.push_back("# Tecplot output options:");
    input_file.push_back("#WRITE_DATA NAME=<filename> INTERVAL=<interval> GEOM=<geometry> VARS=<variables>");

    input_file.push_back("");
    input_file.push_back("# Image output options:");
    input_file.push_back("#WRITE_IMAGE NAME=<filename> INTERVAL=<interval> GEOM=<geometry> VAR=<variable> ");

    input_file.push_back("");
    input_file.push_back("# CTI restart file output options:");
    input_file.push_back("#WRITE_RESULT <interval>");

    input_file.push_back("");
    input_file.push_back("# CTI snapshot file output options:");
    input_file.push_back("#WRITE_SNAPSHOT <interval>");
  }

  return input_file;
}

void SimpleSurface::buildIdealGasInputOptions(vector<string>& input_file, const bool withHelp) const {
  COUT2(" > using ideal gas template");

  if (withHelp) input_file.push_back("# equation of state type:");
  input_file.push_back("EOS IDEAL_GAS");

  if (withHelp) {
    input_file.push_back("# Specification of gas properties:");
    input_file.push_back("# the following parameters require specification");
  }
  input_file.push_back("P_REF   <value>");
  input_file.push_back("RHO_REF <value>");
  input_file.push_back("T_REF   <value>");
  input_file.push_back("MU_REF  <value>");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# the following parameters can be uncommented to adjust from their default values (displayed)");
    input_file.push_back("#GAMMA        1.4");
    input_file.push_back("#MU_POWER_LAW 0.76");
    input_file.push_back("#PR_LAM       0.7");
    input_file.push_back("#C_DISS       1.0");
    input_file.push_back("");
  }

  if (withHelp) input_file.push_back("# Initial condition specification:");
  input_file.push_back("INIT_RUP <rho> <ux> <uy> <uz> <p>");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# Boundary condition specification:");
    input_file.push_back("# Common options for IDEAL_GAS are");
    input_file.push_back("#  - SLIP or SYMMETRY");
    input_file.push_back("#  - CBC_UPT");
    input_file.push_back("#  - CBC_MPT");
    input_file.push_back("#  - CBC_RUNP");
    input_file.push_back("#  - CBC_RUP");
    input_file.push_back("#  - CBC_TOTAL_PT");
    input_file.push_back("#  - NSCBC_MT");
    input_file.push_back("#  - NSCBC_OUTLET_P");
    input_file.push_back("#  - WALL_ISOTHERMAL");
    input_file.push_back("#  - WALL_ADIABATIC (template default)");
    input_file.push_back("# please refer to the CWI Knowledge Base for additional options and parameters");
    input_file.push_back("");
  }
  for (int izone=0, limit=zoneVec.size(); izone < limit; ++izone) {
    if (zoneVec[izone].isBCPeriodic()) {
      input_file.push_back("#" + zoneVec[izone].getName() + " = (periodic)");
    }
    else {
      input_file.push_back(zoneVec[izone].getName() + " = " + zoneVec[izone].getBC() + "");
    }
  }
}

void SimpleSurface::buildPremixedInputOptions(vector<string>& input_file, const bool withHelp) const {
  COUT2(" > using premixed reacting flow template");

  if (withHelp) input_file.push_back("# equation of state type:");
  input_file.push_back("EOS PREMIXED");
  input_file.push_back("");

  if (withHelp) input_file.push_back("# Specification of chemtable:");
  input_file.push_back("CHEMTABLE <chemtable>");
  input_file.push_back("");

  if (withHelp) input_file.push_back("# Initial condition specification:");
  input_file.push_back("INIT_US_AT_TABLE <ux> <uy> <uz> <Z> <C>");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# Ignition specification:");
    input_file.push_back("#  - GEOM=SPHERE (currently only supported geometry, though multiple can exist)");
  }
  input_file.push_back("#IGNITE GEOM=<geometry>");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# Boundary condition specification:");
    input_file.push_back("# Common options for PREMIXED are");
    input_file.push_back("#  - SLIP or SYMMETRY");
    input_file.push_back("#  - CBC_UPTS");
    input_file.push_back("#  - CBC_MPTS");
    input_file.push_back("#  - CBC_RUNPS");
    input_file.push_back("#  - CBC_RUPS");
    input_file.push_back("#  - NSCBC_MTS");
    input_file.push_back("#  - NSCBC_OUTLET_P");
    input_file.push_back("#  - WALL_ISOTHERMAL");
    input_file.push_back("#  - WALL_ADIABATIC (template default)");
    input_file.push_back("# please refer to the CWI Knowledge Base for additional options and parameters");
  }
  input_file.push_back("");
  for (int izone=0, limit=zoneVec.size(); izone < limit; ++izone) {
    if (zoneVec[izone].isBCPeriodic()) {
      input_file.push_back("#" + zoneVec[izone].getName() + " = (periodic)");
    }
    else {
      input_file.push_back(zoneVec[izone].getName() + " = " + zoneVec[izone].getBC() + "S");
    }
  }
}

void SimpleSurface::buildNonPremixedInputOptions(vector<string>& input_file, const bool withHelp) const {
  COUT2(" > using nonpremixed reacting flow template");

  if (withHelp) input_file.push_back("# Specification of chemtable:");
  input_file.push_back("CHEMTABLE <chemtable>");
  input_file.push_back("");

  if (withHelp) input_file.push_back("# Initial condition specification:");
  input_file.push_back("INIT_US_AT_TABLE <ux> <uy> <uz> <Z> <C>");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# Ignition specification:");
    input_file.push_back("#  - GEOM=SPHERE (currently only supported geometry, though multiple can exist)");
  }
  input_file.push_back("#IGNITE GEOM=<geometry>");
  input_file.push_back("");

  if (withHelp) {
    input_file.push_back("# Boundary condition specification:");
    input_file.push_back("# Valid options for NONPREMIXED are");
    input_file.push_back("#  - SLIP or SYMMETRY");
    input_file.push_back("#  - CBC_UPTS");
    input_file.push_back("#  - CBC_MPTS");
    input_file.push_back("#  - CBC_RUNPS");
    input_file.push_back("#  - CBC_RUPS");
    input_file.push_back("#  - NSCBC_MTS");
    input_file.push_back("#  - NSCBC_OUTLET_P");
    input_file.push_back("#  - WALL_ISOTHERMAL");
    input_file.push_back("#  - WALL_ADIABATIC (template default)");
    input_file.push_back("# please refer to the CWI Knowledge Base for additional options and parameters");
    input_file.push_back("");
  }
  for (int izone=0, limit=zoneVec.size(); izone < limit; ++izone) {
    if (zoneVec[izone].isBCPeriodic()) {
      input_file.push_back("#" + zoneVec[izone].getName() + " = (periodic)");
    }
    else {
      input_file.push_back(zoneVec[izone].getName() + " = " + zoneVec[izone].getBC() + "S");
    }
  }
}

void SimpleSurface::writeFluxProbesCylinder(const string& name,const int isz,const int isz_prev,const int isz_next,const bool b_write_image,const double up[3]) {

  // made it

  cout << "writeFluxProbesCylinder: " << name << " " << isz << " " << isz_prev << " " << isz_next << endl;

  assert((isz >= 0)&&(isz < nsz));
  assert((isz_prev >= 0)&&(isz_prev < nsz));
  assert((isz_next >= 0)&&(isz_next < nsz));

  // we need teost to do edge walking...

  ensureTeost();

  st_flag.setLength(nst);
  st_flag.setAll(0);

  double d_sum = 0.0;
  double d2_sum = 0.0;
  double n_sum = 0.0;
  double n2_sum = 0.0;
  int count = 0;

  FILE * fp = fopen((name+".fp_params").c_str(),"w");
  assert(fp != NULL);

  stack<int> stStack;
  for (int ist_seed = 0; ist_seed < nst; ++ist_seed) {
    if ((szost[ist_seed] == isz)&&(st_flag[ist_seed] == 0)) {
      // this is a seed -- march out to get the cylinder...
      double xc0[3] = { 0.0, 0.0, 0.0 };
      double wgt0 = 0.0;
      int n0 = 0;
      double xc1[3] = { 0.0, 0.0, 0.0 };
      double wgt1 = 0.0;
      int n1 = 0;
      st_flag[ist_seed] = 1;
      stStack.push(ist_seed);
      while (!stStack.empty()) {
	const int ist = stStack.top(); stStack.pop();
	FOR_I3 {
	  // use teost to check edge nbr...
	  int ist_nbr,i_nbr,orient_nbr;
	  if (getTriNbrData(ist_nbr,i_nbr,orient_nbr,ist,i)) {
	    if (szost[ist_nbr] != isz) {
	      // this is an edge along another subzone...
	      const int isp0 = spost[ist][i];
	      const int isp1 = spost[ist][(i+1)%3];
	      const double wgt = DIST(xsp[isp0],xsp[isp1]);
	      if (isz_prev == szost[ist_nbr]) {
		FOR_I3 xc0[i] += wgt*(xsp[isp0][i]+xsp[isp1][i]);
		wgt0 += wgt;
		++n0; // number of segments...
	      }
	      else if (isz_next == szost[ist_nbr]) {
		FOR_I3 xc1[i] += wgt*(xsp[isp0][i]+xsp[isp1][i]);
		wgt1 +=wgt;
		++n1;
	      }
	      else {
		cout << "Error: unexpected cylinder subzone: " << szost[ist_nbr] << endl;
		assert(0);
	      }
	    }
	    else if (st_flag[ist_nbr] == 0) {
	      st_flag[ist_nbr] = 1;
	      stStack.push(ist_nbr);
	    }
	  }
	  else {
	    cout << "Error: open edges not supported in cylinder selection" << endl;
	    assert(0);
	  }
	}
      }
      // make sure we got the two defining edges...
      assert(n0 > 0);
      assert(n1 > 0);
      // note that wgt0, wgt1 contains the circumference...
      //cout << " d0: " << wgt0/M_PI << " n0: " << n0 << " d1: " << wgt1/M_PI << " n1: " << n1 << endl;
      FOR_I3 xc0[i] /= 2.0*wgt0;
      FOR_I3 xc1[i] /= 2.0*wgt1;
      // stats...
      ++count;
      const double d_avg = 0.5*(wgt0/M_PI + wgt1/M_PI);
      d_sum += d_avg;
      d2_sum += d_avg*d_avg;
      const double n_avg = 0.5*double(n0+n1);
      n_sum += n_avg;
      n2_sum += n_avg*n_avg;
      const double dx[3] = DIFF(xc1,xc0);
      const double mag = MAG(dx);
      assert(mag > 0.0);
      fprintf(fp,"FLUX_PROBE NAME probes/%s_%04d INTERVAL III XP %lf %lf %lf NP %lf %lf %lf VARS mass_flux() mass_flux(Z) mass_flux(T)\n",
	      name.c_str(),count,0.5*(xc0[0]+xc1[0]),0.5*(xc0[1]+xc1[1]),0.5*(xc0[2]+xc1[2]),dx[0]/mag,dx[1]/mag,dx[2]/mag);
      if (b_write_image) {
	// to write an image for the probe, we orient the image and set the width based on the cylinder axis and direction...
	const double plane_n[3] = CROSS_PRODUCT(dx,up);
	const double mag_plane_n = MAG(plane_n);
	assert(mag_plane_n > 0.0);
	fprintf(fp,"WRITE_IMAGE NAME images/%s_%04d INTERVAL III VAR mesh GEOM PLANE %lf %lf %lf %lf %lf %lf UP %lf %lf %lf WIDTH %lf SIZE 2000 2000\n",
		name.c_str(),count,0.5*(xc0[0]+xc1[0]),0.5*(xc0[1]+xc1[1]),0.5*(xc0[2]+xc1[2]),
		plane_n[0]/mag_plane_n,plane_n[1]/mag_plane_n,plane_n[2]/mag_plane_n,
		up[0],up[1],up[2],10.0*mag);
      }
    }
  }

  fclose(fp);
  cout << " > output writen to \"" << name << ".fp_params\"" << endl;

  d_sum /= double(count);
  n_sum /= double(count);
  cout << " > found " << count << " disjoint cylinders. Average D=" << d_sum << ", RMS=" << sqrt(max(0.0,d2_sum/double(count)-d_sum*d_sum)) << " Average n segments: " << n_sum << endl;

}
